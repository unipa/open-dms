function _wrapRegExp() { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, void 0, groups); }; var _super = RegExp.prototype, _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = new RegExp(re, flags); return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype); } function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { var i = g[name]; if ("number" == typeof i) groups[name] = result[i];else { for (var k = 0; void 0 === result[i[k]] && k + 1 < i.length;) k++; groups[name] = result[i[k]]; } return groups; }, Object.create(null)); } return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) { result.groups = buildGroups(result, this); var indices = result.indices; indices && (indices.groups = buildGroups(indices, this)); } return result; }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if ("string" == typeof substitution) { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { var group = groups[name]; return "$" + (Array.isArray(group) ? group.join("$") : group); })); } if ("function" == typeof substitution) { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = arguments; return "object" != typeof args[args.length - 1] && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args); }); } return _super[Symbol.replace].call(this, str, substitution); }, _wrapRegExp.apply(this, arguments); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
import { keys } from 'min-dash';
export const operators = {
  equals: '=',
  less: '<',
  lessEquals: '<=',
  greater: '>',
  greaterEquals: '>='
};
function getOperatorName(string) {
  return keys(operators).filter(key => {
    return string === operators[key];
  })[0];
}
export function parseDuration(text) {
  if (!text || isEmptyString(text.trim())) {
    return {
      type: 'comparison',
      values: []
    };
  }
  const parsedComparison = parseComparison(text);
  if (parsedComparison) {
    return parsedComparison;
  }
  const parsedRange = parseRange(text);
  if (parsedRange) {
    return parsedRange;
  }
}
export function isEmptyString(string) {
  return string === '';
}
export function getComparisonString(comparisonOperator, comparisonValue) {
  if (comparisonOperator === 'equals') {
    return "duration(\"".concat(comparisonValue, "\")");
  } else {
    return "".concat(operators[comparisonOperator], " duration(\"").concat(comparisonValue, "\")");
  }
}
export function getRangeString(rangeStartValue, rangeEndValue, rangeStartType, rangeEndType) {
  const rangeStartChar = rangeStartType === 'exclude' ? ']' : '[',
    rangeEndChar = rangeEndType === 'exclude' ? '[' : ']';
  return "".concat(rangeStartChar, "duration(\"").concat(rangeStartValue, "\")") + "..duration(\"".concat(rangeEndValue, "\")").concat(rangeEndChar);
}
export function validateDuration(type, value) {
  if (type === 'yearMonthDuration') {
    return validateYearMonthDuration(value);
  } else if (type === 'dayTimeDuration') {
    return validateDayTimeDuration(value);
  }
}
function validateYearMonthDuration(value) {
  return /^P(\d+Y\d+M|\d+Y|\d+M)$/.test(value);
}
function validateDayTimeDuration(value) {
  return /^P(\d+DT\d+H|\d+D|T\d+H)$/.test(value);
}
export function withoutDurationCall(text) {
  const result = /^duration\("([^"]*)"\)$/.exec(text);
  return result && result[1];
}
function parseComparison(text) {
  const exactValue = withoutDurationCall(text);
  if (exactValue) {
    return {
      type: 'comparison',
      operator: 'equals',
      values: [exactValue]
    };
  }
  const _match = match( /*#__PURE__*/_wrapRegExp(/^(=|(:?<|>)=?)\s*duration\("([^"]*)"\)$/, {
      operator: 1,
      value: 3
    }), text),
    operator = _match.operator,
    value = _match.value;
  if (operator && value) {
    return {
      type: 'comparison',
      values: [value],
      operator: getOperatorName(operator)
    };
  }
}
function parseRange(text) {
  const _match2 = match( /*#__PURE__*/_wrapRegExp(/^([[\]])duration\("([^"]*)"\)\.\.duration\("([^"]*)"\)([[\]])$/, {
      start: 1,
      firstValue: 2,
      secondValue: 3,
      end: 4
    }), text),
    start = _match2.start,
    end = _match2.end,
    firstValue = _match2.firstValue,
    secondValue = _match2.secondValue;
  if (start && end) {
    return {
      type: 'range',
      values: [firstValue, secondValue],
      start: start === ']' ? 'exclude' : 'include',
      end: end === '[' ? 'exclude' : 'include'
    };
  }
}
function match(regex, input) {
  const _ref = regex.exec(input) || {
      groups: {}
    },
    groups = _ref.groups;
  return groups;
}
//# sourceMappingURL=Utils.js.map