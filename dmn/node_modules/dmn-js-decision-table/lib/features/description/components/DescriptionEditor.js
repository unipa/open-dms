import { createVNode, createComponentVNode } from "inferno";
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import { Component } from 'inferno';
import { isString } from 'min-dash';
import { query as domQuery } from 'min-dom';
import EditableComponent from 'dmn-js-shared/lib/components/EditableComponent';
export default class DescriptionEditor extends Component {
  constructor(props, context) {
    super(props, context);
    _defineProperty(this, "onElementsChanged", () => {
      this.forceUpdate();
    });
    _defineProperty(this, "changeDescription", value => {
      this._modeling.updateProperties(this._element, {
        description: value
      });
    });
    this._elementRegistry = context.injector.get('elementRegistry');
    this._modeling = context.injector.get('modeling');
    this._changeSupport = this.context.changeSupport;
    const id = this.props.context.id;
    this._element = this._elementRegistry.get(id);
  }
  componentWillMount() {
    if (this._element) {
      this._changeSupport.onElementsChanged(this._element.id, this.onElementsChanged);
    }
  }
  componentDidMount() {
    const autoFocus = this.props.context.autoFocus;
    if (autoFocus && this.node) {
      const editor = getEditor(this.node);
      editor.focus();
    }
  }
  componentWillUnmount() {
    if (this._element) {
      this._changeSupport.offElementsChanged(this._element.id, this.onElementsChanged);
      const businessObject = this._element.businessObject;
      const description = businessObject.description;

      // if empty description remove description
      if (isString(description) && !description.length) {
        this.changeDescription(null);
      }
    }
  }
  render() {
    if (!this._element) {
      return;
    }
    const businessObject = this._element.businessObject;
    const description = businessObject.description;
    if (!isString(description)) {
      return;
    }
    return createVNode(1, "div", "context-menu-container description-editor", createComponentVNode(2, Editor, {
      "className": "dms-input",
      "onChange": this.changeDescription,
      "value": description
    }), 2, null, null, node => this.node = node);
  }
}
class Editor extends EditableComponent {
  render() {
    return createVNode(1, "div", this.getClassName(), this.getEditor(), 0);
  }
}

// helpers //////////

function getEditor(container) {
  return domQuery('.content-editable', container);
}
//# sourceMappingURL=DescriptionEditor.js.map