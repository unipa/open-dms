import { createVNode } from "inferno";
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import { Component } from 'inferno';
import { mixin } from 'table-js/lib/components';
import { ComponentWithSlots } from 'dmn-js-shared/lib/components/mixins';
export default class InputCell extends Component {
  constructor(props, context) {
    super(props, context);
    _defineProperty(this, "onClick", event => {
      const input = this.props.input;
      this._eventBus.fire('input.edit', {
        event,
        input
      });
    });
    _defineProperty(this, "onContextmenu", event => {
      const id = this.props.input.id;
      this._eventBus.fire('cell.contextmenu', {
        event,
        id
      });
    });
    _defineProperty(this, "onElementsChanged", () => {
      this.forceUpdate();
    });
    mixin(this, ComponentWithSlots);
    this._translate = context.injector.get('translate');
  }
  componentWillMount() {
    const injector = this.context.injector;
    this._changeSupport = this.context.changeSupport;
    this._sheet = injector.get('sheet');
    this._eventBus = injector.get('eventBus');
    this._elementRegistry = injector.get('elementRegistry');
    const root = this._sheet.getRoot();
    const input = this.props.input;
    this._changeSupport.onElementsChanged(root.id, this.onElementsChanged);
    this._changeSupport.onElementsChanged(input.id, this.onElementsChanged);
  }
  componentWillUnmount() {
    const root = this._sheet.getRoot();
    const input = this.props.input;
    this._changeSupport.offElementsChanged(root.id, this.onElementsChanged);
    this._changeSupport.offElementsChanged(input.id, this.onElementsChanged);
  }
  render() {
    const _this$props = this.props,
      input = _this$props.input,
      index = _this$props.index,
      inputsLength = _this$props.inputsLength;
    const inputExpression = input.inputExpression,
      inputValues = input.inputValues;
    const label = input.get('label');
    const width = input.width ? input.width + 'px' : '192px';
    return createVNode(1, "th", "input-cell input-editor", [this.slotFills({
      type: 'cell-inner',
      context: {
        cellType: 'input-cell',
        col: this._elementRegistry.get(input.id),
        index,
        inputsLength
      },
      col: input
    }), createVNode(1, "div", "clause", index === 0 ? this._translate('When') : this._translate('And'), 0), label ? createVNode(1, "div", "input-label", label, 0, {
      "title": this._translate('Input Label: ') + label
    }) : createVNode(1, "div", "input-expression", inputExpression.text, 0, {
      "title": this._translate('Input Expression: ') + inputExpression.text
    }), createVNode(1, "div", "input-variable", inputValues && inputValues.text || this._translate(inputExpression.typeRef || ''), 0, {
      "title": inputValues && inputValues.text ? this._translate('Input Values') : this._translate('Input Type')
    })], 0, {
      "data-col-id": input.id,
      "onDblClick": this.onClick,
      "onContextmenu": this.onContextmenu,
      "style": {
        width
      }
    });
  }
}
//# sourceMappingURL=InputCell.js.map