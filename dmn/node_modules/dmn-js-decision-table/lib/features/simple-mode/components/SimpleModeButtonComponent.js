import { createVNode } from "inferno";
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import { Component } from 'inferno';
import { assign } from 'min-dash';
import { closest as domClosest } from 'min-dom';
import { inject } from 'table-js/lib/components';
import { getNodeById } from '../../cell-selection/CellSelectionUtil';
import { isInput, isOutput } from 'dmn-js-shared/lib/util/ModelUtil';
const OFFSET = 4;
export default class SimpleModeButtonComponent extends Component {
  constructor(props, context) {
    super(props, context);
    this._translate = context.injector.get('translate');
    this.state = {
      top: 0,
      left: 0,
      isVisible: false,
      isDisabled: false,
      selection: null
    };
    inject(this);
    const debounceInput = this.debounceInput;
    this.onClick = this.onClick.bind(this);
    this.handleSelectionChanged = this.handleSelectionChanged.bind(this);
    this.hideAndShowDebounced = this.hideAndShowDebounced.bind(this);
    this.showDebounced = debounceInput(this.showDebounced.bind(this));
    this.updatePosition = this.updatePosition.bind(this);
  }
  componentDidMount() {
    const eventBus = this.eventBus;
    eventBus.on('cellSelection.changed', this.handleSelectionChanged);
    eventBus.on('commandStack.changed', this.updatePosition);
    eventBus.on('sheet.scroll', this.hideAndShowDebounced);
  }
  componentWillUnmount() {
    const eventBus = this.eventBus;
    eventBus.off('cellSelection.changed', this.handleSelectionChanged);
    eventBus.off('commandStack.changed', this.updatePosition);
    eventBus.off('sheet.scroll', this.hideAndShowDebounced);
  }
  hideAndShowDebounced() {
    if (this.state.isVisible) {
      this.hide();
      this.showDebounced();
    }
  }
  showDebounced() {
    this.show();
  }
  hide() {
    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.setState(_objectSpread(_objectSpread({}, state), {}, {
      isVisible: false
    }));
  }
  show() {
    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.setState(_objectSpread(_objectSpread({}, state), {}, {
      isVisible: true
    }));
    this.updatePosition();
  }
  handleSelectionChanged(_ref) {
    let elementId = _ref.elementId;
    const elementRegistry = this.elementRegistry,
      expressionLanguages = this.expressionLanguages,
      simpleMode = this.simpleMode;
    const selection = elementRegistry.get(elementId);
    if (!selection || !simpleMode.canSimpleEdit(selection)) {
      this.hide({
        isDisabled: false,
        selection: null
      });
      return;
    }
    const expressionLanguage = getExpressionLanguage(selection);
    const isDisabled = !isDefaultExpressionLanguage(selection, expressionLanguage, expressionLanguages);
    this.show({
      isDisabled,
      selection
    });
  }

  // position button always on opposite site of context menu
  updatePosition() {
    const selection = this.state.selection;
    const node = this.node;
    if (!selection || !node) {
      return;
    }
    const renderer = this.renderer;
    const container = renderer.getContainer(),
      containerBounds = container.getBoundingClientRect();
    const cellNode = getNodeById(selection.id, container);
    const cellBounds = cellNode.getBoundingClientRect();
    const nodeBounds = this.node.getBoundingClientRect();
    const _getTableContainerScr = getTableContainerScroll(node),
      scrollLeft = _getTableContainerScr.scrollLeft,
      scrollTop = _getTableContainerScr.scrollTop;
    const nodePosition = {};
    if (cellBounds.left + cellBounds.width / 2 > containerBounds.width / 2) {
      // left
      nodePosition.left = -containerBounds.left + cellBounds.left - nodeBounds.width + OFFSET + scrollLeft + 'px';
      node.classList.remove('right');
      node.classList.add('left');
    } else {
      // right
      nodePosition.left = -containerBounds.left + cellBounds.left + cellBounds.width - OFFSET + scrollLeft + 'px';
      node.classList.remove('left');
      node.classList.add('right');
    }
    if (cellBounds.top + cellBounds.height / 2 > containerBounds.height / 2) {
      // bottom
      nodePosition.top = -containerBounds.top + cellBounds.top - nodeBounds.height + OFFSET + scrollTop + 'px';
      node.classList.remove('top');
      node.classList.add('bottom');
    } else {
      // top
      nodePosition.top = -containerBounds.top + cellBounds.top - OFFSET + scrollTop + 'px';
      node.classList.remove('bottom');
      node.classList.add('top');
    }
    assign(this.node.style, nodePosition);
  }
  onClick() {
    const eventBus = this.eventBus;
    const isDisabled = this.state.isDisabled;
    if (isDisabled) {
      return;
    }
    const selection = this.selection;
    const element = selection.get();
    if (!element) {
      return;
    }
    eventBus.fire('simpleMode.open', {
      element,
      node: getNodeById(element.id, this._container)
    });
    this.hide();
  }
  render() {
    const _this$state = this.state,
      isDisabled = _this$state.isDisabled,
      isVisible = _this$state.isVisible,
      top = _this$state.top,
      left = _this$state.left;
    const classes = ['simple-mode-button', 'no-deselect'];
    if (isDisabled) {
      classes.push('disabled');
    }
    return isVisible ? createVNode(1, "div", classes.join(' '), createVNode(1, "span", "dmn-icon-edit"), 2, {
      "onClick": this.onClick,
      "style": {
        top,
        left
      },
      "title": isDisabled ? this._translate('Editing not supported for set expression language') : this._translate('Edit')
    }, null, node => this.node = node) : null;
  }
}
SimpleModeButtonComponent.$inject = ['debounceInput', 'elementRegistry', 'eventBus', 'expressionLanguages', 'renderer', 'selection', 'simpleMode'];

// helpers //////////////////////

/**
 * Return set expression language if found.
 *
 * @param {Cell} cell - Cell.
 */
function getExpressionLanguage(cell) {
  return cell.businessObject.expressionLanguage;
}
function isDefaultExpressionLanguage(cell, expressionLanguage, expressionLanguages) {
  return !expressionLanguage || expressionLanguage === getDefaultExpressionLanguage(cell, expressionLanguages);
}
function getDefaultExpressionLanguage(cell, expressionLanguages) {
  if (isInput(cell.col)) {
    return expressionLanguages.getDefault('inputCell').value;
  } else if (isOutput(cell.col)) {
    return expressionLanguages.getDefault('outputCell').value;
  }
}
function getTableContainerScroll(node) {
  const tableContainer = domClosest(node, '.tjs-table-container');
  if (!tableContainer) {
    return {
      scrollTop: 0,
      scrollLeft: 0
    };
  }
  const scrollLeft = tableContainer.scrollLeft,
    scrollTop = tableContainer.scrollTop;
  return {
    scrollTop,
    scrollLeft
  };
}
//# sourceMappingURL=SimpleModeButtonComponent.js.map