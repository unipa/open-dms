function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import { event as domEvent } from 'min-dom';
import { isCmd, isShift } from './KeyboardUtil';

/**
 * A keyboard abstraction that may be activated and
 * deactivated by users at will, consuming key events
 * and triggering diagram actions.
 *
 * The implementation fires the following key events that allow
 * other components to hook into key handling:
 *
 *  - keyboard.bind
 *  - keyboard.unbind
 *  - keyboard.init
 *  - keyboard.destroy
 *
 * All events contain the fields (node, listeners).
 *
 * A default binding for the keyboard may be specified via the
 * `keyboard.bindTo` configuration option.
 *
 * @param {Config} config
 * @param {EventBus} eventBus
 * @param {EditorActions} editorActions
 */
export default class Keyboard {
  constructor(config, eventBus, editorActions) {
    _defineProperty(this, "_init", () => {
      this._registerDefaultBindings();
      this._fire('init');
    });
    _defineProperty(this, "_destroy", () => {
      this._fire('destroy');
      this.unbind();
      this._listeners = null;
    });
    _defineProperty(this, "_keyHandler", event => {
      var i,
        l,
        listeners = this._listeners,
        code = event.keyCode || event.charCode || -1;
      for (i = 0; l = listeners[i]; i++) {
        if (l(code, event)) {
          event.preventDefault();
          event.stopPropagation();
          return;
        }
      }
    });
    _defineProperty(this, "unbind", () => {
      var node = this._node;
      if (node) {
        this._fire('unbind');

        // unbind key events
        domEvent.unbind(node, 'keydown', this._keyHandler, true);
      }
      this._node = null;
    });
    this._config = config || {};
    this._eventBus = eventBus;
    this._editorActions = editorActions;
    this._listeners = [];
    eventBus.on('viewer.destroy', this._destroy);
    eventBus.on('viewer.init', this._init);
    eventBus.on('attach', () => {
      if (this._config.bindTo) {
        this.bind(config.bindTo);
      }
    });
    eventBus.on('detach', this.unbind);
  }
  bind(node) {
    // make sure that the keyboard is only bound once to the DOM
    this.unbind();
    this._node = node;

    // bind key events
    domEvent.bind(node, 'keydown', this._keyHandler, true);
    this._fire('bind');
  }
  getBinding() {
    return this._node;
  }
  _fire(event) {
    this._eventBus.fire('keyboard.' + event, {
      node: this._node,
      listeners: this._listeners
    });
  }
  _registerDefaultBindings() {
    var listeners = this._listeners;
    var editorActions = this._editorActions;

    // init default listeners

    // undo
    // (CTRL|CMD) + Z
    function undo(key, modifiers) {
      if (isCmd(modifiers) && !isShift(modifiers) && key === 90) {
        editorActions.trigger('undo');
        return true;
      }
    }

    // redo
    // CTRL + Y
    // CMD + SHIFT + Z
    function redo(key, modifiers) {
      if (isCmd(modifiers) && (key === 89 || key === 90 && isShift(modifiers))) {
        editorActions.trigger('redo');
        return true;
      }
    }
    listeners.push(undo);
    listeners.push(redo);
  }

  /**
   * Add a listener function that is notified with (key, modifiers) whenever
   * the keyboard is bound and the user presses a key.
   *
   * @param {Function} listenerFn
   */
  addListener(listenerFn) {
    this._listeners.unshift(listenerFn);
  }
  removeListener(listenerFn) {
    this._listeners = this._listeners.filter(l => l !== listenerFn);
  }
}
Keyboard.$inject = ['config.keyboard', 'eventBus', 'editorActions'];
//# sourceMappingURL=Keyboard.js.map