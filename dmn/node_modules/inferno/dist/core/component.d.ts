import { Props, VNode, InfernoChildren, Refs } from './implementation';
export declare type ComponentType<P = {}> = ComponentClass<P> | StatelessComponent<P>;
export declare type SFC<P = {}> = StatelessComponent<P>;
export interface StatelessComponent<P = {}> {
    (props: P & {
        children?: InfernoChildren;
    }, context?: any): VNode<P> | null;
    defaultProps?: Partial<P>;
    displayName?: string;
    defaultHooks?: Refs<P>;
}
export interface ComponentClass<P = {}, S = {}> {
    new (props?: P, context?: any): Component<P, {}>;
    defaultProps?: Partial<P>;
    displayName?: string;
    refs?: any;
    componentDidMount?(): void;
    componentWillMount?(): void;
    componentWillReceiveProps?(nextProps: P, nextContext: any): void;
    shouldComponentUpdate?(nextProps: P, nextState: S, nextContext: any): boolean;
    componentWillUpdate?(nextProps: P, nextState: S, nextContext: any): void;
    componentDidUpdate?(prevProps: P, prevState: S, prevContext: any): void;
    componentWillUnmount?(): void;
    getChildContext?(): void;
}
export interface Component<P = {}, S = {}> extends ComponentClass<P, S> {
}
export declare class Component<P, S> {
    static defaultProps: any;
    state: S | null;
    props: Props<P, this> & P;
    context: any;
    refs?: any;
    $BR: boolean;
    $BS: boolean;
    $PSS: boolean;
    $PS: S | null;
    $LI: any;
    $V: VNode | null;
    $UN: boolean;
    $CX: null;
    $UPD: boolean;
    $QU: Function[] | null;
    constructor(props?: P, context?: any);
    forceUpdate(callback?: Function): void;
    setState(newState: {
        [k in keyof S]?: S[k];
    } | Function, callback?: Function): void;
    render(_nextProps: P, _nextState: any, _nextContext: any): InfernoChildren | void;
}
