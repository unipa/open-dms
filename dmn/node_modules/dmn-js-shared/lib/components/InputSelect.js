import { createVNode } from "inferno";
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import { Component, createPortal } from 'inferno';
import { inject } from 'table-js/lib/components';
import { assign } from 'min-dash';
import { domify, remove as domRemove } from 'min-dom';
export default class InputSelect extends Component {
  constructor(props, context) {
    super(props, context);
    _defineProperty(this, "onChange", value => {
      this.setState({
        value
      });
      const onChange = this.props.onChange;
      if (typeof onChange !== 'function') {
        return;
      }
      onChange(value);
    });
    _defineProperty(this, "onInputClick", event => {
      event.preventDefault();
      event.stopPropagation();
      this.setOptionsVisible(!this.state.optionsVisible);
      this.focusInput();
    });
    _defineProperty(this, "onInput", event => {
      const value = event.target.value;
      this.onChange(value);
    });
    _defineProperty(this, "onOptionClick", (value, event) => {
      event.preventDefault();
      event.stopPropagation();
      this.setOptionsVisible(false);
      this.onChange(value);
      this.focusInput();
    });
    _defineProperty(this, "onFocusChanged", evt => {
      this.checkClose(evt.target);
    });
    _defineProperty(this, "onGlobalClick", evt => {
      this.checkClose(evt.target);
    });
    _defineProperty(this, "onKeyDown", evt => {
      const optionsVisible = this.state.optionsVisible;
      var code = evt.which;

      // DOWN or UP
      if (code === 40 || code === 38) {
        evt.stopPropagation();
        evt.preventDefault();
        if (!optionsVisible) {
          this.setOptionsVisible(true);
        } else {
          this.select(code === 40 ? 1 : -1);
        }
      }
      if (optionsVisible) {
        // ENTER
        // ESC
        if (code === 13 || code === 27) {
          evt.stopPropagation();
          evt.preventDefault();
          this.setOptionsVisible(false);
        }
      }
    });
    _defineProperty(this, "onKeyboard", keycode => {
      const optionsVisible = this.state.optionsVisible;
      if (!optionsVisible) {
        return;
      }

      // close on ESC
      if (keycode === 27) {
        this.setOptionsVisible(false);
        return true;
      }
    });
    inject(this);
    const _value = props.value;
    this.state = {
      value: _value,
      optionsVisible: false
    };
    this._portalEl = null;
  }
  componentDidMount() {
    document.addEventListener('mousedown', this.onGlobalClick);
    document.addEventListener('focusin', this.onFocusChanged);
    this.keyboard.addListener(this.onKeyboard);
  }
  componentWillUnmount() {
    document.removeEventListener('focusin', this.onFocusChanged);
    document.removeEventListener('mousedown', this.onGlobalClick);
    this.keyboard.removeListener(this.onKeyboard);
    this.removePortalEl();
  }
  componentWillReceiveProps(props) {
    const value = props.value;
    this.setState({
      value
    });
  }
  componentWillUpdate(nextProps, nextState) {
    const optionsVisible = nextState.optionsVisible;
    if (optionsVisible) {
      if (!this._portalEl) {
        this.addPortalEl();
      }
    } else {
      if (this._portalEl) {
        this.removePortalEl();
      }
    }
  }
  componentDidUpdate() {
    const optionsVisible = this.state.optionsVisible;
    if (!optionsVisible || !this.inputNode) {
      return;
    }
    const optionsBounds = this.getOptionsBounds();
    assign(this._portalEl.style, optionsBounds);
  }
  getOptionsBounds() {
    const container = this.renderer.getContainer();
    const _container$getBoundin = container.getBoundingClientRect(),
      containerTop = _container$getBoundin.top,
      containerLeft = _container$getBoundin.left,
      containerBottom = _container$getBoundin.bottom;
    const _this$inputNode$getBo = this.inputNode.getBoundingClientRect(),
      inputTop = _this$inputNode$getBo.top,
      inputLeft = _this$inputNode$getBo.left,
      width = _this$inputNode$getBo.width,
      height = _this$inputNode$getBo.height,
      inputBottom = _this$inputNode$getBo.bottom;
    const top = inputTop + height - containerTop + container.scrollTop;
    const left = inputLeft - containerLeft + container.scrollLeft;
    const bounds = {
      top: "".concat(top, "px"),
      left: "".concat(left, "px"),
      width: "".concat(width, "px"),
      'max-height': "calc(100% - ".concat(top, "px)")
    };

    // open the options upwards when not even one option (=input height) fits
    if (containerBottom - inputBottom < height) {
      const bottom = containerBottom - inputTop;
      bounds.bottom = "".concat(bottom, "px");
      bounds['max-height'] = "calc(100% - ".concat(bottom, ")");
      delete bounds.top;
    }
    return bounds;
  }
  addPortalEl() {
    this._portalEl = domify('<div class="dms-select-options"></div>');
    const container = this.renderer.getContainer();
    container.appendChild(this._portalEl);

    // suppress mousedown event propagation to handle click events inside the component
    this._portalEl.addEventListener('mousedown', stopPropagation);
  }
  removePortalEl() {
    if (this._portalEl) {
      this._portalEl.removeEventListener('mousedown', stopPropagation);
      domRemove(this._portalEl);
      this._portalEl = null;
    }
  }
  /**
   * Focus input node
   */
  focusInput() {
    const node = this.inputNode;
    node.focus();

    // move cursor to end of input
    if ('selectionStart' in node) {
      node.selectionStart = 100000;
    }
  }
  checkClose(focusTarget) {
    if (this._portalEl && !this._portalEl.contains(focusTarget) && !this.parentNode.contains(focusTarget)) {
      this.setOptionsVisible(false);
    }
  }
  select(direction) {
    const options = this.props.options;
    const value = this.state.value;
    if (!options) {
      return;
    }
    const option = options.filter(o => o.value === value)[0];
    const idx = option ? options.indexOf(option) : -1;
    const nextIdx = idx === -1 ? direction === 1 ? 0 : options.length - 1 : (idx + direction) % options.length;
    const nextOption = options[nextIdx < 0 ? options.length + nextIdx : nextIdx];
    this.onChange(nextOption.value);
  }
  setOptionsVisible(optionsVisible) {
    this.setState({
      optionsVisible
    });
  }
  renderOptions(options, activeOption) {
    return createVNode(1, "div", "options", options.map(option => {
      return createVNode(1, "div", ['option', activeOption === option ? 'active' : ''].join(' '), option.label, 0, {
        "data-value": option.value,
        "onClick": e => this.onOptionClick(option.value, e)
      });
    }), 0);
  }
  render() {
    const _this$props = this.props,
      className = _this$props.className,
      options = _this$props.options,
      noInput = _this$props.noInput,
      title = _this$props.title;
    const _this$state = this.state,
      optionsVisible = _this$state.optionsVisible,
      value = _this$state.value;
    const option = options ? options.filter(o => o.value === value)[0] : false;
    const label = option ? option.label : value;
    return createVNode(1, "div", [className || '', 'dms-input-select'].join(' '), [noInput ? createVNode(1, "div", "dms-input", label, 0, {
      "tabindex": "0",
      "onKeyDown": this.onKeyDown
    }, null, node => this.inputNode = node) : createVNode(64, "input", "dms-input", null, 1, {
      "onInput": this.onInput,
      "onKeyDown": this.onKeyDown,
      "spellcheck": "false",
      "type": "text",
      "value": value
    }, null, node => this.inputNode = node), createVNode(1, "span", ['dms-input-select-icon', optionsVisible ? 'dmn-icon-up' : 'dmn-icon-down'].join(' ')), optionsVisible && createPortal(this.renderOptions(options, option), this._portalEl)], 0, {
      "title": title,
      "onClick": this.onInputClick
    }, null, node => this.parentNode = node);
  }
}
InputSelect.$inject = ['keyboard', 'renderer'];

// helper ////
function stopPropagation(event) {
  event.stopPropagation();
}
//# sourceMappingURL=InputSelect.js.map