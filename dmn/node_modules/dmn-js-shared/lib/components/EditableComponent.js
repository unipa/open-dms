import { createComponentVNode } from "inferno";
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import { Component } from 'inferno';
import ContentEditable from './ContentEditable';

/**
 * A base component for interactivity.
 *
 * @example
 *
 * class Foo extends EditableComponent {
 *
 *   render() {
 *     return (
 *       <div>{ this.getEditor() }</div>
 *     );
 *   }
 * }
 *
 * And in use:
 *
 * <Foo value={ blub }
 *      onChange={ (newValue) => { ... }
 *      onFocus={ () => { ... } }
 *      onBlur={ () => { ... } }
 *      validate={ (newValue) => { return 'some-error'; } }
 *      className="..." } />
 *
 * Special classes added:
 *
 * * focused
 * * invalid
 *
 */
export default class EditableComponent extends Component {
  constructor(props, context) {
    super(props, context);
    _defineProperty(this, "onFocus", event => {
      this.setState({
        focussed: true
      });
      var onFocus = this.props.onFocus;
      if (typeof onFocus === 'function') {
        onFocus(event);
      }
    });
    _defineProperty(this, "onBlur", event => {
      this.setState({
        focussed: false
      });
      const invalid = this.state.invalid;
      if (invalid) {
        this.setState({
          changing: false,
          invalid: false
        });
      }
      const onBlur = this.props.onBlur;
      if (typeof onBlur === 'function') {
        onBlur(event);
      }
    });
    this.state = {
      changing: false,
      focussed: false
    };
    const injector = context.injector;
    const debounceInput = injector.get('debounceInput');
    this.inputChanged = debounceInput(value => {
      const onChange = this.props.onChange;
      if (typeof onChange === 'function') {
        onChange(value);
      }

      // only unset changed if user input and
      // committed changed value equal. This prevents the
      // input jumping back to the saved, good value.
      const currentValue = this.state.changing;
      this.setState({
        changing: currentValue === value ? false : currentValue
      });
    });
    this.onInput = value => {
      var validate = this.props.validate || function () {};
      var invalid = validate(value);
      this.setState({
        changing: value,
        invalid: invalid
      });
      if (!invalid) {
        this.inputChanged(value);
      }
    };
  }
  getClassName() {
    var _this$props = this.props,
      className = _this$props.className,
      value = _this$props.value;
    var _this$state = this.state,
      changing = _this$state.changing,
      focussed = _this$state.focussed,
      invalid = _this$state.invalid;
    className += ' editable';
    if (focussed) {
      className += ' focussed';
    }
    if (invalid) {
      className += ' invalid';
    }
    if (!value && !changing) {
      className += ' empty';
    }
    return className;
  }
  getDisplayValue() {
    var _this$props2 = this.props,
      value = _this$props2.value,
      placeholder = _this$props2.placeholder;
    var _this$state2 = this.state,
      focussed = _this$state2.focussed,
      changing = _this$state2.changing;
    if (typeof changing === 'string') {
      value = changing;
    }
    if (!value) {
      value = focussed ? '' : placeholder || '';
    }
    return value;
  }
  getEditor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return createComponentVNode(2, ContentEditable, {
      "className": props.className,
      "ctrlForNewline": props.ctrlForNewline,
      "onFocus": this.onFocus,
      "onBlur": this.onBlur,
      "onInput": this.onInput,
      "value": this.getDisplayValue()
    });
  }
}
//# sourceMappingURL=EditableComponent.js.map