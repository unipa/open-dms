import { createVNode, createTextVNode } from "inferno";
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import { Component } from 'inferno';
import { groupBy } from 'min-dash';
const RADIO = 'radio';
const REMOVE_BTN_CLS = 'remove dmn-icon-clear';

/**
 * Shows a list of grouped items that can be checked
 * (checkboxes or radio buttons), removed.
 *
 * Example list of items:
 *
 * [
 *   { value: 'foo', isChecked: true, isRemovable: false, group: 'foo' },
 *   { value: 'bar', isChecked: false, isRemovable: true, group: 'bar' },
 *   { value: 'baz', isCheckable: false, group: 'baz' }
 * ]
 */
export default class List extends Component {
  constructor(props, context) {
    super(props, context);
    _defineProperty(this, "getRemoveClickHandler", item => {
      return e => {
        e.stopPropagation();
        this.removeItem(item);
      };
    });
    _defineProperty(this, "getToggleClickHandler", item => {
      return e => {
        e.stopPropagation();
        this.toggleItem(item);
      };
    });
    _defineProperty(this, "removeItem", item => {
      const onChange = this.props.onChange;

      // remove item
      const newItems = this.state.items.filter(i => i !== item);
      this.setState({
        items: newItems
      });
      onChange && onChange(newItems);
    });
    _defineProperty(this, "toggleItem", item => {
      const _this$props = this.props,
        onChange = _this$props.onChange,
        type = _this$props.type;

      // toggle item
      const newItems = this.state.items.map(i => {
        if (i === item) {
          i.isChecked = !i.isChecked;
        } else {
          if (type === RADIO) {
            i.isChecked = false;
          }
        }
        return i;
      });
      this.setState({
        items: newItems
      });
      onChange && onChange(newItems);
    });
    const items = props.items;
    this.state = {
      items
    };
  }
  componentWillReceiveProps(props) {
    const items = props.items;
    this.setState({
      items
    });
  }
  render() {
    const _this$props2 = this.props,
      className = _this$props2.className,
      items = _this$props2.items,
      type = _this$props2.type,
      labelComponent = _this$props2.labelComponent;
    const classes = ['dms-list-component'];
    if (className) {
      classes.push(className);
    }

    // group items by group title
    const groupedItems = groupBy(items, 'group');
    const asPairs = toPairs(groupedItems);
    return createVNode(1, "div", classes.join(' '), asPairs.map(pair => {
      const groupTitle = pair[0],
        groupItems = pair[1];
      return createVNode(1, "div", "group", [labelComponent && labelComponent(groupTitle) || createVNode(1, "h4", "dms-heading", groupTitle, 0), createVNode(1, "ul", "items no-wrap", groupItems.map(item => {
        return createVNode(1, "li", "item", [type && createVNode(64, "input", "item-toggle", null, 1, {
          "type": type,
          "checked": item.isChecked,
          "onClick": this.getToggleClickHandler(item)
        }), createTextVNode("\xA0"), item.value, item.isRemovable && createVNode(1, "span", REMOVE_BTN_CLS, null, 1, {
          "title": "Remove item",
          "onClick": this.getRemoveClickHandler(item)
        })], 0);
      }), 0)], 0);
    }), 0);
  }
}

// helpers ////////////

function toPairs(object) {
  const entrys = [];
  for (let key in object) {
    entrys.push([key, object[key]]);
  }
  return entrys;
}
//# sourceMappingURL=List.js.map