import { forEach } from 'min-dash';
import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';
import { is, getBusinessObject } from '../../../util/ModelUtil';
const ID = 'id';
export default class IdChangeBehavior extends CommandInterceptor {
  constructor(eventBus) {
    super(eventBus);
    this.executed('element.updateProperties', this.updateIds.bind(this));
  }
  updateIds(_ref) {
    let context = _ref.context;
    const element = context.element,
      oldProperties = context.oldProperties,
      properties = context.properties;
    const bo = getBusinessObject(element);
    if (this.shouldSkipUpdate(bo, oldProperties, properties)) {
      return;
    }
    const definitions = getDefinitions(bo);
    const drgElements = definitions.get('drgElement');
    drgElements.forEach(drgElement => {
      updateElementReferences(drgElement, oldProperties.id, properties.id);
    });
    const artifacts = definitions.get('artifact');
    artifacts.forEach(artifact => {
      updateAssociationReferences(artifact, oldProperties.id, properties.id);
    });
  }
  shouldSkipUpdate(bo, oldProperties, newProperties) {
    return !isIdChange(oldProperties, newProperties) || !is(bo, 'dmn:DRGElement') && !is(bo, 'dmn:TextAnnotation');
  }
}
IdChangeBehavior.$inject = ['eventBus'];

// helpers //////////////////////

function isIdChange(oldProperties, properties) {
  return ID in oldProperties && ID in properties;
}

/**
 * Walk up the tree until at the root to get to dmn:Definitions.
 *
 * @param {ModdleElement} element
 */
function getDefinitions(element) {
  let definitions = element;
  while (!is(definitions, 'dmn:Definitions')) {
    definitions = definitions.$parent;
  }
  return definitions;
}
function updateElementReferences(element, oldId, id) {
  const handlers = {
    authorityRequirement: () => {
      element.authorityRequirement.forEach(authorityRequirement => {
        const requiredAuthority = authorityRequirement.requiredAuthority,
          requiredDecision = authorityRequirement.requiredDecision,
          requiredInput = authorityRequirement.requiredInput;
        if (requiredAuthority && requiredAuthority.href === "#".concat(oldId)) {
          requiredAuthority.href = "#".concat(id);
        }
        if (requiredDecision && requiredDecision.href === "#".concat(oldId)) {
          requiredDecision.href = "#".concat(id);
        }
        if (requiredInput && requiredInput.href === "#".concat(oldId)) {
          requiredInput.href = "#".concat(id);
        }
      });
    },
    informationRequirement: () => {
      element.informationRequirement.forEach(informationRequirement => {
        const requiredDecision = informationRequirement.requiredDecision,
          requiredInput = informationRequirement.requiredInput;
        if (requiredDecision && requiredDecision.href === "#".concat(oldId)) {
          requiredDecision.href = "#".concat(id);
        }
        if (requiredInput && requiredInput.href === "#".concat(oldId)) {
          requiredInput.href = "#".concat(id);
        }
      });
    },
    knowledgeRequirement: () => {
      element.knowledgeRequirement.forEach(knowledgeRequirement => {
        const requiredKnowledge = knowledgeRequirement.requiredKnowledge;
        if (requiredKnowledge && requiredKnowledge.href === "#".concat(oldId)) {
          requiredKnowledge.href = "#".concat(id);
        }
      });
    }
  };
  forEach(handlers, (handler, key) => {
    if (element[key]) {
      handler();
    }
  });
}
function updateAssociationReferences(element, oldId, id) {
  const handlers = {
    sourceRef: () => {
      const sourceRef = element.sourceRef;
      if (sourceRef.href === "#".concat(oldId)) {
        sourceRef.href = "#".concat(id);
      }
    },
    targetRef: () => {
      const targetRef = element.targetRef;
      if (targetRef.href === "#".concat(oldId)) {
        targetRef.href = "#".concat(id);
      }
    }
  };
  forEach(handlers, (handler, key) => {
    if (element[key]) {
      handler();
    }
  });
}
//# sourceMappingURL=IdChangeBehavior.js.map