'use strict';

var preact = require('preact');
var fileDrop = require('file-drops');
var mitt = require('mitt');
var hooks = require('preact/hooks');
var download = require('downloadjs');
var classNames = require('classnames');
var formJsViewer = require('@bpmn-io/form-js-viewer');
var formJsEditor = require('@bpmn-io/form-js-editor');
var jsxRuntime = require('preact/jsx-runtime');
var codemirror = require('codemirror');
var view = require('@codemirror/view');
var state = require('@codemirror/state');
var lint = require('@codemirror/lint');
var langJson = require('@codemirror/lang-json');
var commands = require('@codemirror/commands');
var autocomplete = require('@codemirror/autocomplete');
var language = require('@codemirror/language');

function Modal(props) {
  hooks.useEffect(() => {
    function handleKey(event) {
      if (event.key === 'Escape') {
        event.stopPropagation();
        props.onClose();
      }
    }
    document.addEventListener('keydown', handleKey);
    return () => {
      document.removeEventListener('keydown', handleKey);
    };
  });
  return jsxRuntime.jsxs("div", {
    class: "fjs-pgl-modal",
    children: [jsxRuntime.jsx("div", {
      class: "fjs-pgl-modal-backdrop",
      onClick: props.onClose
    }), jsxRuntime.jsxs("div", {
      class: "fjs-pgl-modal-content",
      children: [jsxRuntime.jsx("h1", {
        class: "fjs-pgl-modal-header",
        children: props.name
      }), jsxRuntime.jsx("div", {
        class: "fjs-pgl-modal-body",
        children: props.children
      }), jsxRuntime.jsx("div", {
        class: "fjs-pgl-modal-footer",
        children: jsxRuntime.jsx("button", {
          class: "fjs-pgl-button fjs-pgl-button-default",
          onClick: props.onClose,
          children: "Close"
        })
      })]
    })]
  });
}

function EmbedModal(props) {
  const schema = serializeValue(props.schema);
  const data = serializeValue(props.data || {});
  const fieldRef = hooks.useRef();
  const snippet = `<!-- styles needed for rendering -->
<link rel="stylesheet" href="https://unpkg.com/@bpmn-io/form-js@0.2.4/dist/assets/form-js.css">

<!-- container to render the form into -->
<div class="fjs-pgl-form-container"></div>

<!-- scripts needed for embedding -->
<script src="https://unpkg.com/@bpmn-io/form-js@0.2.4/dist/form-viewer.umd.js"></script>

<!-- actual script to instantiate the form and load form schema + data -->
<script>
  const data = JSON.parse(${data});
  const schema = JSON.parse(${schema});

  const form = new FormViewer.Form({
    container: document.querySelector(".fjs-pgl-form-container")
  });

  form.on("submit", (event) => {
    console.log(event.data, event.errors);
  });

  form.importSchema(schema, data).catch(err => {
    console.error("Failed to render form", err);
  });
</script>
  `.trim();
  hooks.useEffect(() => {
    fieldRef.current.select();
  });
  return jsxRuntime.jsxs(Modal, {
    name: "Embed form",
    onClose: props.onClose,
    children: [jsxRuntime.jsxs("p", {
      children: ["Use the following HTML snippet to embed your form with ", jsxRuntime.jsx("a", {
        href: "https://github.com/bpmn-io/form-js",
        children: "form-js"
      }), ":"]
    }), jsxRuntime.jsx("textarea", {
      spellCheck: "false",
      ref: fieldRef,
      children: snippet
    })]
  });
}

// helpers ///////////

function serializeValue(obj) {
  return JSON.stringify(JSON.stringify(obj)).replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

/**
 * @type {Facet<import('..').Variables>} Variables
 */
const variablesFacet = state.Facet.define();

function autocompletion () {
  return [autocomplete.autocompletion({
    override: [completions]
  })];
}
function completions(context) {
  const variables = context.state.facet(variablesFacet)[0];
  const options = variables.map(v => ({
    label: v,
    type: 'variable'
  }));
  let nodeBefore = language.syntaxTree(context.state).resolve(context.pos, -1);

  // handle inside property name as explicit call
  if (nodeBefore.type.name === 'PropertyName') {
    context.explicit = true;
  }
  let word = context.matchBefore(/\w*/);
  if (word.from == word.to && !context.explicit) {
    return null;
  }
  return {
    from: word.from,
    options
  };
}

function JSONEditor(options = {}) {
  const {
    readonly = false
  } = options;
  const emitter = mitt();
  let language = new state.Compartment().of(langJson.json());
  let tabSize = new state.Compartment().of(state.EditorState.tabSize.of(2));

  /**
   * @typedef {Array<string>} Variables
   */

  const autocompletionConf = new state.Compartment();
  const linterExtension = lint.linter(langJson.jsonParseLinter());
  function createState(doc, extensions = [], variables = []) {
    return state.EditorState.create({
      doc,
      extensions: [codemirror.basicSetup, language, tabSize, linterExtension, lint.lintGutter(), autocompletionConf.of(variablesFacet.of(variables)), autocompletion(), view.keymap.of([commands.indentWithTab]), ...extensions]
    });
  }
  function createView(readonly) {
    const updateListener = view.EditorView.updateListener.of(update => {
      if (update.docChanged) {
        emitter.emit('changed', {
          value: update.view.state.doc.toString()
        });
      }
    });
    const editable = view.EditorView.editable.of(!readonly);
    const view$1 = new view.EditorView({
      state: createState('', [updateListener, editable])
    });
    view$1.setValue = function (value) {
      this.setState(createState(value, [updateListener, editable]));
    };
    view$1.setVariables = function (variables) {
      this.setState(createState(view$1.state.doc.toString(), [updateListener, editable], variables));
    };
    return view$1;
  }
  const view$1 = this._view = createView(readonly);
  this.setValue = function (value) {
    view$1.setValue(value);
  };
  this.getValue = function () {
    return view$1.state.doc.toString();
  };

  /**
   * @param {Variables} variables
   */
  this.setVariables = function (variables) {
    view$1.setVariables(variables);
  };
  this.on = emitter.on;
  this.off = emitter.off;
  this.emit = emitter.emit;
  this.attachTo = function (container) {
    container.appendChild(view$1.dom);
  };
  this.destroy = function () {
    if (view$1.dom.parentNode) {
      view$1.dom.parentNode.removeChild(view$1.dom);
    }
    view$1.destroy();
  };
}

function Section(props) {
  const elements = Array.isArray(props.children) ? props.children : [props.children];
  const {
    headerItems,
    children
  } = elements.reduce((_, child) => {
    const bucket = child.type === Section.HeaderItem ? _.headerItems : _.children;
    bucket.push(child);
    return _;
  }, {
    headerItems: [],
    children: []
  });
  return jsxRuntime.jsxs("div", {
    class: "fjs-pgl-section",
    children: [jsxRuntime.jsxs("h1", {
      class: "header",
      children: [props.name, " ", headerItems.length ? jsxRuntime.jsx("span", {
        class: "header-items",
        children: headerItems
      }) : null]
    }), jsxRuntime.jsx("div", {
      class: "body",
      children: children
    })]
  });
}
Section.HeaderItem = function (props) {
  return props.children;
};

function PlaygroundRoot(props) {
  const {
    actions: actionsConfig = {},
    emit,
    exporter: exporterConfig = {}
  } = props;
  const {
    display: displayActions = true
  } = actionsConfig;
  const paletteContainerRef = hooks.useRef();
  const editorContainerRef = hooks.useRef();
  const formContainerRef = hooks.useRef();
  const dataContainerRef = hooks.useRef();
  const resultContainerRef = hooks.useRef();
  const propertiesPanelContainerRef = hooks.useRef();
  const paletteRef = hooks.useRef();
  const formEditorRef = hooks.useRef();
  const formRef = hooks.useRef();
  const dataEditorRef = hooks.useRef();
  const resultViewRef = hooks.useRef();
  const propertiesPanelRef = hooks.useRef();
  const [showEmbed, setShowEmbed] = hooks.useState(false);
  const [initialData] = hooks.useState(props.data || {});
  const [initialSchema, setInitialSchema] = hooks.useState(props.schema);
  const [data, setData] = hooks.useState(props.data || {});
  const [schema, setSchema] = hooks.useState(props.schema);
  const [resultData, setResultData] = hooks.useState({});

  // pipe to playground API
  hooks.useEffect(() => {
    props.onInit({
      attachDataContainer: node => dataEditorRef.current.attachTo(node),
      attachEditorContainer: node => formEditorRef.current.attachTo(node),
      attachFormContainer: node => formRef.current.attachTo(node),
      attachPaletteContainer: node => paletteRef.current.attachTo(node),
      attachPropertiesPanelContainer: node => propertiesPanelRef.current.attachTo(node),
      attachResultContainer: node => resultViewRef.current.attachTo(node),
      get: (name, strict) => formEditorRef.current.get(name, strict),
      getDataEditor: () => dataEditorRef.current,
      getEditor: () => formEditorRef.current,
      getForm: () => formRef.current,
      getResultView: () => resultViewRef.current,
      getSchema: () => formEditorRef.current.getSchema(),
      setSchema: setInitialSchema,
      saveSchema: () => formEditorRef.current.saveSchema()
    });
  });
  hooks.useEffect(() => {
    setInitialSchema(props.schema || {});
  }, [props.schema]);
  hooks.useEffect(() => {
    const dataEditor = dataEditorRef.current = new JSONEditor({
      value: toString(data)
    });
    const resultView = resultViewRef.current = new JSONEditor({
      readonly: true,
      value: toString(resultData)
    });
    const form = formRef.current = new formJsViewer.Form();
    const formEditor = formEditorRef.current = new formJsEditor.FormEditor({
      renderer: {
        compact: true
      },
      palette: {
        parent: paletteContainerRef.current
      },
      propertiesPanel: {
        parent: propertiesPanelContainerRef.current
      },
      exporter: exporterConfig
    });
    paletteRef.current = formEditor.get('palette');
    propertiesPanelRef.current = formEditor.get('propertiesPanel');
    formEditor.on('changed', () => {
      setSchema(formEditor.getSchema());
    });
    formEditor.on('formEditor.rendered', () => {
      // notifiy interested parties after render
      emit('formPlayground.rendered');
    });
    form.on('changed', () => {
      setResultData(form._getSubmitData());
    });
    dataEditor.on('changed', event => {
      try {
        setData(JSON.parse(event.value));
      } catch (error) {
        // notify interested about input data error
        emit('formPlayground.inputDataError', error);
      }
    });
    const formContainer = formContainerRef.current;
    const editorContainer = editorContainerRef.current;
    const dataContainer = dataContainerRef.current;
    const resultContainer = resultContainerRef.current;
    dataEditor.attachTo(dataContainer);
    resultView.attachTo(resultContainer);
    form.attachTo(formContainer);
    formEditor.attachTo(editorContainer);
    return () => {
      dataEditor.destroy();
      resultView.destroy();
      form.destroy();
      formEditor.destroy();
    };
  }, []);
  hooks.useEffect(() => {
    dataEditorRef.current.setValue(toString(initialData));
  }, [initialData]);
  hooks.useEffect(() => {
    if (initialSchema) {
      formEditorRef.current.importSchema(initialSchema);
      dataEditorRef.current.setVariables(formJsViewer.getSchemaVariables(initialSchema));
    }
  }, [initialSchema]);
  hooks.useEffect(() => {
    if (schema && dataContainerRef.current) {
      const variables = formJsViewer.getSchemaVariables(schema);
      dataEditorRef.current.setVariables(variables);
    }
  }, [schema]);
  hooks.useEffect(() => {
    schema && formRef.current.importSchema(schema, data);
  }, [schema, data]);
  hooks.useEffect(() => {
    resultViewRef.current.setValue(toString(resultData));
  }, [resultData]);
  hooks.useEffect(() => {
    props.onStateChanged({
      schema,
      data
    });
  }, [schema, data]);
  const handleDownload = hooks.useCallback(() => {
    download(JSON.stringify(schema, null, '  '), 'form.json', 'text/json');
  }, [schema]);
  const hideEmbedModal = hooks.useCallback(() => {
    setShowEmbed(false);
  }, []);
  const showEmbedModal = hooks.useCallback(() => {
    setShowEmbed(true);
  }, []);
  return jsxRuntime.jsxs("div", {
    class: classNames('fjs-container', 'fjs-pgl-root'),
    children: [jsxRuntime.jsx("div", {
      class: "fjs-pgl-modals",
      children: showEmbed ? jsxRuntime.jsx(EmbedModal, {
        schema: schema,
        data: data,
        onClose: hideEmbedModal
      }) : null
    }), jsxRuntime.jsx("div", {
      class: "fjs-pgl-palette-container",
      ref: paletteContainerRef
    }), jsxRuntime.jsxs("div", {
      class: "fjs-pgl-main",
      children: [jsxRuntime.jsxs(Section, {
        name: "Form Definition",
        children: [displayActions && jsxRuntime.jsx(Section.HeaderItem, {
          children: jsxRuntime.jsx("button", {
            class: "fjs-pgl-button",
            title: "Download form definition",
            onClick: handleDownload,
            children: "Download"
          })
        }), displayActions && jsxRuntime.jsx(Section.HeaderItem, {
          children: jsxRuntime.jsx("button", {
            class: "fjs-pgl-button",
            onClick: showEmbedModal,
            children: "Embed"
          })
        }), jsxRuntime.jsx("div", {
          ref: editorContainerRef,
          class: "fjs-pgl-form-container"
        })]
      }), jsxRuntime.jsx(Section, {
        name: "Form Preview",
        children: jsxRuntime.jsx("div", {
          ref: formContainerRef,
          class: "fjs-pgl-form-container"
        })
      }), jsxRuntime.jsx(Section, {
        name: "Form Input",
        children: jsxRuntime.jsx("div", {
          ref: dataContainerRef,
          class: "fjs-pgl-text-container"
        })
      }), jsxRuntime.jsx(Section, {
        name: "Form Output",
        children: jsxRuntime.jsx("div", {
          ref: resultContainerRef,
          class: "fjs-pgl-text-container"
        })
      })]
    }), jsxRuntime.jsx("div", {
      class: "fjs-pgl-properties-container",
      ref: propertiesPanelContainerRef
    })]
  });
}

// helpers ///////////////

function toString(obj) {
  return JSON.stringify(obj, null, '  ');
}

function Playground(options) {
  const {
    container: parent,
    schema,
    data,
    ...rest
  } = options;
  const emitter = mitt();
  let state = {
    data,
    schema
  };
  let ref;
  const container = document.createElement('div');
  container.classList.add('fjs-pgl-parent');
  if (parent) {
    parent.appendChild(container);
  }
  const handleDrop = fileDrop('Drop a form file', function (files) {
    const file = files[0];
    if (file) {
      try {
        ref.setSchema(JSON.parse(file.contents));
      } catch (err) {

        // TODO(nikku): indicate JSON parse error
      }
    }
  });
  const withRef = function (fn) {
    return function (...args) {
      if (!ref) {
        throw new Error('Playground is not initialized.');
      }
      return fn(...args);
    };
  };
  const onInit = function (_ref) {
    ref = _ref;
    emitter.emit('formPlayground.init');
  };
  container.addEventListener('dragover', handleDrop);
  preact.render(jsxRuntime.jsx(PlaygroundRoot, {
    data: data,
    emit: emitter.emit,
    onInit: onInit,
    onStateChanged: _state => state = _state,
    schema: schema,
    ...rest
  }), container);
  this.on = emitter.on;
  this.off = emitter.off;
  this.emit = emitter.emit;
  this.on('destroy', function () {
    preact.render(null, container);
  });
  this.on('destroy', function () {
    parent.removeChild(container);
  });
  this.getState = function () {
    return state;
  };
  this.getSchema = withRef(() => ref.getSchema());
  this.setSchema = withRef(schema => ref.setSchema(schema));
  this.saveSchema = withRef(() => ref.saveSchema());
  this.get = withRef((name, strict) => ref.get(name, strict));
  this.getDataEditor = withRef(() => ref.getDataEditor());
  this.getEditor = withRef(() => ref.getEditor());
  this.getForm = withRef((name, strict) => ref.getForm(name, strict));
  this.getResultView = withRef(() => ref.getResultView());
  this.destroy = function () {
    this.emit('destroy');
  };
  this.attachEditorContainer = withRef(node => ref.attachEditorContainer(node));
  this.attachPreviewContainer = withRef(node => ref.attachFormContainer(node));
  this.attachDataContainer = withRef(node => ref.attachDataContainer(node));
  this.attachResultContainer = withRef(node => ref.attachResultContainer(node));
  this.attachPaletteContainer = withRef(node => ref.attachPaletteContainer(node));
  this.attachPropertiesPanelContainer = withRef(node => ref.attachPropertiesPanelContainer(node));
}

exports.Playground = Playground;
//# sourceMappingURL=index.cjs.map
