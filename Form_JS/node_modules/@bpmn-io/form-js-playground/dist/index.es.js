import { render } from 'preact';
import fileDrop from 'file-drops';
import mitt from 'mitt';
import { useEffect, useRef, useState, useCallback } from 'preact/hooks';
import download from 'downloadjs';
import classNames from 'classnames';
import { Form, getSchemaVariables } from '@bpmn-io/form-js-viewer';
import { FormEditor } from '@bpmn-io/form-js-editor';
import { jsxs, jsx } from 'preact/jsx-runtime';
import { basicSetup } from 'codemirror';
import { EditorView, keymap } from '@codemirror/view';
import { Facet, Compartment, EditorState } from '@codemirror/state';
import { linter, lintGutter } from '@codemirror/lint';
import { json, jsonParseLinter } from '@codemirror/lang-json';
import { indentWithTab } from '@codemirror/commands';
import { autocompletion as autocompletion$1 } from '@codemirror/autocomplete';
import { syntaxTree } from '@codemirror/language';

function Modal(props) {
  useEffect(() => {
    function handleKey(event) {
      if (event.key === 'Escape') {
        event.stopPropagation();
        props.onClose();
      }
    }
    document.addEventListener('keydown', handleKey);
    return () => {
      document.removeEventListener('keydown', handleKey);
    };
  });
  return jsxs("div", {
    class: "fjs-pgl-modal",
    children: [jsx("div", {
      class: "fjs-pgl-modal-backdrop",
      onClick: props.onClose
    }), jsxs("div", {
      class: "fjs-pgl-modal-content",
      children: [jsx("h1", {
        class: "fjs-pgl-modal-header",
        children: props.name
      }), jsx("div", {
        class: "fjs-pgl-modal-body",
        children: props.children
      }), jsx("div", {
        class: "fjs-pgl-modal-footer",
        children: jsx("button", {
          class: "fjs-pgl-button fjs-pgl-button-default",
          onClick: props.onClose,
          children: "Close"
        })
      })]
    })]
  });
}

function EmbedModal(props) {
  const schema = serializeValue(props.schema);
  const data = serializeValue(props.data || {});
  const fieldRef = useRef();
  const snippet = `<!-- styles needed for rendering -->
<link rel="stylesheet" href="https://unpkg.com/@bpmn-io/form-js@0.2.4/dist/assets/form-js.css">

<!-- container to render the form into -->
<div class="fjs-pgl-form-container"></div>

<!-- scripts needed for embedding -->
<script src="https://unpkg.com/@bpmn-io/form-js@0.2.4/dist/form-viewer.umd.js"></script>

<!-- actual script to instantiate the form and load form schema + data -->
<script>
  const data = JSON.parse(${data});
  const schema = JSON.parse(${schema});

  const form = new FormViewer.Form({
    container: document.querySelector(".fjs-pgl-form-container")
  });

  form.on("submit", (event) => {
    console.log(event.data, event.errors);
  });

  form.importSchema(schema, data).catch(err => {
    console.error("Failed to render form", err);
  });
</script>
  `.trim();
  useEffect(() => {
    fieldRef.current.select();
  });
  return jsxs(Modal, {
    name: "Embed form",
    onClose: props.onClose,
    children: [jsxs("p", {
      children: ["Use the following HTML snippet to embed your form with ", jsx("a", {
        href: "https://github.com/bpmn-io/form-js",
        children: "form-js"
      }), ":"]
    }), jsx("textarea", {
      spellCheck: "false",
      ref: fieldRef,
      children: snippet
    })]
  });
}

// helpers ///////////

function serializeValue(obj) {
  return JSON.stringify(JSON.stringify(obj)).replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

/**
 * @type {Facet<import('..').Variables>} Variables
 */
const variablesFacet = Facet.define();

function autocompletion () {
  return [autocompletion$1({
    override: [completions]
  })];
}
function completions(context) {
  const variables = context.state.facet(variablesFacet)[0];
  const options = variables.map(v => ({
    label: v,
    type: 'variable'
  }));
  let nodeBefore = syntaxTree(context.state).resolve(context.pos, -1);

  // handle inside property name as explicit call
  if (nodeBefore.type.name === 'PropertyName') {
    context.explicit = true;
  }
  let word = context.matchBefore(/\w*/);
  if (word.from == word.to && !context.explicit) {
    return null;
  }
  return {
    from: word.from,
    options
  };
}

function JSONEditor(options = {}) {
  const {
    readonly = false
  } = options;
  const emitter = mitt();
  let language = new Compartment().of(json());
  let tabSize = new Compartment().of(EditorState.tabSize.of(2));

  /**
   * @typedef {Array<string>} Variables
   */

  const autocompletionConf = new Compartment();
  const linterExtension = linter(jsonParseLinter());
  function createState(doc, extensions = [], variables = []) {
    return EditorState.create({
      doc,
      extensions: [basicSetup, language, tabSize, linterExtension, lintGutter(), autocompletionConf.of(variablesFacet.of(variables)), autocompletion(), keymap.of([indentWithTab]), ...extensions]
    });
  }
  function createView(readonly) {
    const updateListener = EditorView.updateListener.of(update => {
      if (update.docChanged) {
        emitter.emit('changed', {
          value: update.view.state.doc.toString()
        });
      }
    });
    const editable = EditorView.editable.of(!readonly);
    const view = new EditorView({
      state: createState('', [updateListener, editable])
    });
    view.setValue = function (value) {
      this.setState(createState(value, [updateListener, editable]));
    };
    view.setVariables = function (variables) {
      this.setState(createState(view.state.doc.toString(), [updateListener, editable], variables));
    };
    return view;
  }
  const view = this._view = createView(readonly);
  this.setValue = function (value) {
    view.setValue(value);
  };
  this.getValue = function () {
    return view.state.doc.toString();
  };

  /**
   * @param {Variables} variables
   */
  this.setVariables = function (variables) {
    view.setVariables(variables);
  };
  this.on = emitter.on;
  this.off = emitter.off;
  this.emit = emitter.emit;
  this.attachTo = function (container) {
    container.appendChild(view.dom);
  };
  this.destroy = function () {
    if (view.dom.parentNode) {
      view.dom.parentNode.removeChild(view.dom);
    }
    view.destroy();
  };
}

function Section(props) {
  const elements = Array.isArray(props.children) ? props.children : [props.children];
  const {
    headerItems,
    children
  } = elements.reduce((_, child) => {
    const bucket = child.type === Section.HeaderItem ? _.headerItems : _.children;
    bucket.push(child);
    return _;
  }, {
    headerItems: [],
    children: []
  });
  return jsxs("div", {
    class: "fjs-pgl-section",
    children: [jsxs("h1", {
      class: "header",
      children: [props.name, " ", headerItems.length ? jsx("span", {
        class: "header-items",
        children: headerItems
      }) : null]
    }), jsx("div", {
      class: "body",
      children: children
    })]
  });
}
Section.HeaderItem = function (props) {
  return props.children;
};

function PlaygroundRoot(props) {
  const {
    actions: actionsConfig = {},
    emit,
    exporter: exporterConfig = {}
  } = props;
  const {
    display: displayActions = true
  } = actionsConfig;
  const paletteContainerRef = useRef();
  const editorContainerRef = useRef();
  const formContainerRef = useRef();
  const dataContainerRef = useRef();
  const resultContainerRef = useRef();
  const propertiesPanelContainerRef = useRef();
  const paletteRef = useRef();
  const formEditorRef = useRef();
  const formRef = useRef();
  const dataEditorRef = useRef();
  const resultViewRef = useRef();
  const propertiesPanelRef = useRef();
  const [showEmbed, setShowEmbed] = useState(false);
  const [initialData] = useState(props.data || {});
  const [initialSchema, setInitialSchema] = useState(props.schema);
  const [data, setData] = useState(props.data || {});
  const [schema, setSchema] = useState(props.schema);
  const [resultData, setResultData] = useState({});

  // pipe to playground API
  useEffect(() => {
    props.onInit({
      attachDataContainer: node => dataEditorRef.current.attachTo(node),
      attachEditorContainer: node => formEditorRef.current.attachTo(node),
      attachFormContainer: node => formRef.current.attachTo(node),
      attachPaletteContainer: node => paletteRef.current.attachTo(node),
      attachPropertiesPanelContainer: node => propertiesPanelRef.current.attachTo(node),
      attachResultContainer: node => resultViewRef.current.attachTo(node),
      get: (name, strict) => formEditorRef.current.get(name, strict),
      getDataEditor: () => dataEditorRef.current,
      getEditor: () => formEditorRef.current,
      getForm: () => formRef.current,
      getResultView: () => resultViewRef.current,
      getSchema: () => formEditorRef.current.getSchema(),
      setSchema: setInitialSchema,
      saveSchema: () => formEditorRef.current.saveSchema()
    });
  });
  useEffect(() => {
    setInitialSchema(props.schema || {});
  }, [props.schema]);
  useEffect(() => {
    const dataEditor = dataEditorRef.current = new JSONEditor({
      value: toString(data)
    });
    const resultView = resultViewRef.current = new JSONEditor({
      readonly: true,
      value: toString(resultData)
    });
    const form = formRef.current = new Form();
    const formEditor = formEditorRef.current = new FormEditor({
      renderer: {
        compact: true
      },
      palette: {
        parent: paletteContainerRef.current
      },
      propertiesPanel: {
        parent: propertiesPanelContainerRef.current
      },
      exporter: exporterConfig
    });
    paletteRef.current = formEditor.get('palette');
    propertiesPanelRef.current = formEditor.get('propertiesPanel');
    formEditor.on('changed', () => {
      setSchema(formEditor.getSchema());
    });
    formEditor.on('formEditor.rendered', () => {
      // notifiy interested parties after render
      emit('formPlayground.rendered');
    });
    form.on('changed', () => {
      setResultData(form._getSubmitData());
    });
    dataEditor.on('changed', event => {
      try {
        setData(JSON.parse(event.value));
      } catch (error) {
        // notify interested about input data error
        emit('formPlayground.inputDataError', error);
      }
    });
    const formContainer = formContainerRef.current;
    const editorContainer = editorContainerRef.current;
    const dataContainer = dataContainerRef.current;
    const resultContainer = resultContainerRef.current;
    dataEditor.attachTo(dataContainer);
    resultView.attachTo(resultContainer);
    form.attachTo(formContainer);
    formEditor.attachTo(editorContainer);
    return () => {
      dataEditor.destroy();
      resultView.destroy();
      form.destroy();
      formEditor.destroy();
    };
  }, []);
  useEffect(() => {
    dataEditorRef.current.setValue(toString(initialData));
  }, [initialData]);
  useEffect(() => {
    if (initialSchema) {
      formEditorRef.current.importSchema(initialSchema);
      dataEditorRef.current.setVariables(getSchemaVariables(initialSchema));
    }
  }, [initialSchema]);
  useEffect(() => {
    if (schema && dataContainerRef.current) {
      const variables = getSchemaVariables(schema);
      dataEditorRef.current.setVariables(variables);
    }
  }, [schema]);
  useEffect(() => {
    schema && formRef.current.importSchema(schema, data);
  }, [schema, data]);
  useEffect(() => {
    resultViewRef.current.setValue(toString(resultData));
  }, [resultData]);
  useEffect(() => {
    props.onStateChanged({
      schema,
      data
    });
  }, [schema, data]);
  const handleDownload = useCallback(() => {
    download(JSON.stringify(schema, null, '  '), 'form.json', 'text/json');
  }, [schema]);
  const hideEmbedModal = useCallback(() => {
    setShowEmbed(false);
  }, []);
  const showEmbedModal = useCallback(() => {
    setShowEmbed(true);
  }, []);
  return jsxs("div", {
    class: classNames('fjs-container', 'fjs-pgl-root'),
    children: [jsx("div", {
      class: "fjs-pgl-modals",
      children: showEmbed ? jsx(EmbedModal, {
        schema: schema,
        data: data,
        onClose: hideEmbedModal
      }) : null
    }), jsx("div", {
      class: "fjs-pgl-palette-container",
      ref: paletteContainerRef
    }), jsxs("div", {
      class: "fjs-pgl-main",
      children: [jsxs(Section, {
        name: "Form Definition",
        children: [displayActions && jsx(Section.HeaderItem, {
          children: jsx("button", {
            class: "fjs-pgl-button",
            title: "Download form definition",
            onClick: handleDownload,
            children: "Download"
          })
        }), displayActions && jsx(Section.HeaderItem, {
          children: jsx("button", {
            class: "fjs-pgl-button",
            onClick: showEmbedModal,
            children: "Embed"
          })
        }), jsx("div", {
          ref: editorContainerRef,
          class: "fjs-pgl-form-container"
        })]
      }), jsx(Section, {
        name: "Form Preview",
        children: jsx("div", {
          ref: formContainerRef,
          class: "fjs-pgl-form-container"
        })
      }), jsx(Section, {
        name: "Form Input",
        children: jsx("div", {
          ref: dataContainerRef,
          class: "fjs-pgl-text-container"
        })
      }), jsx(Section, {
        name: "Form Output",
        children: jsx("div", {
          ref: resultContainerRef,
          class: "fjs-pgl-text-container"
        })
      })]
    }), jsx("div", {
      class: "fjs-pgl-properties-container",
      ref: propertiesPanelContainerRef
    })]
  });
}

// helpers ///////////////

function toString(obj) {
  return JSON.stringify(obj, null, '  ');
}

function Playground(options) {
  const {
    container: parent,
    schema,
    data,
    ...rest
  } = options;
  const emitter = mitt();
  let state = {
    data,
    schema
  };
  let ref;
  const container = document.createElement('div');
  container.classList.add('fjs-pgl-parent');
  if (parent) {
    parent.appendChild(container);
  }
  const handleDrop = fileDrop('Drop a form file', function (files) {
    const file = files[0];
    if (file) {
      try {
        ref.setSchema(JSON.parse(file.contents));
      } catch (err) {

        // TODO(nikku): indicate JSON parse error
      }
    }
  });
  const withRef = function (fn) {
    return function (...args) {
      if (!ref) {
        throw new Error('Playground is not initialized.');
      }
      return fn(...args);
    };
  };
  const onInit = function (_ref) {
    ref = _ref;
    emitter.emit('formPlayground.init');
  };
  container.addEventListener('dragover', handleDrop);
  render(jsx(PlaygroundRoot, {
    data: data,
    emit: emitter.emit,
    onInit: onInit,
    onStateChanged: _state => state = _state,
    schema: schema,
    ...rest
  }), container);
  this.on = emitter.on;
  this.off = emitter.off;
  this.emit = emitter.emit;
  this.on('destroy', function () {
    render(null, container);
  });
  this.on('destroy', function () {
    parent.removeChild(container);
  });
  this.getState = function () {
    return state;
  };
  this.getSchema = withRef(() => ref.getSchema());
  this.setSchema = withRef(schema => ref.setSchema(schema));
  this.saveSchema = withRef(() => ref.saveSchema());
  this.get = withRef((name, strict) => ref.get(name, strict));
  this.getDataEditor = withRef(() => ref.getDataEditor());
  this.getEditor = withRef(() => ref.getEditor());
  this.getForm = withRef((name, strict) => ref.getForm(name, strict));
  this.getResultView = withRef(() => ref.getResultView());
  this.destroy = function () {
    this.emit('destroy');
  };
  this.attachEditorContainer = withRef(node => ref.attachEditorContainer(node));
  this.attachPreviewContainer = withRef(node => ref.attachFormContainer(node));
  this.attachDataContainer = withRef(node => ref.attachDataContainer(node));
  this.attachResultContainer = withRef(node => ref.attachResultContainer(node));
  this.attachPaletteContainer = withRef(node => ref.attachPaletteContainer(node));
  this.attachPropertiesPanelContainer = withRef(node => ref.attachPropertiesPanelContainer(node));
}

export { Playground };
//# sourceMappingURL=index.es.js.map
