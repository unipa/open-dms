import Ids from 'ids';
import { isString, isArray, isFunction, isNumber, bind, assign, isNil, get, isUndefined, set, findIndex, isObject } from 'min-dash';
import { unaryTest, evaluate, parseUnaryTests, parseExpressions } from 'feelin';
import Big from 'big.js';
import snarkdown from '@bpmn-io/snarkdown';
import classNames from 'classnames';
import { jsx, jsxs, Fragment as Fragment$1 } from 'preact/jsx-runtime';
import { useContext, useState, useEffect, useRef, useCallback, useMemo } from 'preact/hooks';
import { createContext, createElement, Fragment, render } from 'preact';
import React, { createPortal } from 'preact/compat';
import flatpickr from 'flatpickr';
import Markup from 'preact-markup';
import { Injector } from 'didi';

/**
 * @typedef {object} Condition
 * @property {string} [hide]
 */

class ConditionChecker {
  constructor(formFieldRegistry, eventBus) {
    this._formFieldRegistry = formFieldRegistry;
    this._eventBus = eventBus;
  }

  /**
   * For given data, remove properties based on condition.
   *
   * @param {Object<string, any>} properties
   * @param {Object<string, any>} data
   */
  applyConditions(properties, data = {}) {
    const conditions = this._getConditions();
    const newProperties = {
      ...properties
    };
    for (const {
      key,
      condition
    } of conditions) {
      const shouldRemove = this._checkHideCondition(condition, data);
      if (shouldRemove) {
        delete newProperties[key];
      }
    }
    return newProperties;
  }

  /**
   * Check if given condition is met. Returns null for invalid/missing conditions.
   *
   * @param {string} condition
   * @param {import('../types').Data} [data]
   *
   * @returns {boolean|null}
   */
  check(condition, data = {}) {
    if (!condition) {
      return null;
    }
    if (!isString(condition) || !condition.startsWith('=')) {
      return null;
    }
    try {
      // cut off initial '='
      const result = unaryTest(condition.slice(1), data);
      return result;
    } catch (error) {
      this._eventBus.fire('error', {
        error
      });
      return null;
    }
  }

  /**
   * Check if hide condition is met.
   *
   * @param {Condition} condition
   * @param {Object<string, any>} data
   * @returns {boolean}
   */
  _checkHideCondition(condition, data) {
    if (!condition.hide) {
      return false;
    }
    const result = this.check(condition.hide, data);
    return result === true;
  }

  /**
   * Evaluate an expression.
   *
   * @param {string} expression
   * @param {import('../types').Data} [data]
   *
   * @returns {any}
   */
  evaluate(expression, data = {}) {
    if (!expression) {
      return null;
    }
    if (!isString(expression) || !expression.startsWith('=')) {
      return null;
    }
    try {
      const result = evaluate(expression.slice(1), data);
      return result;
    } catch (error) {
      this._eventBus.fire('error', {
        error
      });
      return null;
    }
  }
  _getConditions() {
    const formFields = this._formFieldRegistry.getAll();
    return formFields.reduce((conditions, formField) => {
      const {
        key,
        conditional: condition
      } = formField;
      if (key && condition) {
        return [...conditions, {
          key,
          condition
        }];
      }
      return conditions;
    }, []);
  }
}
ConditionChecker.$inject = ['formFieldRegistry', 'eventBus'];

var FN_REF = '__fn';
var DEFAULT_PRIORITY = 1000;
var slice = Array.prototype.slice;

/**
 * A general purpose event bus.
 *
 * This component is used to communicate across a diagram instance.
 * Other parts of a diagram can use it to listen to and broadcast events.
 *
 *
 * ## Registering for Events
 *
 * The event bus provides the {@link EventBus#on} and {@link EventBus#once}
 * methods to register for events. {@link EventBus#off} can be used to
 * remove event registrations. Listeners receive an instance of {@link Event}
 * as the first argument. It allows them to hook into the event execution.
 *
 * ```javascript
 *
 * // listen for event
 * eventBus.on('foo', function(event) {
 *
 *   // access event type
 *   event.type; // 'foo'
 *
 *   // stop propagation to other listeners
 *   event.stopPropagation();
 *
 *   // prevent event default
 *   event.preventDefault();
 * });
 *
 * // listen for event with custom payload
 * eventBus.on('bar', function(event, payload) {
 *   console.log(payload);
 * });
 *
 * // listen for event returning value
 * eventBus.on('foobar', function(event) {
 *
 *   // stop event propagation + prevent default
 *   return false;
 *
 *   // stop event propagation + return custom result
 *   return {
 *     complex: 'listening result'
 *   };
 * });
 *
 *
 * // listen with custom priority (default=1000, higher is better)
 * eventBus.on('priorityfoo', 1500, function(event) {
 *   console.log('invoked first!');
 * });
 *
 *
 * // listen for event and pass the context (`this`)
 * eventBus.on('foobar', function(event) {
 *   this.foo();
 * }, this);
 * ```
 *
 *
 * ## Emitting Events
 *
 * Events can be emitted via the event bus using {@link EventBus#fire}.
 *
 * ```javascript
 *
 * // false indicates that the default action
 * // was prevented by listeners
 * if (eventBus.fire('foo') === false) {
 *   console.log('default has been prevented!');
 * };
 *
 *
 * // custom args + return value listener
 * eventBus.on('sum', function(event, a, b) {
 *   return a + b;
 * });
 *
 * // you can pass custom arguments + retrieve result values.
 * var sum = eventBus.fire('sum', 1, 2);
 * console.log(sum); // 3
 * ```
 */
function EventBus() {
  this._listeners = {};

  // cleanup on destroy on lowest priority to allow
  // message passing until the bitter end
  this.on('diagram.destroy', 1, this._destroy, this);
}

/**
 * Register an event listener for events with the given name.
 *
 * The callback will be invoked with `event, ...additionalArguments`
 * that have been passed to {@link EventBus#fire}.
 *
 * Returning false from a listener will prevent the events default action
 * (if any is specified). To stop an event from being processed further in
 * other listeners execute {@link Event#stopPropagation}.
 *
 * Returning anything but `undefined` from a listener will stop the listener propagation.
 *
 * @param {string|Array<string>} events
 * @param {number} [priority=1000] the priority in which this listener is called, larger is higher
 * @param {Function} callback
 * @param {Object} [that] Pass context (`this`) to the callback
 */
EventBus.prototype.on = function (events, priority, callback, that) {
  events = isArray(events) ? events : [events];
  if (isFunction(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY;
  }
  if (!isNumber(priority)) {
    throw new Error('priority must be a number');
  }
  var actualCallback = callback;
  if (that) {
    actualCallback = bind(callback, that);

    // make sure we remember and are able to remove
    // bound callbacks via {@link #off} using the original
    // callback
    actualCallback[FN_REF] = callback[FN_REF] || callback;
  }
  var self = this;
  events.forEach(function (e) {
    self._addListener(e, {
      priority: priority,
      callback: actualCallback,
      next: null
    });
  });
};

/**
 * Register an event listener that is executed only once.
 *
 * @param {string} event the event name to register for
 * @param {number} [priority=1000] the priority in which this listener is called, larger is higher
 * @param {Function} callback the callback to execute
 * @param {Object} [that] Pass context (`this`) to the callback
 */
EventBus.prototype.once = function (event, priority, callback, that) {
  var self = this;
  if (isFunction(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY;
  }
  if (!isNumber(priority)) {
    throw new Error('priority must be a number');
  }
  function wrappedCallback() {
    wrappedCallback.__isTomb = true;
    var result = callback.apply(that, arguments);
    self.off(event, wrappedCallback);
    return result;
  }

  // make sure we remember and are able to remove
  // bound callbacks via {@link #off} using the original
  // callback
  wrappedCallback[FN_REF] = callback;
  this.on(event, priority, wrappedCallback);
};

/**
 * Removes event listeners by event and callback.
 *
 * If no callback is given, all listeners for a given event name are being removed.
 *
 * @param {string|Array<string>} events
 * @param {Function} [callback]
 */
EventBus.prototype.off = function (events, callback) {
  events = isArray(events) ? events : [events];
  var self = this;
  events.forEach(function (event) {
    self._removeListener(event, callback);
  });
};

/**
 * Create an EventBus event.
 *
 * @param {Object} data
 *
 * @return {Object} event, recognized by the eventBus
 */
EventBus.prototype.createEvent = function (data) {
  var event = new InternalEvent();
  event.init(data);
  return event;
};

/**
 * Fires a named event.
 *
 * @example
 *
 * // fire event by name
 * events.fire('foo');
 *
 * // fire event object with nested type
 * var event = { type: 'foo' };
 * events.fire(event);
 *
 * // fire event with explicit type
 * var event = { x: 10, y: 20 };
 * events.fire('element.moved', event);
 *
 * // pass additional arguments to the event
 * events.on('foo', function(event, bar) {
 *   alert(bar);
 * });
 *
 * events.fire({ type: 'foo' }, 'I am bar!');
 *
 * @param {string} [name] the optional event name
 * @param {Object} [event] the event object
 * @param {...Object} additional arguments to be passed to the callback functions
 *
 * @return {boolean} the events return value, if specified or false if the
 *                   default action was prevented by listeners
 */
EventBus.prototype.fire = function (type, data) {
  var event, firstListener, returnValue, args;
  args = slice.call(arguments);
  if (typeof type === 'object') {
    data = type;
    type = data.type;
  }
  if (!type) {
    throw new Error('no event type specified');
  }
  firstListener = this._listeners[type];
  if (!firstListener) {
    return;
  }

  // we make sure we fire instances of our home made
  // events here. We wrap them only once, though
  if (data instanceof InternalEvent) {
    // we are fine, we alread have an event
    event = data;
  } else {
    event = this.createEvent(data);
  }

  // ensure we pass the event as the first parameter
  args[0] = event;

  // original event type (in case we delegate)
  var originalType = event.type;

  // update event type before delegation
  if (type !== originalType) {
    event.type = type;
  }
  try {
    returnValue = this._invokeListeners(event, args, firstListener);
  } finally {
    // reset event type after delegation
    if (type !== originalType) {
      event.type = originalType;
    }
  }

  // set the return value to false if the event default
  // got prevented and no other return value exists
  if (returnValue === undefined && event.defaultPrevented) {
    returnValue = false;
  }
  return returnValue;
};
EventBus.prototype.handleError = function (error) {
  return this.fire('error', {
    error: error
  }) === false;
};
EventBus.prototype._destroy = function () {
  this._listeners = {};
};
EventBus.prototype._invokeListeners = function (event, args, listener) {
  var returnValue;
  while (listener) {
    // handle stopped propagation
    if (event.cancelBubble) {
      break;
    }
    returnValue = this._invokeListener(event, args, listener);
    listener = listener.next;
  }
  return returnValue;
};
EventBus.prototype._invokeListener = function (event, args, listener) {
  var returnValue;
  if (listener.callback.__isTomb) {
    return returnValue;
  }
  try {
    // returning false prevents the default action
    returnValue = invokeFunction(listener.callback, args);

    // stop propagation on return value
    if (returnValue !== undefined) {
      event.returnValue = returnValue;
      event.stopPropagation();
    }

    // prevent default on return false
    if (returnValue === false) {
      event.preventDefault();
    }
  } catch (error) {
    if (!this.handleError(error)) {
      console.error('unhandled error in event listener', error);
      throw error;
    }
  }
  return returnValue;
};

/*
 * Add new listener with a certain priority to the list
 * of listeners (for the given event).
 *
 * The semantics of listener registration / listener execution are
 * first register, first serve: New listeners will always be inserted
 * after existing listeners with the same priority.
 *
 * Example: Inserting two listeners with priority 1000 and 1300
 *
 *    * before: [ 1500, 1500, 1000, 1000 ]
 *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]
 *
 * @param {string} event
 * @param {Object} listener { priority, callback }
 */
EventBus.prototype._addListener = function (event, newListener) {
  var listener = this._getListeners(event),
    previousListener;

  // no prior listeners
  if (!listener) {
    this._setListeners(event, newListener);
    return;
  }

  // ensure we order listeners by priority from
  // 0 (high) to n > 0 (low)
  while (listener) {
    if (listener.priority < newListener.priority) {
      newListener.next = listener;
      if (previousListener) {
        previousListener.next = newListener;
      } else {
        this._setListeners(event, newListener);
      }
      return;
    }
    previousListener = listener;
    listener = listener.next;
  }

  // add new listener to back
  previousListener.next = newListener;
};
EventBus.prototype._getListeners = function (name) {
  return this._listeners[name];
};
EventBus.prototype._setListeners = function (name, listener) {
  this._listeners[name] = listener;
};
EventBus.prototype._removeListener = function (event, callback) {
  var listener = this._getListeners(event),
    nextListener,
    previousListener,
    listenerCallback;
  if (!callback) {
    // clear listeners
    this._setListeners(event, null);
    return;
  }
  while (listener) {
    nextListener = listener.next;
    listenerCallback = listener.callback;
    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {
      if (previousListener) {
        previousListener.next = nextListener;
      } else {
        // new first listener
        this._setListeners(event, nextListener);
      }
    }
    previousListener = listener;
    listener = nextListener;
  }
};

/**
 * A event that is emitted via the event bus.
 */
function InternalEvent() {}
InternalEvent.prototype.stopPropagation = function () {
  this.cancelBubble = true;
};
InternalEvent.prototype.preventDefault = function () {
  this.defaultPrevented = true;
};
InternalEvent.prototype.init = function (data) {
  assign(this, data || {});
};

/**
 * Invoke function. Be fast...
 *
 * @param {Function} fn
 * @param {Array<Object>} args
 *
 * @return {Any}
 */
function invokeFunction(fn, args) {
  return fn.apply(null, args);
}

function countDecimals(number) {
  const num = Big(number);
  if (num.toString() === num.toFixed(0)) return 0;
  return num.toFixed().split('.')[1].length || 0;
}
function isValidNumber(value) {
  return (typeof value === 'number' || typeof value === 'string') && value !== '' && !isNaN(Number(value));
}
function willKeyProduceValidNumber(key, previousValue, caretIndex, selectionWidth, decimalDigits) {
  // Dot and comma are both treated as dot
  previousValue = previousValue.replace(',', '.');
  const isFirstDot = !previousValue.includes('.') && (key === '.' || key === ',');
  const isFirstMinus = !previousValue.includes('-') && key === '-' && caretIndex === 0;
  const keypressIsNumeric = /^[0-9]$/i.test(key);
  const dotIndex = previousValue === undefined ? -1 : previousValue.indexOf('.');

  // If the caret is positioned after a dot, and the current decimal digits count is equal or greater to the maximum, disallow the key press
  const overflowsDecimalSpace = typeof decimalDigits === 'number' && selectionWidth === 0 && dotIndex !== -1 && previousValue.includes('.') && previousValue.split('.')[1].length >= decimalDigits && caretIndex > dotIndex;
  const keypressIsAllowedChar = keypressIsNumeric || decimalDigits !== 0 && isFirstDot || isFirstMinus;
  return keypressIsAllowedChar && !overflowsDecimalSpace;
}
function isNullEquivalentValue(value) {
  return value === undefined || value === null || value === '';
}

const EMAIL_PATTERN = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
const PHONE_PATTERN = /(\+|00)(297|93|244|1264|358|355|376|971|54|374|1684|1268|61|43|994|257|32|229|226|880|359|973|1242|387|590|375|501|1441|591|55|1246|673|975|267|236|1|61|41|56|86|225|237|243|242|682|57|269|238|506|53|5999|61|1345|357|420|49|253|1767|45|1809|1829|1849|213|593|20|291|212|34|372|251|358|679|500|33|298|691|241|44|995|44|233|350|224|590|220|245|240|30|1473|299|502|594|1671|592|852|504|385|509|36|62|44|91|246|353|98|964|354|972|39|1876|44|962|81|76|77|254|996|855|686|1869|82|383|965|856|961|231|218|1758|423|94|266|370|352|371|853|590|212|377|373|261|960|52|692|389|223|356|95|382|976|1670|258|222|1664|596|230|265|60|262|264|687|227|672|234|505|683|31|47|977|674|64|968|92|507|64|51|63|680|675|48|1787|1939|850|351|595|970|689|974|262|40|7|250|966|249|221|65|500|4779|677|232|503|378|252|508|381|211|239|597|421|386|46|268|1721|248|963|1649|235|228|66|992|690|993|670|676|1868|216|90|688|886|255|256|380|598|1|998|3906698|379|1784|58|1284|1340|84|678|681|685|967|27|260|263)(9[976]\d|8[987530]\d|6[987]\d|5[90]\d|42\d|3[875]\d|2[98654321]\d|9[8543210]|8[6421]|6[6543210]|5[87654321]|4[987654310]|3[9643210]|2[70]|7|1)\d{4,20}$/;
class Validator {
  validateField(field, value) {
    const {
      type,
      validate
    } = field;
    let errors = [];
    if (type === 'number') {
      const {
        decimalDigits,
        increment
      } = field;
      if (value === 'NaN') {
        errors = [...errors, 'Value is not a number.'];
      } else if (value) {
        if (decimalDigits >= 0 && countDecimals(value) > decimalDigits) {
          errors = [...errors, 'Value is expected to ' + (decimalDigits === 0 ? 'be an integer' : `have at most ${decimalDigits} decimal digit${decimalDigits > 1 ? 's' : ''}`) + '.'];
        }
        if (increment) {
          const bigValue = Big(value);
          const bigIncrement = Big(increment);
          const offset = bigValue.mod(bigIncrement);
          if (offset.cmp(0) !== 0) {
            const previousValue = bigValue.minus(offset);
            const nextValue = previousValue.plus(bigIncrement);
            errors = [...errors, `Please select a valid value, the two nearest valid values are ${previousValue} and ${nextValue}.`];
          }
        }
      }
    }
    if (!validate) {
      return errors;
    }
    if (validate.pattern && value && !new RegExp(validate.pattern).test(value)) {
      errors = [...errors, `Field must match pattern ${validate.pattern}.`];
    }
    if (validate.required && (isNil(value) || value === '')) {
      errors = [...errors, 'Field is required.'];
    }
    if ('min' in validate && (value || value === 0) && value < validate.min) {
      errors = [...errors, `Field must have minimum value of ${validate.min}.`];
    }
    if ('max' in validate && (value || value === 0) && value > validate.max) {
      errors = [...errors, `Field must have maximum value of ${validate.max}.`];
    }
    if ('minLength' in validate && value && value.trim().length < validate.minLength) {
      errors = [...errors, `Field must have minimum length of ${validate.minLength}.`];
    }
    if ('maxLength' in validate && value && value.trim().length > validate.maxLength) {
      errors = [...errors, `Field must have maximum length of ${validate.maxLength}.`];
    }
    if ('validationType' in validate && value && validate.validationType === 'phone' && !PHONE_PATTERN.test(value)) {
      errors = [...errors, 'Field must be a valid  international phone number. (e.g. +4930664040900)'];
    }
    if ('validationType' in validate && value && validate.validationType === 'email' && !EMAIL_PATTERN.test(value)) {
      errors = [...errors, 'Field must be a valid email.'];
    }
    return errors;
  }
}
Validator.$inject = [];

class FormFieldRegistry {
  constructor(eventBus) {
    this._eventBus = eventBus;
    this._formFields = {};
    eventBus.on('form.clear', () => this.clear());
    this._ids = new Ids([32, 36, 1]);
    this._keys = new Ids([32, 36, 1]);
  }
  add(formField) {
    const {
      id
    } = formField;
    if (this._formFields[id]) {
      throw new Error(`form field with ID ${id} already exists`);
    }
    this._eventBus.fire('formField.add', {
      formField
    });
    this._formFields[id] = formField;
  }
  remove(formField) {
    const {
      id
    } = formField;
    if (!this._formFields[id]) {
      return;
    }
    this._eventBus.fire('formField.remove', {
      formField
    });
    delete this._formFields[id];
  }
  get(id) {
    return this._formFields[id];
  }
  getAll() {
    return Object.values(this._formFields);
  }
  forEach(callback) {
    this.getAll().forEach(formField => callback(formField));
  }
  clear() {
    this._formFields = {};
    this._ids.clear();
    this._keys.clear();
  }
}
FormFieldRegistry.$inject = ['eventBus'];

/**
 * Retrieve variable names from given FEEL unary test.
 *
 * @param {string} unaryTest
 * @returns {string[]}
 */
function getVariableNames(unaryTest) {
  const tree = parseUnaryTests(unaryTest);
  const cursor = tree.cursor();
  const variables = new Set();
  do {
    const node = cursor.node;
    if (node.type.name === 'VariableName') {
      variables.add(unaryTest.slice(node.from, node.to));
    }
  } while (cursor.next());
  return Array.from(variables);
}

/**
 * Retrieve variable names from given FEEL expression.
 *
 * @param {string} expression
 * @returns {string[]}
 */
function getExpressionVariableNames(expression) {
  const tree = parseExpressions(expression);
  const cursor = tree.cursor();
  const variables = new Set();
  do {
    const node = cursor.node;
    if (node.type.name === 'VariableName') {
      variables.add(expression.slice(node.from, node.to));
    }
  } while (cursor.next());
  return Array.from(variables);
}
function isExpression$1(value) {
  return isString(value) && value.startsWith('=');
}

// config  ///////////////////

const MINUTES_IN_DAY = 60 * 24;
const DATETIME_SUBTYPES = {
  DATE: 'date',
  TIME: 'time',
  DATETIME: 'datetime'
};
const TIME_SERIALISING_FORMATS = {
  UTC_OFFSET: 'utc_offset',
  UTC_NORMALIZED: 'utc_normalized',
  NO_TIMEZONE: 'no_timezone'
};
const DATETIME_SUBTYPES_LABELS = {
  [DATETIME_SUBTYPES.DATE]: 'Date',
  [DATETIME_SUBTYPES.TIME]: 'Time',
  [DATETIME_SUBTYPES.DATETIME]: 'Date & Time'
};
const TIME_SERIALISINGFORMAT_LABELS = {
  [TIME_SERIALISING_FORMATS.UTC_OFFSET]: 'UTC offset',
  [TIME_SERIALISING_FORMATS.UTC_NORMALIZED]: 'UTC normalized',
  [TIME_SERIALISING_FORMATS.NO_TIMEZONE]: 'No timezone'
};
const DATETIME_SUBTYPE_PATH = ['subtype'];
const DATE_LABEL_PATH = ['dateLabel'];
const DATE_DISALLOW_PAST_PATH = ['disallowPassedDates'];
const TIME_LABEL_PATH = ['timeLabel'];
const TIME_USE24H_PATH = ['use24h'];
const TIME_INTERVAL_PATH = ['timeInterval'];
const TIME_SERIALISING_FORMAT_PATH = ['timeSerializingFormat'];

// config  ///////////////////

const VALUES_SOURCES = {
  STATIC: 'static',
  INPUT: 'input'
};
const VALUES_SOURCE_DEFAULT = VALUES_SOURCES.STATIC;
const VALUES_SOURCES_LABELS = {
  [VALUES_SOURCES.STATIC]: 'Static',
  [VALUES_SOURCES.INPUT]: 'Input data'
};
const VALUES_SOURCES_PATHS = {
  [VALUES_SOURCES.STATIC]: ['values'],
  [VALUES_SOURCES.INPUT]: ['valuesKey']
};
const VALUES_SOURCES_DEFAULTS = {
  [VALUES_SOURCES.STATIC]: [{
    label: 'Value',
    value: 'value'
  }],
  [VALUES_SOURCES.INPUT]: ''
};

// helpers ///////////////////

function getValuesSource(field) {
  for (const source of Object.values(VALUES_SOURCES)) {
    if (get(field, VALUES_SOURCES_PATHS[source]) !== undefined) {
      return source;
    }
  }
  return VALUES_SOURCE_DEFAULT;
}

function createInjector(bootstrapModules) {
  const injector = new Injector(bootstrapModules);
  injector.init();
  return injector;
}

/**
 * @param {string?} prefix
 *
 * @returns Element
 */
function createFormContainer(prefix = 'fjs') {
  const container = document.createElement('div');
  container.classList.add(`${prefix}-container`);
  return container;
}

const EXPRESSION_PROPERTIES = ['alt', 'source', 'text'];
function findErrors(errors, path) {
  return errors[pathStringify(path)];
}
function isRequired(field) {
  return field.required;
}
function pathParse(path) {
  if (!path) {
    return [];
  }
  return path.split('.').map(key => {
    return isNaN(parseInt(key)) ? key : parseInt(key);
  });
}
function pathsEqual(a, b) {
  return a && b && a.length === b.length && a.every((value, index) => value === b[index]);
}
function pathStringify(path) {
  if (!path) {
    return '';
  }
  return path.join('.');
}
const indices = {};
function generateIndexForType(type) {
  if (type in indices) {
    indices[type]++;
  } else {
    indices[type] = 1;
  }
  return indices[type];
}
function generateIdForType(type) {
  return `${type}${generateIndexForType(type)}`;
}

/**
 * @template T
 * @param {T} data
 * @param {(this: any, key: string, value: any) => any} [replacer]
 * @return {T}
 */
function clone(data, replacer) {
  return JSON.parse(JSON.stringify(data, replacer));
}

/**
 * Parse the schema for input variables a form might make use of
 *
 * @param {any} schema
 *
 * @return {string[]}
 */
function getSchemaVariables(schema) {
  if (!schema.components) {
    return [];
  }
  const variables = schema.components.reduce((variables, component) => {
    const {
      key,
      valuesKey,
      type,
      conditional
    } = component;
    if (['button'].includes(type)) {
      return variables;
    }
    if (key) {
      variables = [...variables, key];
    }
    if (valuesKey) {
      variables = [...variables, valuesKey];
    }
    if (conditional && conditional.hide) {
      // cut off initial '='
      const conditionVariables = getVariableNames(conditional.hide.slice(1));
      variables = [...variables, ...conditionVariables];
    }
    EXPRESSION_PROPERTIES.forEach(prop => {
      const property = component[prop];
      if (property && isExpression$1(property)) {
        // cut off initial '='
        const expressionVariables = getExpressionVariableNames(property.slice(1));
        variables = [...variables, ...expressionVariables];
      }
    });
    return variables;
  }, []);

  // remove duplicates
  return Array.from(new Set(variables));
}

class Importer {
  /**
   * @constructor
   * @param { import('../core').FormFieldRegistry } formFieldRegistry
   * @param { import('../render/FormFields').default } formFields
   */
  constructor(formFieldRegistry, formFields) {
    this._formFieldRegistry = formFieldRegistry;
    this._formFields = formFields;
  }

  /**
   * Import schema adding `id`, `_parent` and `_path`
   * information to each field and adding it to the
   * form field registry.
   *
   * @param {any} schema
   * @param {any} [data]
   *
   * @return { { warnings: Array<any>, schema: any, data: any } }
   */
  importSchema(schema, data = {}) {
    // TODO: Add warnings - https://github.com/bpmn-io/form-js/issues/289
    const warnings = [];
    try {
      const importedSchema = this.importFormField(clone(schema)),
        initializedData = this.initializeFieldValues(clone(data));
      return {
        warnings,
        schema: importedSchema,
        data: initializedData
      };
    } catch (err) {
      err.warnings = warnings;
      throw err;
    }
  }

  /**
   * @param {any} formField
   * @param {string} [parentId]
   *
   * @return {any} importedField
   */
  importFormField(formField, parentId) {
    const {
      components,
      key,
      type,
      id = generateIdForType(type)
    } = formField;
    if (parentId) {
      // set form field parent
      formField._parent = parentId;
    }
    if (!this._formFields.get(type)) {
      throw new Error(`form field of type <${type}> not supported`);
    }
    if (key) {
      // validate <key> uniqueness
      if (this._formFieldRegistry._keys.assigned(key)) {
        throw new Error(`form field with key <${key}> already exists`);
      }
      this._formFieldRegistry._keys.claim(key, formField);

      // TODO: buttons should not have key
      if (type !== 'button') {
        // set form field path
        formField._path = [key];
      }
    }
    if (id) {
      // validate <id> uniqueness
      if (this._formFieldRegistry._ids.assigned(id)) {
        throw new Error(`form field with id <${id}> already exists`);
      }
      this._formFieldRegistry._ids.claim(id, formField);
    }

    // set form field ID
    formField.id = id;
    this._formFieldRegistry.add(formField);
    if (components) {
      this.importFormFields(components, id);
    }
    return formField;
  }
  importFormFields(components, parentId) {
    components.forEach(component => {
      this.importFormField(component, parentId);
    });
  }

  /**
   * @param {Object} data
   *
   * @return {Object} initializedData
   */
  initializeFieldValues(data) {
    return this._formFieldRegistry.getAll().reduce((initializedData, formField) => {
      const {
        defaultValue,
        _path,
        type
      } = formField;

      // try to get value from data
      // if unavailable - try to get default value from form field
      // if unavailable - get empty value from form field

      if (_path) {
        const fieldImplementation = this._formFields.get(type);
        let valueData = get(data, _path);
        if (!isUndefined(valueData) && fieldImplementation.sanitizeValue) {
          valueData = fieldImplementation.sanitizeValue({
            formField,
            data,
            value: valueData
          });
        }
        const initializedFieldValue = !isUndefined(valueData) ? valueData : !isUndefined(defaultValue) ? defaultValue : fieldImplementation.emptyValue;
        initializedData = {
          ...initializedData,
          [_path[0]]: initializedFieldValue
        };
      }
      return initializedData;
    }, data);
  }
}
Importer.$inject = ['formFieldRegistry', 'formFields'];

var importModule = {
  importer: ['type', Importer]
};

const NODE_TYPE_TEXT = 3,
  NODE_TYPE_ELEMENT = 1;
const ALLOWED_NODES = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'span', 'em', 'a', 'p', 'div', 'ul', 'ol', 'li', 'hr', 'blockquote', 'img', 'pre', 'code', 'br', 'strong'];
const ALLOWED_ATTRIBUTES = ['align', 'alt', 'class', 'href', 'id', 'name', 'rel', 'target', 'src'];
const ALLOWED_URI_PATTERN = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i; // eslint-disable-line no-useless-escape
const ALLOWED_IMAGE_SRC_PATTERN = /^(https?|data):.*/i; // eslint-disable-line no-useless-escape
const ATTR_WHITESPACE_PATTERN = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g; // eslint-disable-line no-control-regex

const FORM_ELEMENT = document.createElement('form');

/**
 * Sanitize a HTML string and return the cleaned, safe version.
 *
 * @param {string} html
 * @return {string}
 */
function sanitizeHTML(html) {
  const doc = new DOMParser().parseFromString(`<!DOCTYPE html>\n<html><body><div>${html}`, 'text/html');
  doc.normalize();
  const element = doc.body.firstChild;
  if (element) {
    sanitizeNode( /** @type Element */element);
    return new XMLSerializer().serializeToString(element);
  } else {
    // handle the case that document parsing
    // does not work at all, due to HTML gibberish
    return '';
  }
}
function sanitizeImageSource(src) {
  const valid = ALLOWED_IMAGE_SRC_PATTERN.test(src);
  return valid ? src : '';
}

/**
 * Recursively sanitize a HTML node, potentially
 * removing it, its children or attributes.
 *
 * Inspired by https://github.com/developit/snarkdown/issues/70
 * and https://github.com/cure53/DOMPurify. Simplified
 * for our use-case.
 *
 * @param {Element} node
 */
function sanitizeNode(node) {
  // allow text nodes
  if (node.nodeType === NODE_TYPE_TEXT) {
    return;
  }

  // disallow all other nodes but Element
  if (node.nodeType !== NODE_TYPE_ELEMENT) {
    return node.remove();
  }
  const lcTag = node.tagName.toLowerCase();

  // disallow non-whitelisted tags
  if (!ALLOWED_NODES.includes(lcTag)) {
    return node.remove();
  }
  const attributes = node.attributes;

  // clean attributes
  for (let i = attributes.length; i--;) {
    const attribute = attributes[i];
    const name = attribute.name;
    const lcName = name.toLowerCase();

    // normalize node value
    const value = attribute.value.trim();
    node.removeAttribute(name);
    const valid = isValidAttribute(lcTag, lcName, value);
    if (valid) {
      node.setAttribute(name, value);
    }
  }

  // force noopener on target="_blank" links
  if (lcTag === 'a' && node.getAttribute('target') === '_blank' && node.getAttribute('rel') !== 'noopener') {
    node.setAttribute('rel', 'noopener');
  }
  for (let i = node.childNodes.length; i--;) {
    sanitizeNode( /** @type Element */node.childNodes[i]);
  }
}

/**
 * Validates attributes for validity.
 *
 * @param {string} lcTag
 * @param {string} lcName
 * @param {string} value
 * @return {boolean}
 */
function isValidAttribute(lcTag, lcName, value) {
  // disallow most attributes based on whitelist
  if (!ALLOWED_ATTRIBUTES.includes(lcName)) {
    return false;
  }

  // disallow "DOM clobbering" / polution of document and wrapping form elements
  if ((lcName === 'id' || lcName === 'name') && (value in document || value in FORM_ELEMENT)) {
    return false;
  }
  if (lcName === 'target' && value !== '_blank') {
    return false;
  }

  // allow valid url links only
  if (lcName === 'href' && !ALLOWED_URI_PATTERN.test(value.replace(ATTR_WHITESPACE_PATTERN, ''))) {
    return false;
  }
  return true;
}

function formFieldClasses(type, {
  errors = [],
  disabled = false
} = {}) {
  if (!type) {
    throw new Error('type required');
  }
  return classNames('fjs-form-field', `fjs-form-field-${type}`, {
    'fjs-has-errors': errors.length > 0,
    'fjs-disabled': disabled
  });
}
function prefixId(id, formId) {
  if (formId) {
    return `fjs-form-${formId}-${id}`;
  }
  return `fjs-form-${id}`;
}
function markdownToHTML(markdown) {
  const htmls = markdown.toString().split(/(?:\r?\n){2,}/).map(line => /^((\d+.)|[><\s#-*])/.test(line) ? snarkdown(line) : `<p>${snarkdown(line)}</p>`);
  return htmls.join('\n\n');
}

// see https://github.com/developit/snarkdown/issues/70
function safeMarkdown(markdown) {
  const html = markdownToHTML(markdown);
  return sanitizeHTML(html);
}

/**
 * Sanitizes an image source to ensure we only allow for data URI and links
 * that start with http(s).
 *
 * Note: Most browsers anyway do not support script execution in <img> elements.
 *
 * @param {string} src
 * @returns {string}
 */
function safeImageSource(src) {
  return sanitizeImageSource(src);
}

const type$b = 'button';
function Button(props) {
  const {
    disabled,
    field
  } = props;
  const {
    action = 'submit'
  } = field;
  return jsx("div", {
    class: formFieldClasses(type$b),
    children: jsx("button", {
      class: "fjs-button",
      type: action,
      disabled: disabled,
      children: field.label
    })
  });
}
Button.create = (options = {}) => ({
  action: 'submit',
  ...options
});
Button.type = type$b;
Button.label = 'Button';
Button.keyed = true;
Button.group = 'action';

const FormRenderContext = createContext({
  Empty: props => {
    return null;
  },
  Children: props => {
    return props.children;
  },
  Element: props => {
    return props.children;
  }
});
var FormRenderContext$1 = FormRenderContext;

/**
 * @param {string} type
 * @param {boolean} [strict]
 *
 * @returns {any}
 */
function getService(type, strict) {}
const FormContext = createContext({
  getService,
  formId: null
});
var FormContext$1 = FormContext;

function Description(props) {
  const {
    description
  } = props;
  if (!description) {
    return null;
  }
  return jsx("div", {
    class: "fjs-form-field-description",
    children: description
  });
}

function Errors(props) {
  const {
    errors
  } = props;
  if (!errors.length) {
    return null;
  }
  return jsx("div", {
    class: "fjs-form-field-error",
    children: jsx("ul", {
      children: errors.map(error => {
        return jsx("li", {
          children: error
        });
      })
    })
  });
}

function Label(props) {
  const {
    id,
    label,
    collapseOnEmpty = true,
    required = false
  } = props;
  return jsxs("label", {
    for: id,
    class: classNames('fjs-form-field-label', {
      'fjs-incollapsible-label': !collapseOnEmpty
    }, props['class']),
    children: [props.children, label || '', required && jsx("span", {
      class: "fjs-asterix",
      children: "*"
    })]
  });
}

const type$a = 'checkbox';
function Checkbox(props) {
  const {
    disabled,
    errors = [],
    field,
    value = false
  } = props;
  const {
    description,
    id,
    label
  } = field;
  const onChange = ({
    target
  }) => {
    props.onChange({
      field,
      value: target.checked
    });
  };
  const {
    formId
  } = useContext(FormContext$1);
  return jsxs("div", {
    class: classNames(formFieldClasses(type$a, {
      errors,
      disabled
    }), {
      'fjs-checked': value
    }),
    children: [jsx(Label, {
      id: prefixId(id, formId),
      label: label,
      required: false,
      children: jsx("input", {
        checked: value,
        class: "fjs-input",
        disabled: disabled,
        id: prefixId(id, formId),
        type: "checkbox",
        onChange: onChange
      })
    }), jsx(Description, {
      description: description
    }), jsx(Errors, {
      errors: errors
    })]
  });
}
Checkbox.create = (options = {}) => ({
  ...options
});
Checkbox.type = type$a;
Checkbox.label = 'Checkbox';
Checkbox.keyed = true;
Checkbox.emptyValue = false;
Checkbox.sanitizeValue = ({
  value
}) => value === true;
Checkbox.group = 'selection';

function useService (type, strict) {
  const {
    getService
  } = useContext(FormContext$1);
  return getService(type, strict);
}

/**
 * @enum { String }
 */
const LOAD_STATES = {
  LOADING: 'loading',
  LOADED: 'loaded',
  ERROR: 'error'
};

/**
 * @typedef {Object} ValuesGetter
 * @property {Object[]} values - The values data
 * @property {(LOAD_STATES)} state - The values data's loading state, to use for conditional rendering
 */

/**
 * A hook to load values for single and multiselect components.
 *
 * @param {Object} field - The form field to handle values for
 * @return {ValuesGetter} valuesGetter - A values getter object providing loading state and values
 */
function useValuesAsync (field) {
  const {
    valuesKey,
    values: staticValues
  } = field;
  const [valuesGetter, setValuesGetter] = useState({
    values: [],
    error: undefined,
    state: LOAD_STATES.LOADING
  });
  const initialData = useService('form')._getState().initialData;
  useEffect(() => {
    let values = [];
    if (valuesKey !== undefined) {
      const keyedValues = (initialData || {})[valuesKey];
      if (keyedValues && Array.isArray(keyedValues)) {
        values = keyedValues;
      }
    } else if (staticValues !== undefined) {
      values = Array.isArray(staticValues) ? staticValues : [];
    } else {
      setValuesGetter(getErrorState('No values source defined in the form definition'));
      return;
    }
    setValuesGetter(buildLoadedState(values));
  }, [valuesKey, staticValues, initialData]);
  return valuesGetter;
}
const getErrorState = error => ({
  values: [],
  error,
  state: LOAD_STATES.ERROR
});
const buildLoadedState = values => ({
  values,
  error: undefined,
  state: LOAD_STATES.LOADED
});

const ENTER_KEYDOWN_EVENT = new KeyboardEvent('keydown', {
  code: 'Enter',
  key: 'Enter',
  charCode: 13,
  keyCode: 13,
  view: window,
  bubbles: true
});
function focusRelevantFlatpickerDay(flatpickrInstance) {
  if (!flatpickrInstance) return;
  !flatpickrInstance.isOpen && flatpickrInstance.open();
  const container = flatpickrInstance.calendarContainer;
  const dayToFocus = container.querySelector('.flatpickr-day.selected') || container.querySelector('.flatpickr-day.today') || container.querySelector('.flatpickr-day');
  dayToFocus && dayToFocus.focus();
}
function formatTime(use24h, minutes) {
  if (minutes === null) return null;
  const wrappedMinutes = minutes % (24 * 60);
  const minute = minutes % 60;
  let hour = Math.floor(wrappedMinutes / 60);
  if (use24h) {
    return _getZeroPaddedString(hour) + ':' + _getZeroPaddedString(minute);
  }
  hour = hour % 12 || 12;
  const isPM = wrappedMinutes >= 12 * 60;
  return _getZeroPaddedString(hour) + ':' + _getZeroPaddedString(minute) + ' ' + (isPM ? 'PM' : 'AM');
}
function parseInputTime(stringTime) {
  let workingString = stringTime.toLowerCase();
  const is12h = workingString.includes('am') || workingString.includes('pm');
  if (is12h) {
    const isPM = workingString.includes('pm');
    const digits = workingString.match(/\d+/g);
    const displayHour = parseInt(digits && digits[0]);
    const minute = parseInt(digits && digits[1]) || 0;
    const isValidDisplayHour = isNumber(displayHour) && displayHour >= 1 && displayHour <= 12;
    const isValidMinute = minute >= 0 && minute <= 59;
    if (!isValidDisplayHour || !isValidMinute) return null;
    const hour = displayHour % 12 + (isPM ? 12 : 0);
    return hour * 60 + minute;
  } else {
    const digits = workingString.match(/\d+/g);
    const hour = parseInt(digits && digits[0]);
    const minute = parseInt(digits && digits[1]);
    const isValidHour = isNumber(hour) && hour >= 0 && hour <= 23;
    const isValidMinute = isNumber(minute) && minute >= 0 && minute <= 59;
    if (!isValidHour || !isValidMinute) return null;
    return hour * 60 + minute;
  }
}
function serializeTime(minutes, offset, timeSerializingFormat) {
  if (timeSerializingFormat === TIME_SERIALISING_FORMATS.UTC_NORMALIZED) {
    const normalizedMinutes = (minutes + offset + MINUTES_IN_DAY) % MINUTES_IN_DAY;
    return _getZeroPaddedString(Math.floor(normalizedMinutes / 60)) + ':' + _getZeroPaddedString(normalizedMinutes % 60) + 'Z';
  }
  const baseTime = _getZeroPaddedString(Math.floor(minutes / 60)) + ':' + _getZeroPaddedString(minutes % 60);
  const addUTCOffset = timeSerializingFormat === TIME_SERIALISING_FORMATS.UTC_OFFSET;
  return baseTime + (addUTCOffset ? formatTimezoneOffset(offset) : '');
}
function parseIsoTime(isoTimeString) {
  if (!isoTimeString) return null;
  const parseBasicMinutes = timeString => {
    const timeSegments = timeString.split(':');
    const hour = parseInt(timeSegments[0]);
    const minute = timeSegments.length > 1 ? parseInt(timeSegments[1]) : 0;
    if (isNaN(hour) || hour < 0 || hour > 24 || isNaN(minute) || minute < 0 || minute > 60) return null;
    return hour * 60 + minute;
  };
  const localOffset = new Date().getTimezoneOffset();

  // Parse normalized time
  if (isoTimeString.includes('Z')) {
    isoTimeString = isoTimeString.replace('Z', '');
    const minutes = parseBasicMinutes(isoTimeString);
    if (minutes === null) return null;
    return (minutes - localOffset + MINUTES_IN_DAY) % MINUTES_IN_DAY;
  }

  // Parse offset positive time
  else if (isoTimeString.includes('+')) {
    const [timeString, offsetString] = isoTimeString.split('+');
    const minutes = parseBasicMinutes(timeString);
    let inboundOffset = parseBasicMinutes(offsetString);
    if (minutes === null || inboundOffset === null) return null;

    // The offset is flipped for consistency with javascript
    inboundOffset = -inboundOffset;
    return (minutes + inboundOffset - localOffset + MINUTES_IN_DAY) % MINUTES_IN_DAY;
  }

  // Parse offset negative time
  else if (isoTimeString.includes('-')) {
    const [timeString, offsetString] = isoTimeString.split('-');
    const minutes = parseBasicMinutes(timeString);
    let inboundOffset = parseBasicMinutes(offsetString);
    if (minutes === null || inboundOffset === null) return null;
    return (minutes + inboundOffset - localOffset + MINUTES_IN_DAY) % MINUTES_IN_DAY;
  }

  // Default to local parsing
  else {
    return parseBasicMinutes(isoTimeString);
  }
}
function serializeDate(date) {
  var d = new Date(date),
    month = '' + (d.getMonth() + 1),
    day = '' + d.getDate(),
    year = d.getFullYear();
  if (month.length < 2) month = '0' + month;
  if (day.length < 2) day = '0' + day;
  return [year, month, day].join('-');
}

// this method is used to make the `new Date(value)` parsing behavior stricter
function isDateTimeInputInformationSufficient(value) {
  if (!value || typeof value !== 'string') return false;
  const segments = value.split('T');
  if (segments.length != 2) return false;
  const dateNumbers = segments[0].split('-');
  if (dateNumbers.length != 3) return false;
  return true;
}

// this method checks if the date isn't a datetime, or a partial date
function isDateInputInformationMatching(value) {
  if (!value || typeof value !== 'string') return false;
  if (value.includes('T')) return false;
  const dateNumbers = value.split('-');
  if (dateNumbers.length != 3) return false;
  return true;
}
function serializeDateTime(date, time, timeSerializingFormat) {
  const workingDate = new Date();
  workingDate.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
  workingDate.setHours(Math.floor(time / 60), time % 60, 0, 0);
  if (timeSerializingFormat === TIME_SERIALISING_FORMATS.UTC_NORMALIZED) {
    const timezoneOffsetMinutes = workingDate.getTimezoneOffset();
    const dayOffset = time + timezoneOffsetMinutes < 0 ? -1 : time + timezoneOffsetMinutes > MINUTES_IN_DAY ? 1 : 0;

    // Apply the date rollover pre-emptively
    workingDate.setHours(workingDate.getHours() + dayOffset * 24);
  }
  return serializeDate(workingDate) + 'T' + serializeTime(time, workingDate.getTimezoneOffset(), timeSerializingFormat);
}
function formatTimezoneOffset(minutes) {
  return _getSignedPaddedHours(minutes) + ':' + _getZeroPaddedString(Math.abs(minutes % 60));
}
function isInvalidDateString(value) {
  return isNaN(new Date(Date.parse(value)).getTime());
}
function _getSignedPaddedHours(minutes) {
  if (minutes > 0) {
    return '-' + _getZeroPaddedString(Math.floor(minutes / 60));
  } else {
    return '+' + _getZeroPaddedString(Math.floor((0 - minutes) / 60));
  }
}
function _getZeroPaddedString(time) {
  return time.toString().padStart(2, '0');
}

function sanitizeDateTimePickerValue(options) {
  const {
    formField,
    value
  } = options;
  const {
    subtype
  } = formField;
  if (typeof value !== 'string') return null;
  if (subtype === DATETIME_SUBTYPES.DATE && (isInvalidDateString(value) || !isDateInputInformationMatching(value))) return null;
  if (subtype === DATETIME_SUBTYPES.TIME && parseIsoTime(value) === null) return null;
  if (subtype === DATETIME_SUBTYPES.DATETIME && (isInvalidDateString(value) || !isDateTimeInputInformationSufficient(value))) return null;
  return value;
}
function sanitizeSingleSelectValue(options) {
  const {
    formField,
    data,
    value
  } = options;
  const {
    valuesKey,
    values
  } = formField;
  try {
    const validValues = (valuesKey ? get(data, [valuesKey]) : values).map(v => v.value) || [];
    return validValues.includes(value) ? value : null;
  } catch (error) {
    // use default value in case of formatting error
    // TODO(@Skaiir): log a warning when this happens - https://github.com/bpmn-io/form-js/issues/289
    return null;
  }
}
function sanitizeMultiSelectValue(options) {
  const {
    formField,
    data,
    value
  } = options;
  const {
    valuesKey,
    values
  } = formField;
  try {
    const validValues = (valuesKey ? get(data, [valuesKey]) : values).map(v => v.value) || [];
    return value.filter(v => validValues.includes(v));
  } catch (error) {
    // use default value in case of formatting error
    // TODO(@Skaiir): log a warning when this happens - https://github.com/bpmn-io/form-js/issues/289
    return [];
  }
}

const type$9 = 'checklist';
function Checklist(props) {
  const {
    disabled,
    errors = [],
    field,
    value = []
  } = props;
  const {
    description,
    id,
    label
  } = field;
  const toggleCheckbox = v => {
    let newValue = [...value];
    if (!newValue.includes(v)) {
      newValue.push(v);
    } else {
      newValue = newValue.filter(x => x != v);
    }
    props.onChange({
      field,
      value: newValue
    });
  };
  const {
    state: loadState,
    values: options
  } = useValuesAsync(field);
  const {
    formId
  } = useContext(FormContext$1);
  return jsxs("div", {
    class: classNames(formFieldClasses(type$9, {
      errors,
      disabled
    })),
    children: [jsx(Label, {
      label: label
    }), loadState == LOAD_STATES.LOADED && options.map((v, index) => {
      return jsx(Label, {
        id: prefixId(`${id}-${index}`, formId),
        label: v.label,
        class: classNames({
          'fjs-checked': value.includes(v.value)
        }),
        required: false,
        children: jsx("input", {
          checked: value.includes(v.value),
          class: "fjs-input",
          disabled: disabled,
          id: prefixId(`${id}-${index}`, formId),
          type: "checkbox",
          onClick: () => toggleCheckbox(v.value)
        })
      }, `${id}-${index}`);
    }), jsx(Description, {
      description: description
    }), jsx(Errors, {
      errors: errors
    })]
  });
}
Checklist.create = (options = {}) => {
  const defaults = {};

  // provide default values if valuesKey isn't set
  if (!options.valuesKey) {
    defaults.values = [{
      label: 'Value',
      value: 'value'
    }];
  }
  return {
    ...defaults,
    ...options
  };
};
Checklist.type = type$9;
Checklist.label = 'Checklist';
Checklist.keyed = true;
Checklist.emptyValue = [];
Checklist.sanitizeValue = sanitizeMultiSelectValue;
Checklist.group = 'selection';

/**
 * Check if condition is met with given variables.
 *
 * @param {string | undefined} condition
 * @param {import('../../types').Data} data
 *
 * @returns {boolean} true if condition is met or no condition or condition checker exists
 */
function useCondition(condition, data) {
  const initialData = useService('form')._getState().initialData;
  const conditionChecker = useService('conditionChecker', false);
  if (!conditionChecker) {
    return null;
  }

  // make sure we do not use data from hidden fields
  const filteredData = {
    ...initialData,
    ...conditionChecker.applyConditions(data, data)
  };
  return conditionChecker.check(condition, filteredData);
}

const noop$1 = () => false;
function FormField(props) {
  const {
    field,
    onChange
  } = props;
  const {
    _path
  } = field;
  const formFields = useService('formFields'),
    form = useService('form');
  const {
    data,
    errors,
    properties
  } = form._getState();
  const {
    Element,
    Empty
  } = useContext(FormRenderContext$1);
  const FormFieldComponent = formFields.get(field.type);
  if (!FormFieldComponent) {
    throw new Error(`cannot render field <${field.type}>`);
  }
  const value = get(data, _path);
  const fieldErrors = findErrors(errors, _path);
  const disabled = properties.readOnly || field.disabled || false;
  const hidden = useHideCondition(field, data);
  if (hidden) {
    return jsx(Empty, {});
  }
  return jsx(Element, {
    field: field,
    children: jsx(FormFieldComponent, {
      ...props,
      disabled: disabled,
      errors: fieldErrors,
      onChange: disabled ? noop$1 : onChange,
      value: value
    })
  });
}
function useHideCondition(field, data) {
  const hideCondition = field.conditional && field.conditional.hide;
  return useCondition(hideCondition, data) === true;
}

function Default(props) {
  const {
    Children,
    Empty
  } = useContext(FormRenderContext$1);
  const {
    field
  } = props;
  const {
    components = []
  } = field;
  return jsxs(Children, {
    class: "fjs-vertical-layout",
    field: field,
    children: [components.map(childField => {
      return createElement(FormField, {
        ...props,
        key: childField.id,
        field: childField
      });
    }), components.length ? null : jsx(Empty, {})]
  });
}
Default.create = (options = {}) => ({
  components: [],
  ...options
});
Default.type = 'default';
Default.keyed = false;
Default.label = null;
Default.group = null;

function _extends$j() { _extends$j = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$j.apply(this, arguments); }
var CalendarIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$j({
  width: "14",
  height: "15",
  viewBox: "0 0 28 30",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  fill: "currentColor",
  d: "M19 2H9V0H7v2H2a2 2 0 00-2 2v24a2 2 0 002 2h24a2 2 0 002-2V4a2 2 0 00-2-2h-5V0h-2v2zM7 7V4H2v5h24V4h-5v3h-2V4H9v3H7zm-5 4v17h24V11H2z"
})));

function InputAdorner(props) {
  const {
    pre = null,
    post = null,
    rootRef,
    inputRef,
    children,
    disabled,
    hasErrors
  } = props;
  const onAdornmentClick = () => inputRef && inputRef.current && inputRef.current.focus();
  return jsxs("div", {
    class: classNames('fjs-input-group', {
      'fjs-disabled': disabled
    }, {
      'hasErrors': hasErrors
    }),
    ref: rootRef,
    children: [pre !== null && jsxs("span", {
      class: "fjs-input-adornment border-right border-radius-left",
      onClick: onAdornmentClick,
      children: [" ", isString(pre) ? jsx("span", {
        class: "fjs-input-adornment-text",
        children: pre
      }) : pre, " "]
    }), children, post !== null && jsxs("span", {
      class: "fjs-input-adornment border-left border-radius-right",
      onClick: onAdornmentClick,
      children: [" ", isString(post) ? jsx("span", {
        class: "fjs-input-adornment-text",
        children: post
      }) : post, " "]
    })]
  });
}

function Datepicker(props) {
  const {
    id,
    label,
    collapseLabelOnEmpty,
    formId,
    required,
    disabled,
    disallowPassedDates,
    date,
    setDate
  } = props;
  const dateInputRef = useRef();
  const focusScopeRef = useRef();
  const [flatpickrInstance, setFlatpickrInstance] = useState(null);
  const [isInputDirty, setIsInputDirty] = useState(false);
  const [forceFocusCalendar, setForceFocusCalendar] = useState(false);

  // shorts the date value back to the source
  useEffect(() => {
    if (!flatpickrInstance || !flatpickrInstance.config) return;
    flatpickrInstance.setDate(date, true);
    setIsInputDirty(false);
  }, [flatpickrInstance, date.toString()]);
  useEffect(() => {
    if (!forceFocusCalendar) return;
    focusRelevantFlatpickerDay(flatpickrInstance);
    setForceFocusCalendar(false);
  }, [flatpickrInstance, forceFocusCalendar]);

  // setup flatpickr instance
  useEffect(() => {
    let config = {
      allowInput: true,
      dateFormat: 'm/d/Y',
      static: true,
      clickOpens: false,
      // TODO: support dates prior to 1900 (https://github.com/bpmn-io/form-js/issues/533)
      minDate: disallowPassedDates ? 'today' : '01/01/1900',
      errorHandler: () => {/* do nothing, we expect the values to sometimes be erronous and we don't want warnings polluting the console */}
    };
    const instance = flatpickr(dateInputRef.current, config);
    setFlatpickrInstance(instance);
    const onCalendarFocusOut = e => {
      if (!instance.calendarContainer.contains(e.relatedTarget) && e.relatedTarget != dateInputRef.current) {
        instance.close();
      }
    };

    // remove dirty tag to have mouse day selection prioritize input blur
    const onCalendarMouseDown = e => {
      if (e.target.classList.contains('flatpickr-day')) {
        setIsInputDirty(false);
      }
    };

    // when the dropdown of the datepickr opens, we register a few event handlers to re-implement some of the
    // flatpicker logic that was lost when setting allowInput to true
    instance.config.onOpen = [() => instance.calendarContainer.addEventListener('focusout', onCalendarFocusOut), () => instance.calendarContainer.addEventListener('mousedown', onCalendarMouseDown)];
    instance.config.onClose = [() => instance.calendarContainer.removeEventListener('focusout', onCalendarFocusOut), () => instance.calendarContainer.removeEventListener('mousedown', onCalendarMouseDown)];
  }, [disallowPassedDates]);

  // onChange is updated dynamically, so not to re-render the flatpicker every time it changes
  useEffect(() => {
    if (!flatpickrInstance || !flatpickrInstance.config) return;
    flatpickrInstance.config.onChange = [date => setDate(new Date(date)), () => setIsInputDirty(false)];
  }, [flatpickrInstance, setDate]);
  const onInputKeyDown = useCallback(e => {
    if (!flatpickrInstance) return;
    if (e.code === 'Escape') {
      flatpickrInstance.close();
    }
    if (e.code === 'ArrowDown') {
      if (isInputDirty) {
        // trigger an enter keypress to submit the new input, then focus calendar day on the next render cycle
        dateInputRef.current.dispatchEvent(ENTER_KEYDOWN_EVENT);
        setIsInputDirty(false);
        setForceFocusCalendar(true);
      } else {
        // focus calendar day immediately
        focusRelevantFlatpickerDay(flatpickrInstance);
      }
      e.preventDefault();
    }
    if (e.code === 'Enter') {
      setIsInputDirty(false);
    }
  }, [flatpickrInstance, isInputDirty]);
  const onInputFocus = useCallback(e => {
    if (!flatpickrInstance || focusScopeRef.current.contains(e.relatedTarget)) return;
    flatpickrInstance.open();
  }, [flatpickrInstance]);

  // simulate an enter press on blur to make sure the date value is submitted in all scenarios
  const onInputBlur = useCallback(e => {
    if (!isInputDirty || e.relatedTarget && e.relatedTarget.classList.contains('flatpickr-day')) return;
    dateInputRef.current.dispatchEvent(ENTER_KEYDOWN_EVENT);
    setIsInputDirty(false);
  }, [isInputDirty]);
  const fullId = `${prefixId(id, formId)}--date`;
  return jsxs("div", {
    class: "fjs-datetime-subsection",
    children: [jsx(Label, {
      id: fullId,
      label: label,
      collapseOnEmpty: collapseLabelOnEmpty,
      required: required
    }), jsx(InputAdorner, {
      pre: jsx(CalendarIcon, {}),
      disabled: disabled,
      rootRef: focusScopeRef,
      inputRef: dateInputRef,
      children: jsx("div", {
        class: "fjs-datepicker",
        style: {
          width: '100%'
        },
        children: jsx("input", {
          ref: dateInputRef,
          type: "text",
          id: fullId,
          class: 'fjs-input',
          disabled: disabled,
          placeholder: "mm/dd/yyyy",
          autoComplete: "off",
          onFocus: onInputFocus,
          onKeyDown: onInputKeyDown,
          onMouseDown: e => !flatpickrInstance.isOpen && flatpickrInstance.open(),
          onBlur: onInputBlur,
          onInput: e => setIsInputDirty(true),
          "data-input": true
        })
      })
    })]
  });
}

function _extends$i() { _extends$i = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$i.apply(this, arguments); }
var ClockIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$i({
  width: "16",
  height: "16",
  viewBox: "0 0 28 29",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("path", {
  fill: "currentColor",
  d: "M13 14.41L18.59 20 20 18.59l-5-5.01V5h-2v9.41z"
}), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  fill: "currentColor",
  d: "M6.222 25.64A14 14 0 1021.778 2.36 14 14 0 006.222 25.64zM7.333 4.023a12 12 0 1113.334 19.955A12 12 0 017.333 4.022z"
})));

function useKeyDownAction(targetKey, action, listenerElement = window) {
  function downHandler({
    key
  }) {
    if (key === targetKey) {
      action();
    }
  }
  useEffect(() => {
    listenerElement.addEventListener('keydown', downHandler);
    return () => {
      listenerElement.removeEventListener('keydown', downHandler);
    };
  });
}

const DEFAULT_LABEL_GETTER = value => value;
const NOOP = () => {};
function DropdownList(props) {
  const {
    listenerElement = window,
    values = [],
    getLabel = DEFAULT_LABEL_GETTER,
    onValueSelected = NOOP,
    height = 235,
    emptyListMessage = 'No results',
    initialFocusIndex = 0
  } = props;
  const [mouseControl, setMouseControl] = useState(false);
  const [focusedValueIndex, setFocusedValueIndex] = useState(initialFocusIndex);
  const [smoothScrolling, setSmoothScrolling] = useState(false);
  const dropdownContainer = useRef();
  const mouseScreenPos = useRef();
  const focusedItem = useMemo(() => values.length ? values[focusedValueIndex] : null, [focusedValueIndex, values]);
  const changeFocusedValueIndex = useCallback(delta => {
    setFocusedValueIndex(x => Math.min(Math.max(0, x + delta), values.length - 1));
  }, [values.length]);
  useEffect(() => {
    if (focusedValueIndex === 0) return;
    if (!focusedValueIndex || !values.length) {
      setFocusedValueIndex(0);
    } else if (focusedValueIndex >= values.length) {
      setFocusedValueIndex(values.length - 1);
    }
  }, [focusedValueIndex, values.length]);
  useKeyDownAction('ArrowUp', () => {
    if (values.length) {
      changeFocusedValueIndex(-1);
      setMouseControl(false);
    }
  }, listenerElement);
  useKeyDownAction('ArrowDown', () => {
    if (values.length) {
      changeFocusedValueIndex(1);
      setMouseControl(false);
    }
  }, listenerElement);
  useKeyDownAction('Enter', () => {
    if (focusedItem) {
      onValueSelected(focusedItem);
    }
  }, listenerElement);
  useEffect(() => {
    const individualEntries = dropdownContainer.current.children;
    if (individualEntries.length && !mouseControl) {
      individualEntries[focusedValueIndex].scrollIntoView({
        block: 'nearest',
        inline: 'nearest'
      });
    }
  }, [focusedValueIndex, mouseControl]);
  useEffect(() => {
    setSmoothScrolling(true);
  }, []);
  const onMouseMovedInKeyboardMode = (event, valueIndex) => {
    const userMovedCursor = !mouseScreenPos.current || mouseScreenPos.current.x !== event.screenX && mouseScreenPos.current.y !== event.screenY;
    if (userMovedCursor) {
      mouseScreenPos.current = {
        x: event.screenX,
        y: event.screenY
      };
      setMouseControl(true);
      setFocusedValueIndex(valueIndex);
    }
  };
  return jsxs("div", {
    ref: dropdownContainer,
    tabIndex: -1,
    class: "fjs-dropdownlist",
    onMouseDown: e => e.preventDefault(),
    style: {
      maxHeight: height,
      scrollBehavior: smoothScrolling ? 'smooth' : 'auto'
    },
    children: [values.length > 0 && values.map((v, i) => {
      return jsx("div", {
        class: classNames('fjs-dropdownlist-item', {
          'focused': focusedValueIndex === i
        }),
        onMouseMove: mouseControl ? undefined : e => onMouseMovedInKeyboardMode(e, i),
        onMouseEnter: mouseControl ? () => setFocusedValueIndex(i) : undefined,
        onMouseDown: e => onValueSelected(v),
        children: getLabel(v)
      });
    }), !values.length && jsx("div", {
      class: "fjs-dropdownlist-empty",
      children: emptyListMessage
    })]
  });
}

function Timepicker(props) {
  const {
    id,
    label,
    collapseLabelOnEmpty,
    formId,
    required,
    disabled,
    use24h = false,
    timeInterval,
    time,
    setTime
  } = props;
  const timeInputRef = useRef();
  const [dropdownIsOpen, setDropdownIsOpen] = useState(false);
  const useDropdown = useMemo(() => timeInterval !== 1, [timeInterval]);
  const [rawValue, setRawValue] = useState('');

  // populates values from source
  useEffect(() => {
    if (time === null) {
      setRawValue('');
      return;
    }
    const intervalAdjustedTime = time - time % timeInterval;
    setRawValue(formatTime(use24h, intervalAdjustedTime));
    if (intervalAdjustedTime != time) {
      setTime(intervalAdjustedTime);
    }
  }, [time, setTime, use24h, timeInterval]);
  const propagateRawToMinute = useCallback(newRawValue => {
    const localRawValue = newRawValue || rawValue;

    // If no raw value exists, set the minute to null
    if (!localRawValue) {
      setTime(null);
      return;
    }
    const minutes = parseInputTime(localRawValue);

    // If raw string couldn't be parsed, clean everything up
    if (!isNumber(minutes)) {
      setRawValue('');
      setTime(null);
      return;
    }

    // Enforce the minutes to match the timeInterval
    const correctedMinutes = minutes - minutes % timeInterval;

    // Enforce the raw text to be formatted properly
    setRawValue(formatTime(use24h, correctedMinutes));
    setTime(correctedMinutes);
  }, [rawValue, timeInterval, use24h, setTime]);
  const timeOptions = useMemo(() => {
    const minutesInDay = 24 * 60;
    const intervalCount = Math.floor(minutesInDay / timeInterval);
    return [...Array(intervalCount).keys()].map(intervalIndex => formatTime(use24h, intervalIndex * timeInterval));
  }, [timeInterval, use24h]);
  const initialFocusIndex = useMemo(() => {
    // if there are no options, there will not be any focusing
    if (!timeOptions || !timeInterval) return null;

    // if there is a set minute value, we focus it in the dropdown
    if (time) return time / timeInterval;
    const cacheTime = parseInputTime(rawValue);

    // if there is a valid value in the input cache, we try and focus close to it
    if (cacheTime) {
      const flooredCacheTime = cacheTime - cacheTime % timeInterval;
      return flooredCacheTime / timeInterval;
    }

    // If there is no set value, simply focus the middle of the dropdown (12:00)
    return Math.floor(timeOptions.length / 2);
  }, [rawValue, time, timeInterval, timeOptions]);
  const onInputKeyDown = e => {
    switch (e.key) {
      case 'ArrowUp':
        e.preventDefault();
        break;
      case 'ArrowDown':
        useDropdown && setDropdownIsOpen(true);
        e.preventDefault();
        break;
      case 'Escape':
        useDropdown && setDropdownIsOpen(false);
        break;
      case 'Enter':
        !dropdownIsOpen && propagateRawToMinute();
        break;
    }
  };
  const onInputBlur = e => {
    setDropdownIsOpen(false);
    propagateRawToMinute();
  };
  const onDropdownValueSelected = value => {
    setDropdownIsOpen(false);
    propagateRawToMinute(value);
  };
  const fullId = `${prefixId(id, formId)}--time`;
  return jsxs("div", {
    class: "fjs-datetime-subsection",
    children: [jsx(Label, {
      id: fullId,
      label: label,
      collapseOnEmpty: collapseLabelOnEmpty,
      required: required
    }), jsx(InputAdorner, {
      pre: jsx(ClockIcon, {}),
      inputRef: timeInputRef,
      disabled: disabled,
      children: jsxs("div", {
        class: "fjs-timepicker fjs-timepicker-anchor",
        children: [jsx("input", {
          ref: timeInputRef,
          type: "text",
          id: fullId,
          class: "fjs-input",
          value: rawValue,
          disabled: disabled,
          placeholder: use24h ? 'hh:mm' : 'hh:mm ?m',
          autoComplete: "off",
          onFocus: () => useDropdown && setDropdownIsOpen(true),
          onClick: () => useDropdown && setDropdownIsOpen(true)

          // @ts-ignore
          ,
          onInput: e => {
            setRawValue(e.target.value);
            useDropdown && setDropdownIsOpen(false);
          },
          onBlur: onInputBlur,
          onKeyDown: onInputKeyDown,
          "data-input": true
        }), dropdownIsOpen && jsx(DropdownList, {
          values: timeOptions,
          height: 150,
          onValueSelected: onDropdownValueSelected,
          listenerElement: timeInputRef.current,
          initialFocusIndex: initialFocusIndex
        })]
      })
    })]
  });
}

const type$8 = 'datetime';
function Datetime(props) {
  const {
    disabled,
    errors = [],
    field,
    onChange,
    value = ''
  } = props;
  const {
    description,
    id,
    dateLabel,
    timeLabel,
    validate = {},
    subtype,
    use24h,
    disallowPassedDates,
    timeInterval,
    timeSerializingFormat
  } = field;
  const {
    required
  } = validate;
  const {
    formId
  } = useContext(FormContext$1);
  const getNullDateTime = () => ({
    date: new Date(Date.parse(null)),
    time: null
  });
  const [dateTime, setDateTime] = useState(getNullDateTime());
  const [dateTimeUpdateRequest, setDateTimeUpdateRequest] = useState(null);
  const isValidDate = date => date && !isNaN(date.getTime());
  const isValidTime = time => !isNaN(parseInt(time));
  const useDatePicker = useMemo(() => subtype === DATETIME_SUBTYPES.DATE || subtype === DATETIME_SUBTYPES.DATETIME, [subtype]);
  const useTimePicker = useMemo(() => subtype === DATETIME_SUBTYPES.TIME || subtype === DATETIME_SUBTYPES.DATETIME, [subtype]);
  useEffect(() => {
    let {
      date,
      time
    } = getNullDateTime();
    switch (subtype) {
      case DATETIME_SUBTYPES.DATE:
        {
          date = new Date(Date.parse(value));
          break;
        }
      case DATETIME_SUBTYPES.TIME:
        {
          time = parseIsoTime(value);
          break;
        }
      case DATETIME_SUBTYPES.DATETIME:
        {
          date = new Date(Date.parse(value));
          time = isValidDate(date) ? 60 * date.getHours() + date.getMinutes() : null;
          break;
        }
    }
    setDateTime({
      date,
      time
    });
  }, [subtype, value]);
  const computeAndSetState = useCallback(({
    date,
    time
  }) => {
    let newDateTimeValue = null;
    if (subtype === DATETIME_SUBTYPES.DATE && isValidDate(date)) {
      newDateTimeValue = serializeDate(date);
    } else if (subtype === DATETIME_SUBTYPES.TIME && isValidTime(time)) {
      newDateTimeValue = serializeTime(time, new Date().getTimezoneOffset(), timeSerializingFormat);
    } else if (subtype === DATETIME_SUBTYPES.DATETIME && isValidDate(date) && isValidTime(time)) {
      newDateTimeValue = serializeDateTime(date, time, timeSerializingFormat);
    }
    onChange({
      value: newDateTimeValue,
      field
    });
  }, [field, onChange, subtype, timeSerializingFormat]);
  useEffect(() => {
    if (dateTimeUpdateRequest) {
      if (dateTimeUpdateRequest.refreshOnly) {
        computeAndSetState(dateTime);
      } else {
        const newDateTime = {
          ...dateTime,
          ...dateTimeUpdateRequest
        };
        setDateTime(newDateTime);
        computeAndSetState(newDateTime);
      }
      setDateTimeUpdateRequest(null);
    }
  }, [computeAndSetState, dateTime, dateTimeUpdateRequest]);
  useEffect(() => {
    setDateTimeUpdateRequest({
      refreshOnly: true
    });
  }, [timeSerializingFormat]);
  const allErrors = useMemo(() => {
    if (required || subtype !== DATETIME_SUBTYPES.DATETIME) return errors;
    const isOnlyOneFieldSet = isValidDate(dateTime.date) && !isValidTime(dateTime.time) || !isValidDate(dateTime.date) && isValidTime(dateTime.time);
    return isOnlyOneFieldSet ? ['Date and time must both be entered.', ...errors] : errors;
  }, [required, subtype, dateTime, errors]);
  const setDate = useCallback(date => {
    setDateTimeUpdateRequest(prev => prev ? {
      ...prev,
      date
    } : {
      date
    });
  }, []);
  const setTime = useCallback(time => {
    setDateTimeUpdateRequest(prev => prev ? {
      ...prev,
      time
    } : {
      time
    });
  }, []);
  const datePickerProps = {
    id,
    label: dateLabel,
    collapseLabelOnEmpty: !timeLabel,
    formId,
    required,
    disabled,
    disallowPassedDates,
    date: dateTime.date,
    setDate
  };
  const timePickerProps = {
    id,
    label: timeLabel,
    collapseLabelOnEmpty: !dateLabel,
    formId,
    required,
    disabled,
    use24h,
    timeInterval,
    time: dateTime.time,
    setTime
  };
  return jsxs("div", {
    class: formFieldClasses(type$8, {
      errors: allErrors,
      disabled
    }),
    children: [jsxs("div", {
      class: classNames('fjs-vertical-group'),
      children: [useDatePicker && jsx(Datepicker, {
        ...datePickerProps
      }), useTimePicker && useDatePicker && jsx("div", {
        class: "fjs-datetime-separator"
      }), useTimePicker && jsx(Timepicker, {
        ...timePickerProps
      })]
    }), jsx(Description, {
      description: description
    }), jsx(Errors, {
      errors: allErrors
    })]
  });
}
Datetime.create = (options = {}) => {
  const defaults = {};
  set(defaults, DATETIME_SUBTYPE_PATH, DATETIME_SUBTYPES.DATE);
  set(defaults, DATE_LABEL_PATH, 'Date');
  return {
    ...defaults,
    ...options
  };
};
Datetime.type = type$8;
Datetime.keyed = true;
Datetime.emptyValue = null;
Datetime.sanitizeValue = sanitizeDateTimePickerValue;
Datetime.label = 'Date time';
Datetime.group = 'basic-input';

/**
 * This file must not be changed or exchanged.
 *
 * @see http://bpmn.io/license for more information.
 */
function Logo() {
  return jsxs("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 14.02 5.57",
    width: "53",
    height: "21",
    style: "vertical-align:middle",
    children: [jsx("path", {
      fill: "currentColor",
      d: "M1.88.92v.14c0 .41-.13.68-.4.8.33.14.46.44.46.86v.33c0 .61-.33.95-.95.95H0V0h.95c.65 0 .93.3.93.92zM.63.57v1.06h.24c.24 0 .38-.1.38-.43V.98c0-.28-.1-.4-.32-.4zm0 1.63v1.22h.36c.2 0 .32-.1.32-.39v-.35c0-.37-.12-.48-.4-.48H.63zM4.18.99v.52c0 .64-.31.98-.94.98h-.3V4h-.62V0h.92c.63 0 .94.35.94.99zM2.94.57v1.35h.3c.2 0 .3-.09.3-.37v-.6c0-.29-.1-.38-.3-.38h-.3zm2.89 2.27L6.25 0h.88v4h-.6V1.12L6.1 3.99h-.6l-.46-2.82v2.82h-.55V0h.87zM8.14 1.1V4h-.56V0h.79L9 2.4V0h.56v4h-.64zm2.49 2.29v.6h-.6v-.6zM12.12 1c0-.63.33-1 .95-1 .61 0 .95.37.95 1v2.04c0 .64-.34 1-.95 1-.62 0-.95-.37-.95-1zm.62 2.08c0 .28.13.39.33.39s.32-.1.32-.4V.98c0-.29-.12-.4-.32-.4s-.33.11-.33.4z"
    }), jsx("path", {
      fill: "currentColor",
      d: "M0 4.53h14.02v1.04H0zM11.08 0h.63v.62h-.63zm.63 4V1h-.63v2.98z"
    })]
  });
}
function Lightbox(props) {
  const {
    open
  } = props;
  if (!open) {
    return null;
  }
  return jsxs("div", {
    class: "fjs-powered-by-lightbox",
    style: "z-index: 100; position: fixed; top: 0; left: 0;right: 0; bottom: 0",
    children: [jsx("div", {
      class: "backdrop",
      style: "width: 100%; height: 100%; background: rgba(40 40 40 / 20%)",
      onClick: props.onBackdropClick
    }), jsxs("div", {
      class: "notice",
      style: "position: absolute; left: 50%; top: 40%; transform: translate(-50%); width: 260px; padding: 10px; background: white; box-shadow: 0  1px 4px rgba(0 0 0 / 30%); font-family: Helvetica, Arial, sans-serif; font-size: 14px; display: flex; line-height: 1.3",
      children: [jsx("a", {
        href: "https://bpmn.io",
        target: "_blank",
        rel: "noopener",
        style: "margin: 15px 20px 15px 10px; align-self: center; color: #404040",
        children: jsx(Logo, {})
      }), jsxs("span", {
        children: ["Web-based tooling for BPMN, DMN, and forms powered by ", jsx("a", {
          href: "https://bpmn.io",
          target: "_blank",
          rel: "noopener",
          children: "bpmn.io"
        }), "."]
      })]
    })]
  });
}
function Link(props) {
  return jsx("div", {
    class: "fjs-powered-by fjs-form-field",
    style: "text-align: right",
    children: jsx("a", {
      href: "https://bpmn.io",
      target: "_blank",
      rel: "noopener",
      class: "fjs-powered-by-link",
      title: "Powered by bpmn.io",
      style: "color: #404040",
      onClick: props.onClick,
      children: jsx(Logo, {})
    })
  });
}
function PoweredBy(props) {
  const [open, setOpen] = useState(false);
  function toggleOpen(open) {
    return event => {
      event.preventDefault();
      setOpen(open);
    };
  }
  return jsxs(Fragment, {
    children: [createPortal(jsx(Lightbox, {
      open: open,
      onBackdropClick: toggleOpen(false)
    }), document.body), jsx(Link, {
      onClick: toggleOpen(true)
    })]
  });
}

const noop = () => {};
function FormComponent(props) {
  const form = useService('form');
  const {
    schema
  } = form._getState();
  const {
    onSubmit = noop,
    onReset = noop,
    onChange = noop
  } = props;
  const handleSubmit = event => {
    event.preventDefault();
    onSubmit();
  };
  const handleReset = event => {
    event.preventDefault();
    onReset();
  };
  return jsxs("form", {
    class: "fjs-form",
    onSubmit: handleSubmit,
    onReset: handleReset,
    noValidate: true,
    children: [jsx(FormField, {
      field: schema,
      onChange: onChange
    }), jsx(PoweredBy, {})]
  });
}

/**
 *
 * @param {string | undefined} expression
 * @param {import('../../types').Data} data
 */
function useEvaluation(expression, data) {
  const initialData = useService('form')._getState().initialData;
  const conditionChecker = useService('conditionChecker', false);
  if (!conditionChecker) {
    return null;
  }

  // make sure we do not use data from hidden fields
  const filteredData = {
    ...initialData,
    ...conditionChecker.applyConditions(data, data)
  };
  return conditionChecker.evaluate(expression, filteredData);
}

/**
 *
 * @param {string} value
 */
function useExpressionValue(value) {
  const formData = useService('form')._getState().data;
  if (!isExpression(value)) {
    return value;
  }

  // We can ignore this hook rule as we do not use
  // state or effects in our custom hooks
  /* eslint-disable-next-line react-hooks/rules-of-hooks */
  return useEvaluation(value, formData);
}

// helper ///////////////

function isExpression(value) {
  return isString(value) && value.startsWith('=');
}

function _extends$h() { _extends$h = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$h.apply(this, arguments); }
var ImagePlaceholder = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$h({
  width: "64",
  height: "64",
  viewBox: "0 0 1280 1280",
  xmlns: "http://www.w3.org/2000/svg",
  fillRule: "evenodd",
  clipRule: "evenodd",
  strokeLinejoin: "round",
  strokeMiterlimit: "2"
}, props), /*#__PURE__*/React.createElement("path", {
  fill: "#e5e9ed",
  d: "M0 0h1280v1280H0z"
}), /*#__PURE__*/React.createElement("path", {
  d: "M910 410H370v470h540V410zm-57.333 57.333v355.334H427.333V467.333h425.334z",
  fill: "#cad3db"
}), /*#__PURE__*/React.createElement("path", {
  d: "M810 770H480v-60l100-170 130 170 100-65v125z",
  fill: "#cad3db"
}), /*#__PURE__*/React.createElement("circle", {
  cx: "750",
  cy: "550",
  r: "50",
  fill: "#cad3db",
  transform: "translate(10 10)"
})));

const type$7 = 'image';
function Image(props) {
  const {
    field
  } = props;
  const {
    alt,
    id,
    source
  } = field;
  const safeSource = safeImageSource(useExpressionValue(source));
  const altText = useExpressionValue(alt);
  const {
    formId
  } = useContext(FormContext$1);
  return jsx("div", {
    class: formFieldClasses(type$7),
    children: jsxs("div", {
      class: "fjs-image-container",
      children: [safeSource && jsx("img", {
        alt: altText,
        src: safeSource,
        class: "fjs-image",
        id: prefixId(id, formId)
      }), !safeSource && jsx("div", {
        class: "fjs-image-placeholder",
        children: jsx(ImagePlaceholder, {
          alt: "This is an image placeholder"
        })
      })]
    })
  });
}
Image.create = (options = {}) => ({
  ...options
});
Image.type = type$7;
Image.keyed = false;
Image.label = 'Image view';
Image.group = 'presentation';

function _extends$g() { _extends$g = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$g.apply(this, arguments); }
var AngelDownIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$g({
  xmlns: "http://www.w3.org/2000/svg",
  width: "8",
  height: "8"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  fill: "currentColor",
  stroke: "currentColor",
  strokeWidth: ".5",
  d: "M7.75 1.336L4 6.125.258 1.335 0 1.54l4 5.125L8 1.54zm0 0"
})));

function _extends$f() { _extends$f = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$f.apply(this, arguments); }
var AngelUpIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$f({
  xmlns: "http://www.w3.org/2000/svg",
  width: "8",
  height: "8"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  fill: "currentColor",
  stroke: "currentColor",
  strokeWidth: ".5",
  d: "M7.75 6.664L4 1.875.258 6.665 0 6.46l4-5.125L8 6.46zm0 0"
})));

const type$6 = 'number';
function Numberfield(props) {
  const {
    disabled,
    errors = [],
    field,
    value,
    onChange
  } = props;
  const {
    description,
    id,
    label,
    appearance = {},
    validate = {},
    decimalDigits,
    serializeToString = false,
    increment: incrementValue
  } = field;
  const {
    prefixAdorner,
    suffixAdorner
  } = appearance;
  const {
    required
  } = validate;
  const inputRef = useRef();
  const [stringValueCache, setStringValueCache] = useState('');

  // checks whether the value currently in the form data is practically different from the one in the input field cache
  // this allows us to guarantee the field always displays valid form data, but without auto-simplifying values like 1.000 to 1
  const cacheValueMatchesState = useMemo(() => Numberfield.sanitizeValue({
    value,
    formField: field
  }) === Numberfield.sanitizeValue({
    value: stringValueCache,
    formField: field
  }), [stringValueCache, value, field]);
  const displayValue = useMemo(() => {
    if (value === 'NaN') return 'NaN';
    if (stringValueCache === '-') return '-';
    return cacheValueMatchesState ? stringValueCache : value || value === 0 ? Big(value).toFixed() : '';
  }, [stringValueCache, value, cacheValueMatchesState]);
  const arrowIncrementValue = useMemo(() => {
    if (incrementValue) return Big(incrementValue);
    if (decimalDigits) return Big(`1e-${decimalDigits}`);
    return Big('1');
  }, [decimalDigits, incrementValue]);
  const setValue = useCallback(stringValue => {
    if (isNullEquivalentValue(stringValue)) {
      setStringValueCache('');
      onChange({
        field,
        value: null
      });
      return;
    }

    // treat commas as dots
    stringValue = stringValue.replaceAll(',', '.');
    if (stringValue === '-') {
      setStringValueCache('-');
      return;
    }
    if (isNaN(Number(stringValue))) {
      setStringValueCache('NaN');
      onChange({
        field,
        value: 'NaN'
      });
      return;
    }
    setStringValueCache(stringValue);
    onChange({
      field,
      value: serializeToString ? stringValue : Number(stringValue)
    });
  }, [field, onChange, serializeToString]);
  const increment = () => {
    const base = isValidNumber(value) ? Big(value) : Big(0);
    const stepFlooredValue = base.minus(base.mod(arrowIncrementValue));

    // note: toFixed() behaves differently in big.js
    setValue(stepFlooredValue.plus(arrowIncrementValue).toFixed());
  };
  const decrement = () => {
    const base = isValidNumber(value) ? Big(value) : Big(0);
    const offset = base.mod(arrowIncrementValue);
    if (offset.cmp(0) === 0) {
      // if we're already on a valid step, decrement
      setValue(base.minus(arrowIncrementValue).toFixed());
    } else {
      // otherwise floor to the step
      const stepFlooredValue = base.minus(base.mod(arrowIncrementValue));
      setValue(stepFlooredValue.toFixed());
    }
  };
  const onKeyDown = e => {
    // delete the NaN state all at once on backspace or delete
    if (value === 'NaN' && (e.code === 'Backspace' || e.code === 'Delete')) {
      setValue(null);
      e.preventDefault();
      return;
    }
    if (e.code === 'ArrowUp') {
      increment();
      e.preventDefault();
      return;
    }
    if (e.code === 'ArrowDown') {
      decrement();
      e.preventDefault();
      return;
    }
  };

  // intercept key presses which would lead to an invalid number
  const onKeyPress = e => {
    const caretIndex = inputRef.current.selectionStart;
    const selectionWidth = inputRef.current.selectionStart - inputRef.current.selectionEnd;
    const previousValue = inputRef.current.value;
    if (!willKeyProduceValidNumber(e.key, previousValue, caretIndex, selectionWidth, decimalDigits)) {
      e.preventDefault();
    }
  };
  const {
    formId
  } = useContext(FormContext$1);
  return jsxs("div", {
    class: formFieldClasses(type$6, {
      errors,
      disabled
    }),
    children: [jsx(Label, {
      id: prefixId(id, formId),
      label: label,
      required: required
    }), jsx(InputAdorner, {
      disabled: disabled,
      pre: prefixAdorner,
      post: suffixAdorner,
      children: jsxs("div", {
        class: classNames('fjs-vertical-group', {
          'fjs-disabled': disabled
        }, {
          'hasErrors': errors.length
        }),
        children: [jsx("input", {
          ref: inputRef,
          class: "fjs-input",
          disabled: disabled,
          id: prefixId(id, formId),
          onKeyDown: onKeyDown,
          onKeyPress: onKeyPress

          // @ts-ignore
          ,
          onInput: e => setValue(e.target.value),
          type: "text",
          autoComplete: "off",
          step: arrowIncrementValue,
          value: displayValue
        }), jsxs("div", {
          class: classNames('fjs-number-arrow-container', {
            'fjs-disabled': disabled
          }),
          children: [jsx("button", {
            class: "fjs-number-arrow-up",
            type: "button",
            "aria-label": "Increment",
            onClick: () => increment(),
            tabIndex: -1,
            children: jsx(AngelUpIcon, {})
          }), jsx("div", {
            class: "fjs-number-arrow-separator"
          }), jsx("button", {
            class: "fjs-number-arrow-down",
            type: "button",
            "aria-label": "Decrement",
            onClick: () => decrement(),
            tabIndex: -1,
            children: jsx(AngelDownIcon, {})
          })]
        })]
      })
    }), jsx(Description, {
      description: description
    }), jsx(Errors, {
      errors: errors
    })]
  });
}
Numberfield.create = (options = {}) => ({
  ...options
});
Numberfield.sanitizeValue = ({
  value,
  formField
}) => {
  // null state is allowed
  if (isNullEquivalentValue(value)) return null;

  // if data cannot be parsed as a valid number, go into invalid NaN state
  if (!isValidNumber(value)) return 'NaN';

  // otherwise parse to formatting type
  return formField.serializeToString ? value.toString() : Number(value);
};
Numberfield.type = type$6;
Numberfield.keyed = true;
Numberfield.label = 'Number';
Numberfield.emptyValue = null;
Numberfield.group = 'basic-input';

const type$5 = 'radio';
function Radio(props) {
  const {
    disabled,
    errors = [],
    field,
    value
  } = props;
  const {
    description,
    id,
    label,
    validate = {}
  } = field;
  const {
    required
  } = validate;
  const onChange = v => {
    props.onChange({
      field,
      value: v
    });
  };
  const {
    state: loadState,
    values: options
  } = useValuesAsync(field);
  const {
    formId
  } = useContext(FormContext$1);
  return jsxs("div", {
    class: formFieldClasses(type$5, {
      errors,
      disabled
    }),
    children: [jsx(Label, {
      label: label,
      required: required
    }), loadState == LOAD_STATES.LOADED && options.map((option, index) => {
      return jsx(Label, {
        id: prefixId(`${id}-${index}`, formId),
        label: option.label,
        class: classNames({
          'fjs-checked': option.value === value
        }),
        required: false,
        children: jsx("input", {
          checked: option.value === value,
          class: "fjs-input",
          disabled: disabled,
          id: prefixId(`${id}-${index}`, formId),
          type: "radio",
          onClick: () => onChange(option.value)
        })
      }, `${id}-${index}`);
    }), jsx(Description, {
      description: description
    }), jsx(Errors, {
      errors: errors
    })]
  });
}
Radio.create = function (options = {}) {
  const defaults = {};

  // provide default values if valuesKey isn't set
  if (!options.valuesKey) {
    defaults.values = [{
      label: 'Value',
      value: 'value'
    }];
  }
  return {
    ...defaults,
    ...options
  };
};
Radio.type = type$5;
Radio.label = 'Radio';
Radio.keyed = true;
Radio.emptyValue = null;
Radio.sanitizeValue = sanitizeSingleSelectValue;
Radio.group = 'selection';

function _extends$e() { _extends$e = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$e.apply(this, arguments); }
var XMarkIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$e({
  xmlns: "http://www.w3.org/2000/svg",
  width: "8",
  height: "8"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  fill: "currentColor",
  stroke: "currentColor",
  strokeWidth: ".5",
  d: "M4 3.766L7.43.336l.234.234L4.234 4l3.43 3.43-.234.234L4 4.234.57 7.664.336 7.43 3.766 4 .336.57.57.336zm0 0"
})));

function SearchableSelect(props) {
  const {
    id,
    disabled,
    errors,
    field,
    value
  } = props;
  const {
    formId
  } = useContext(FormContext$1);
  const [filter, setFilter] = useState('');
  const [isDropdownExpanded, setIsDropdownExpanded] = useState(false);
  const [shouldApplyFilter, setShouldApplyFilter] = useState(true);
  const [isEscapeClosed, setIsEscapeClose] = useState(false);
  const searchbarRef = useRef();
  const {
    state: loadState,
    values: options
  } = useValuesAsync(field);

  // We cache a map of option values to their index so that we don't need to search the whole options array every time to correlate the label
  const valueToOptionMap = useMemo(() => Object.assign({}, ...options.map((o, x) => ({
    [o.value]: options[x]
  }))), [options]);
  const valueLabel = useMemo(() => value && valueToOptionMap[value] && valueToOptionMap[value].label || '', [value, valueToOptionMap]);

  // whenever we change the underlying value, set the label to it
  useEffect(() => {
    setFilter(valueLabel);
  }, [valueLabel]);
  const filteredOptions = useMemo(() => {
    if (loadState === LOAD_STATES.LOADED) {
      return shouldApplyFilter ? options.filter(o => o.label && o.value && o.label.toLowerCase().includes(filter.toLowerCase())) : options;
    }
    return [];
  }, [filter, loadState, options, shouldApplyFilter]);
  const onChange = ({
    target
  }) => {
    setIsEscapeClose(false);
    setIsDropdownExpanded(true);
    setShouldApplyFilter(true);
    setFilter(target.value || '');
  };
  const setValue = useCallback(option => {
    setFilter(option && option.label || '');
    props.onChange({
      value: option && option.value || null,
      field
    });
  }, [field, props]);
  const onInputKeyDown = useCallback(keyDownEvent => {
    switch (keyDownEvent.key) {
      case 'ArrowUp':
        keyDownEvent.preventDefault();
        break;
      case 'ArrowDown':
        {
          if (!isDropdownExpanded) {
            setIsDropdownExpanded(true);
            setShouldApplyFilter(false);
          }
          keyDownEvent.preventDefault();
          break;
        }
      case 'Escape':
        setIsEscapeClose(true);
        break;
      case 'Enter':
        if (isEscapeClosed) {
          setIsEscapeClose(false);
        }
        break;
    }
  }, [isDropdownExpanded, isEscapeClosed]);
  const displayState = useMemo(() => {
    const ds = {};
    ds.componentReady = !disabled && loadState === LOAD_STATES.LOADED;
    ds.displayCross = ds.componentReady && value !== null && value !== undefined;
    ds.displayDropdown = !disabled && isDropdownExpanded && !isEscapeClosed;
    return ds;
  }, [disabled, isDropdownExpanded, isEscapeClosed, loadState, value]);
  const onAngelMouseDown = useCallback(e => {
    setIsEscapeClose(false);
    setIsDropdownExpanded(!isDropdownExpanded);
    const searchbar = searchbarRef.current;
    isDropdownExpanded ? searchbar.blur() : searchbar.focus();
    e.preventDefault();
  }, [isDropdownExpanded]);
  return jsxs(Fragment$1, {
    children: [jsxs("div", {
      id: prefixId(`${id}`, formId),
      class: classNames('fjs-input-group', {
        'disabled': disabled
      }, {
        'hasErrors': errors.length
      }),
      children: [jsx("input", {
        disabled: disabled,
        class: "fjs-input",
        ref: searchbarRef,
        id: prefixId(`${id}-search`, formId),
        onChange: onChange,
        type: "text",
        value: filter,
        placeholder: 'Search',
        autoComplete: "off",
        onKeyDown: e => onInputKeyDown(e),
        onMouseDown: () => {
          setIsEscapeClose(false);
          setIsDropdownExpanded(true);
          setShouldApplyFilter(false);
        },
        onFocus: () => {
          setIsDropdownExpanded(true);
          setShouldApplyFilter(false);
        },
        onBlur: () => {
          setIsDropdownExpanded(false);
          setFilter(valueLabel);
        }
      }), displayState.displayCross && jsxs("span", {
        class: "fjs-select-cross",
        onMouseDown: e => {
          setValue(null);
          e.preventDefault();
        },
        children: [jsx(XMarkIcon, {}), " "]
      }), jsx("span", {
        class: "fjs-select-arrow",
        onMouseDown: e => onAngelMouseDown(e),
        children: displayState.displayDropdown ? jsx(AngelUpIcon, {}) : jsx(AngelDownIcon, {})
      })]
    }), jsx("div", {
      class: "fjs-select-anchor",
      children: displayState.displayDropdown && jsx(DropdownList, {
        values: filteredOptions,
        getLabel: o => o.label,
        onValueSelected: o => {
          setValue(o);
          setIsDropdownExpanded(false);
        },
        listenerElement: searchbarRef.current
      })
    })]
  });
}

function SimpleSelect(props) {
  const {
    id,
    disabled,
    errors,
    field,
    value
  } = props;
  const {
    formId
  } = useContext(FormContext$1);
  const [isDropdownExpanded, setIsDropdownExpanded] = useState(false);
  const selectRef = useRef();
  const {
    state: loadState,
    values: options
  } = useValuesAsync(field);

  // We cache a map of option values to their index so that we don't need to search the whole options array every time to correlate the label
  const valueToOptionMap = useMemo(() => Object.assign({}, ...options.map((o, x) => ({
    [o.value]: options[x]
  }))), [options]);
  const valueLabel = useMemo(() => value && valueToOptionMap[value] && valueToOptionMap[value].label || '', [value, valueToOptionMap]);
  const setValue = useCallback(option => {
    props.onChange({
      value: option && option.value || null,
      field
    });
  }, [field, props]);
  const displayState = useMemo(() => {
    const ds = {};
    ds.componentReady = !disabled && loadState === LOAD_STATES.LOADED;
    ds.displayCross = ds.componentReady && value !== null && value !== undefined;
    ds.displayDropdown = !disabled && isDropdownExpanded;
    return ds;
  }, [disabled, isDropdownExpanded, loadState, value]);
  const onMouseDown = useCallback(e => {
    const select = selectRef.current;
    setIsDropdownExpanded(!isDropdownExpanded);
    if (isDropdownExpanded) {
      select.blur();
    } else {
      select.focus();
    }
    e.preventDefault();
  }, [isDropdownExpanded]);
  const initialFocusIndex = useMemo(() => value && findIndex(options, o => o.value === value) || 0, [options, value]);
  return jsxs(Fragment$1, {
    children: [jsxs("div", {
      ref: selectRef,
      id: prefixId(`${id}`, formId),
      class: classNames('fjs-input-group', {
        'disabled': disabled
      }, {
        'hasErrors': errors.length
      }),
      onFocus: () => setIsDropdownExpanded(true),
      onBlur: () => setIsDropdownExpanded(false),
      onMouseDown: e => onMouseDown(e),
      tabIndex: disabled ? undefined : 0,
      children: [jsx("div", {
        class: classNames('fjs-select-display', {
          'fjs-select-placeholder': !value
        }),
        id: prefixId(`${id}-display`, formId),
        children: valueLabel || 'Select'
      }), displayState.displayCross && jsx("span", {
        class: "fjs-select-cross",
        onMouseDown: e => {
          setValue(null);
          e.stopPropagation();
        },
        children: jsx(XMarkIcon, {})
      }), jsx("span", {
        class: "fjs-select-arrow",
        children: displayState.displayDropdown ? jsx(AngelUpIcon, {}) : jsx(AngelDownIcon, {})
      })]
    }), jsx("div", {
      class: "fjs-select-anchor",
      children: displayState.displayDropdown && jsx(DropdownList, {
        values: options,
        getLabel: o => o.label,
        initialFocusIndex: initialFocusIndex,
        onValueSelected: o => {
          setValue(o);
          setIsDropdownExpanded(false);
        },
        listenerElement: selectRef.current
      })
    })]
  });
}

const type$4 = 'select';
function Select(props) {
  const {
    disabled,
    errors = [],
    field,
    onChange,
    value
  } = props;
  const {
    description,
    id,
    label,
    searchable = false,
    validate = {}
  } = field;
  const {
    required
  } = validate;
  const {
    formId
  } = useContext(FormContext$1);
  const selectProps = useMemo(() => ({
    id,
    disabled,
    errors,
    field,
    value,
    onChange
  }), [disabled, errors, field, id, value, onChange]);
  return jsxs("div", {
    class: formFieldClasses(type$4, {
      errors,
      disabled
    }),
    children: [jsx(Label, {
      id: prefixId(id, formId),
      label: label,
      required: required
    }), searchable ? jsx(SearchableSelect, {
      ...selectProps
    }) : jsx(SimpleSelect, {
      ...selectProps
    }), jsx(Description, {
      description: description
    }), jsx(Errors, {
      errors: errors
    })]
  });
}
Select.create = (options = {}) => {
  const defaults = {};

  // provide default values if valuesKey isn't set
  if (!options.valuesKey) {
    defaults.values = [{
      label: 'Value',
      value: 'value'
    }];
  }
  return {
    ...defaults,
    ...options
  };
};
Select.type = type$4;
Select.label = 'Select';
Select.keyed = true;
Select.emptyValue = null;
Select.sanitizeValue = sanitizeSingleSelectValue;
Select.group = 'selection';

const type$3 = 'taglist';
function Taglist(props) {
  const {
    disabled,
    errors = [],
    field,
    value: values = []
  } = props;
  const {
    description,
    id,
    label
  } = field;
  const {
    formId
  } = useContext(FormContext$1);
  const [filter, setFilter] = useState('');
  const [filteredOptions, setFilteredOptions] = useState([]);
  const [isDropdownExpanded, setIsDropdownExpanded] = useState(false);
  const [hasOptionsLeft, setHasOptionsLeft] = useState(true);
  const [isEscapeClosed, setIsEscapeClose] = useState(false);
  const searchbarRef = useRef();
  const {
    state: loadState,
    values: options
  } = useValuesAsync(field);

  // We cache a map of option values to their index so that we don't need to search the whole options array every time to correlate the label
  const valueToOptionMap = useMemo(() => Object.assign({}, ...options.map((o, x) => ({
    [o.value]: options[x]
  }))), [options]);

  // Usage of stringify is necessary here because we want this effect to only trigger when there is a value change to the array
  useEffect(() => {
    if (loadState === LOAD_STATES.LOADED) {
      setFilteredOptions(options.filter(o => o.label && o.value && o.label.toLowerCase().includes(filter.toLowerCase()) && !values.includes(o.value)));
    } else {
      setFilteredOptions([]);
    }
  }, [filter, JSON.stringify(values), options, loadState]);
  useEffect(() => {
    setHasOptionsLeft(options.length > values.length);
  }, [options.length, values.length]);
  const onFilterChange = ({
    target
  }) => {
    setIsEscapeClose(false);
    setFilter(target.value);
  };
  const selectValue = value => {
    if (filter) {
      setFilter('');
    }

    // Ensure values cannot be double selected due to latency
    if (values.at(-1) === value) {
      return;
    }
    props.onChange({
      value: [...values, value],
      field
    });
  };
  const deselectValue = value => {
    props.onChange({
      value: values.filter(v => v != value),
      field
    });
  };
  const onInputKeyDown = e => {
    switch (e.key) {
      case 'ArrowUp':
      case 'ArrowDown':
        // We do not want the cursor to seek in the search field when we press up and down
        e.preventDefault();
        break;
      case 'Backspace':
        if (!filter && values.length) {
          deselectValue(values[values.length - 1]);
        }
        break;
      case 'Escape':
        setIsEscapeClose(true);
        break;
      case 'Enter':
        if (isEscapeClosed) {
          setIsEscapeClose(false);
        }
        break;
    }
  };
  const onTagRemoveClick = (event, value) => {
    const {
      target
    } = event;
    deselectValue(value);

    // restore focus if there is no next sibling to focus
    const nextTag = target.closest('.fjs-taglist-tag').nextSibling;
    if (!nextTag) {
      searchbarRef.current.focus();
    }
  };
  const shouldDisplayDropdown = useMemo(() => !disabled && loadState === LOAD_STATES.LOADED && isDropdownExpanded && !isEscapeClosed, [disabled, isDropdownExpanded, isEscapeClosed, loadState]);
  return jsxs("div", {
    class: formFieldClasses(type$3, {
      errors,
      disabled
    }),
    children: [jsx(Label, {
      label: label,
      id: prefixId(`${id}-search`, formId)
    }), jsxs("div", {
      class: classNames('fjs-taglist', {
        'fjs-disabled': disabled
      }),
      children: [loadState === LOAD_STATES.LOADED && jsx("div", {
        class: "fjs-taglist-tags",
        children: values.map(v => {
          return jsxs("div", {
            class: classNames('fjs-taglist-tag', {
              'fjs-disabled': disabled
            }),
            onMouseDown: e => e.preventDefault(),
            children: [jsx("span", {
              class: "fjs-taglist-tag-label",
              children: valueToOptionMap[v] ? valueToOptionMap[v].label : `unexpected value{${v}}`
            }), !disabled && jsx("button", {
              type: "button",
              title: "Remove tag",
              class: "fjs-taglist-tag-remove",
              onClick: event => onTagRemoveClick(event, v),
              children: jsx(XMarkIcon, {})
            })]
          });
        })
      }), jsx("input", {
        disabled: disabled,
        class: "fjs-taglist-input",
        ref: searchbarRef,
        id: prefixId(`${id}-search`, formId),
        onChange: onFilterChange,
        type: "text",
        value: filter,
        placeholder: disabled ? '' : 'Search',
        autoComplete: "off",
        onKeyDown: e => onInputKeyDown(e),
        onMouseDown: () => setIsEscapeClose(false),
        onFocus: () => setIsDropdownExpanded(true),
        onBlur: () => {
          setIsDropdownExpanded(false);
          setFilter('');
        }
      })]
    }), jsx("div", {
      class: "fjs-taglist-anchor",
      children: shouldDisplayDropdown && jsx(DropdownList, {
        values: filteredOptions,
        getLabel: o => o.label,
        onValueSelected: o => selectValue(o.value),
        emptyListMessage: hasOptionsLeft ? 'No results' : 'All values selected',
        listenerElement: searchbarRef.current
      })
    }), jsx(Description, {
      description: description
    }), jsx(Errors, {
      errors: errors
    })]
  });
}
Taglist.create = (options = {}) => {
  const defaults = {};

  // provide default values if valuesKey isn't set
  if (!options.valuesKey) {
    defaults.values = [{
      label: 'Value',
      value: 'value'
    }];
  }
  return {
    ...defaults,
    ...options
  };
};
Taglist.type = type$3;
Taglist.label = 'Tag list';
Taglist.keyed = true;
Taglist.emptyValue = [];
Taglist.sanitizeValue = sanitizeMultiSelectValue;
Taglist.group = 'selection';

const type$2 = 'text';
function Text(props) {
  const {
    field,
    disableLinks
  } = props;
  const {
    text = ''
  } = field;
  const textValue = useExpressionValue(text) || '';
  const componentOverrides = disableLinks ? {
    'a': DisabledLink
  } : {};
  return jsx("div", {
    class: formFieldClasses(type$2),
    children: jsx(Markup, {
      markup: safeMarkdown(textValue),
      components: componentOverrides,
      trim: false
    })
  });
}
Text.create = (options = {}) => ({
  text: '# Text',
  ...options
});
Text.type = type$2;
Text.keyed = false;
Text.group = 'presentation';
Text.label = 'Text view';
function DisabledLink({
  href,
  children
}) {
  return jsx("a", {
    class: "fjs-disabled-link",
    href: href,
    tabIndex: -1,
    children: children
  });
}

const type$1 = 'textfield';
function Textfield(props) {
  const {
    disabled,
    errors = [],
    field,
    value = ''
  } = props;
  const {
    description,
    id,
    label,
    appearance = {},
    validate = {}
  } = field;
  const {
    prefixAdorner,
    suffixAdorner
  } = appearance;
  const {
    required
  } = validate;
  const onChange = ({
    target
  }) => {
    props.onChange({
      field,
      value: target.value
    });
  };
  const {
    formId
  } = useContext(FormContext$1);
  return jsxs("div", {
    class: formFieldClasses(type$1, {
      errors,
      disabled
    }),
    children: [jsx(Label, {
      id: prefixId(id, formId),
      label: label,
      required: required
    }), jsx(InputAdorner, {
      disabled: disabled,
      pre: prefixAdorner,
      post: suffixAdorner,
      children: jsx("input", {
        class: "fjs-input",
        disabled: disabled,
        id: prefixId(id, formId),
        onInput: onChange,
        type: "text",
        value: value
      })
    }), jsx(Description, {
      description: description
    }), jsx(Errors, {
      errors: errors
    })]
  });
}
Textfield.create = (options = {}) => ({
  ...options
});
Textfield.type = type$1;
Textfield.label = 'Text field';
Textfield.keyed = true;
Textfield.emptyValue = '';
Textfield.sanitizeValue = ({
  value
}) => isArray(value) || isObject(value) ? '' : String(value);
Textfield.group = 'basic-input';

const type = 'textarea';
function Textarea(props) {
  const {
    disabled,
    errors = [],
    field,
    value = ''
  } = props;
  const {
    description,
    id,
    label,
    validate = {}
  } = field;
  const {
    required
  } = validate;
  const textareaRef = useRef();
  const onInput = ({
    target
  }) => {
    props.onChange({
      field,
      value: target.value
    });
  };
  const autoSizeTextarea = useCallback(textarea => {
    // Ensures the textarea shrinks back, and improves resizing behavior consistency
    textarea.style.height = '0px';
    const computed = window.getComputedStyle(textarea);
    const calculatedHeight = parseInt(computed.getPropertyValue('border-top-width')) + parseInt(computed.getPropertyValue('padding-top')) + textarea.scrollHeight + parseInt(computed.getPropertyValue('padding-bottom')) + parseInt(computed.getPropertyValue('border-bottom-width'));
    const minHeight = 75;
    const maxHeight = 350;
    const displayHeight = Math.max(Math.min(calculatedHeight, maxHeight), minHeight);
    textarea.style.height = `${displayHeight}px`;

    // Overflow is hidden by default to hide scrollbar flickering
    textarea.style.overflow = calculatedHeight > maxHeight ? 'visible' : 'hidden';
  }, []);
  useEffect(() => {
    autoSizeTextarea(textareaRef.current);
  }, [autoSizeTextarea, value]);
  const {
    formId
  } = useContext(FormContext$1);
  return jsxs("div", {
    class: formFieldClasses(type, {
      errors,
      disabled
    }),
    children: [jsx(Label, {
      id: prefixId(id, formId),
      label: label,
      required: required
    }), jsx("textarea", {
      class: "fjs-textarea",
      disabled: disabled,
      id: prefixId(id, formId),
      onInput: onInput,
      value: value,
      ref: textareaRef
    }), jsx(Description, {
      description: description
    }), jsx(Errors, {
      errors: errors
    })]
  });
}
Textarea.create = (options = {}) => ({
  ...options
});
Textarea.type = type;
Textarea.label = 'Text area';
Textarea.keyed = true;
Textarea.emptyValue = '';
Textarea.sanitizeValue = ({
  value
}) => isArray(value) || isObject(value) ? '' : String(value);
Textarea.group = 'basic-input';

function _extends$d() { _extends$d = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$d.apply(this, arguments); }
var ButtonIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$d({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  d: "M45 17a3 3 0 013 3v14a3 3 0 01-3 3H9a3 3 0 01-3-3V20a3 3 0 013-3h36zm-9 8.889H18v2.222h18V25.89z"
})));

function _extends$c() { _extends$c = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$c.apply(this, arguments); }
var CheckboxIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$c({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  d: "M34 18H20a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2V20a2 2 0 00-2-2zm-9 14l-5-5 1.41-1.41L25 29.17l7.59-7.59L34 23l-9 9z"
})));

function _extends$b() { _extends$b = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$b.apply(this, arguments); }
var ChecklistIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$b({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54",
  fill: "none"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M18 12h-6v6h6v-6zm-6-2a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2v-6a2 2 0 00-2-2h-6zM18 36h-6v6h6v-6zm-6-2a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2v-6a2 2 0 00-2-2h-6zM18 24h-6v6h6v-6zm-6-2a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2v-6a2 2 0 00-2-2h-6z",
  fill: "#161616"
}), /*#__PURE__*/React.createElement("path", {
  d: "M23 14.5a1 1 0 011-1h19a1 1 0 011 1v1a1 1 0 01-1 1H24a1 1 0 01-1-1v-1zM23 26.5a1 1 0 011-1h19a1 1 0 011 1v1a1 1 0 01-1 1H24a1 1 0 01-1-1v-1zM23 38.5a1 1 0 011-1h19a1 1 0 011 1v1a1 1 0 01-1 1H24a1 1 0 01-1-1v-1z",
  fill: "#161616"
})));

function _extends$a() { _extends$a = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$a.apply(this, arguments); }
var DatetimeIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$a({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54",
  fill: "none"
}, props), /*#__PURE__*/React.createElement("path", {
  fill: "#000",
  fillRule: "evenodd",
  d: "M37.908 13.418h-5.004v-2.354h-1.766v2.354H21.13v-2.354h-1.766v2.354H14.36c-1.132 0-2.06.928-2.06 2.06v23.549c0 1.132.928 2.06 2.06 2.06h6.77v-1.766h-6.358a.707.707 0 01-.706-.706V15.89c0-.39.316-.707.706-.707h4.592v2.355h1.766v-2.355h10.008v2.355h1.766v-2.355h4.592c.39 0 .707.317.707.707v6.358h1.765v-6.77c0-1.133-.927-2.06-2.06-2.06z",
  clipRule: "evenodd"
}), /*#__PURE__*/React.createElement("path", {
  fill: "#000",
  d: "M35.13 37.603l1.237-1.237-3.468-3.475v-5.926h-1.754v6.654l3.984 3.984z"
}), /*#__PURE__*/React.createElement("path", {
  fill: "#000",
  fillRule: "evenodd",
  d: "M23.08 36.962a9.678 9.678 0 1017.883-7.408 9.678 9.678 0 00-17.882 7.408zm4.54-10.292a7.924 7.924 0 118.805 13.177A7.924 7.924 0 0127.62 26.67z",
  clipRule: "evenodd"
})));

function _extends$9() { _extends$9 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$9.apply(this, arguments); }
var TaglistIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$9({
  width: "54",
  height: "54",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M45 16a3 3 0 013 3v16a3 3 0 01-3 3H9a3 3 0 01-3-3V19a3 3 0 013-3h36zm0 2H9a1 1 0 00-1 1v16a1 1 0 001 1h36a1 1 0 001-1V19a1 1 0 00-1-1z",
  fill: "#000"
}), /*#__PURE__*/React.createElement("path", {
  d: "M11 22a1 1 0 011-1h19a1 1 0 011 1v10a1 1 0 01-1 1H12a1 1 0 01-1-1V22z",
  fill: "#505562"
})));

function _extends$8() { _extends$8 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$8.apply(this, arguments); }
var FormIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$8({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("rect", {
  x: "15",
  y: "17",
  width: "24",
  height: "4",
  rx: "1"
}), /*#__PURE__*/React.createElement("rect", {
  x: "15",
  y: "25",
  width: "24",
  height: "4",
  rx: "1"
}), /*#__PURE__*/React.createElement("rect", {
  x: "15",
  y: "33",
  width: "13",
  height: "4",
  rx: "1"
})));

function _extends$7() { _extends$7 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$7.apply(this, arguments); }
var ColumnsIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$7({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  d: "M8 33v5a1 1 0 001 1h4v2H9a3 3 0 01-3-3v-5h2zm18 6v2H15v-2h11zm13 0v2H28v-2h11zm9-6v5a3 3 0 01-3 3h-4v-2h4a1 1 0 00.993-.883L46 38v-5h2zM8 22v9H6v-9h2zm40 0v9h-2v-9h2zm-35-9v2H9a1 1 0 00-.993.883L8 16v4H6v-4a3 3 0 013-3h4zm32 0a3 3 0 013 3v4h-2v-4a1 1 0 00-.883-.993L45 15h-4v-2h4zm-6 0v2H28v-2h11zm-13 0v2H15v-2h11z"
})));

function _extends$6() { _extends$6 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$6.apply(this, arguments); }
var NumberIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$6({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  d: "M45 16a3 3 0 013 3v16a3 3 0 01-3 3H9a3 3 0 01-3-3V19a3 3 0 013-3h36zm0 2H9a1 1 0 00-1 1v16a1 1 0 001 1h36a1 1 0 001-1V19a1 1 0 00-1-1zM35 28.444h7l-3.5 4-3.5-4zM35 26h7l-3.5-4-3.5 4z"
})));

function _extends$5() { _extends$5 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$5.apply(this, arguments); }
var RadioIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$5({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  d: "M27 22c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0-5c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
})));

function _extends$4() { _extends$4 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$4.apply(this, arguments); }
var SelectIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$4({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  d: "M45 16a3 3 0 013 3v16a3 3 0 01-3 3H9a3 3 0 01-3-3V19a3 3 0 013-3h36zm0 2H9a1 1 0 00-1 1v16a1 1 0 001 1h36a1 1 0 001-1V19a1 1 0 00-1-1zm-12 7h9l-4.5 6-4.5-6z"
})));

function _extends$3() { _extends$3 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }
var TextIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$3({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  d: "M20.58 33.77h-3l-1.18-3.08H11l-1.1 3.08H7l5.27-13.54h2.89zm-5-5.36l-1.86-5-1.83 5zM22 20.23h5.41a15.47 15.47 0 012.4.14 3.42 3.42 0 011.41.55 3.47 3.47 0 011 1.14 3 3 0 01.42 1.58 3.26 3.26 0 01-1.91 2.94 3.63 3.63 0 011.91 1.22 3.28 3.28 0 01.66 2 4 4 0 01-.43 1.8 3.63 3.63 0 01-1.09 1.4 3.89 3.89 0 01-1.83.65q-.69.07-3.3.09H22zm2.73 2.25v3.13h3.8a1.79 1.79 0 001.1-.49 1.41 1.41 0 00.41-1 1.49 1.49 0 00-.35-1 1.54 1.54 0 00-1-.48c-.27 0-1.05-.05-2.34-.05zm0 5.39v3.62h2.57a11.52 11.52 0 001.88-.09 1.65 1.65 0 001-.54 1.6 1.6 0 00.38-1.14 1.75 1.75 0 00-.29-1 1.69 1.69 0 00-.86-.62 9.28 9.28 0 00-2.41-.23zM44.35 28.79l2.65.84a5.94 5.94 0 01-2 3.29A5.74 5.74 0 0141.38 34a5.87 5.87 0 01-4.44-1.84 7.09 7.09 0 01-1.73-5A7.43 7.43 0 0137 21.87 6 6 0 0141.54 20a5.64 5.64 0 014 1.47A5.33 5.33 0 0147 24l-2.7.65a2.8 2.8 0 00-2.86-2.27A3.09 3.09 0 0039 23.42a5.31 5.31 0 00-.93 3.5 5.62 5.62 0 00.93 3.65 3 3 0 002.4 1.09 2.72 2.72 0 001.82-.66 4 4 0 001.13-2.21z"
})));

function _extends$2() { _extends$2 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }
var TextfieldIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$2({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  d: "M45 16a3 3 0 013 3v16a3 3 0 01-3 3H9a3 3 0 01-3-3V19a3 3 0 013-3h36zm0 2H9a1 1 0 00-1 1v16a1 1 0 001 1h36a1 1 0 001-1V19a1 1 0 00-1-1zm-32 4v10h-2V22h2z"
})));

function _extends$1() { _extends$1 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }
var TextareaIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$1({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  d: "M45 13a3 3 0 013 3v22a3 3 0 01-3 3H9a3 3 0 01-3-3V16a3 3 0 013-3h36zm0 2H9a1 1 0 00-1 1v22a1 1 0 001 1h36a1 1 0 001-1V16a1 1 0 00-1-1zm-1.136 15.5l.848.849-6.363 6.363-.849-.848 6.364-6.364zm.264 3.5l.849.849-2.828 2.828-.849-.849L44.128 34zM13 19v10h-2V19h2z"
})));

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var ImageIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends({
  width: "54",
  height: "54",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M34.636 21.91A3.818 3.818 0 1127 21.908a3.818 3.818 0 017.636 0zm-2 0A1.818 1.818 0 1129 21.908a1.818 1.818 0 013.636 0z",
  fill: "#000"
}), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M15 13a2 2 0 00-2 2v24a2 2 0 002 2h24a2 2 0 002-2V15a2 2 0 00-2-2H15zm24 2H15v12.45l4.71-4.709a1.91 1.91 0 012.702 0l6.695 6.695 2.656-1.77a1.91 1.91 0 012.411.239L39 32.73V15zM15 39v-8.754c.06-.038.116-.083.168-.135l5.893-5.893 6.684 6.685a1.911 1.911 0 002.41.238l2.657-1.77 6.02 6.02c.052.051.108.097.168.135V39H15z",
  fill: "#000"
})));

const iconsByType = type => {
  return {
    button: ButtonIcon,
    checkbox: CheckboxIcon,
    checklist: ChecklistIcon,
    columns: ColumnsIcon,
    datetime: DatetimeIcon,
    image: ImageIcon,
    number: NumberIcon,
    radio: RadioIcon,
    select: SelectIcon,
    taglist: TaglistIcon,
    text: TextIcon,
    textfield: TextfieldIcon,
    textarea: TextareaIcon,
    default: FormIcon
  }[type];
};

const formFields = [Button, Checkbox, Checklist, Default, Image, Numberfield, Datetime, Radio, Select, Taglist, Text, Textfield, Textarea];

class FormFields {
  constructor() {
    this._formFields = {};
    formFields.forEach(formField => {
      this.register(formField.type, formField);
    });
  }
  register(type, formField) {
    this._formFields[type] = formField;
  }
  get(type) {
    return this._formFields[type];
  }
}

function Renderer(config, eventBus, form, injector) {
  const App = () => {
    const [state, setState] = useState(form._getState());
    const formContext = {
      getService(type, strict = true) {
        return injector.get(type, strict);
      },
      formId: form._id
    };
    eventBus.on('changed', newState => {
      setState(newState);
    });
    const onChange = useCallback(update => form._update(update), [form]);
    const {
      properties
    } = state;
    const {
      readOnly
    } = properties;
    const onSubmit = useCallback(() => {
      if (!readOnly) {
        form.submit();
      }
    }, [form, readOnly]);
    const onReset = useCallback(() => form.reset(), [form]);
    const {
      schema
    } = state;
    if (!schema) {
      return null;
    }
    return jsx(FormContext$1.Provider, {
      value: formContext,
      children: jsx(FormComponent, {
        onChange: onChange,
        onSubmit: onSubmit,
        onReset: onReset
      })
    });
  };
  const {
    container
  } = config;
  eventBus.on('form.init', () => {
    render(jsx(App, {}), container);
  });
  eventBus.on('form.destroy', () => {
    render(null, container);
  });
}
Renderer.$inject = ['config.renderer', 'eventBus', 'form', 'injector'];

var renderModule = {
  __init__: ['formFields', 'renderer'],
  formFields: ['type', FormFields],
  renderer: ['type', Renderer]
};

var core = {
  __depends__: [importModule, renderModule],
  conditionChecker: ['type', ConditionChecker],
  eventBus: ['type', EventBus],
  formFieldRegistry: ['type', FormFieldRegistry],
  validator: ['type', Validator]
};

/**
 * @typedef { import('./types').Injector } Injector
 * @typedef { import('./types').Data } Data
 * @typedef { import('./types').Errors } Errors
 * @typedef { import('./types').Schema } Schema
 * @typedef { import('./types').FormProperties } FormProperties
 * @typedef { import('./types').FormProperty } FormProperty
 * @typedef { import('./types').FormEvent } FormEvent
 * @typedef { import('./types').FormOptions } FormOptions
 *
 * @typedef { {
 *   data: Data,
 *   initialData: Data,
 *   errors: Errors,
 *   properties: FormProperties,
 *   schema: Schema
 * } } State
 *
 * @typedef { (type:FormEvent, priority:number, handler:Function) => void } OnEventWithPriority
 * @typedef { (type:FormEvent, handler:Function) => void } OnEventWithOutPriority
 * @typedef { OnEventWithPriority & OnEventWithOutPriority } OnEventType
 */

const ids = new Ids([32, 36, 1]);

/**
 * The form.
 */
class Form {
  /**
   * @constructor
   * @param {FormOptions} options
   */
  constructor(options = {}) {
    /**
     * @public
     * @type {OnEventType}
     */
    this.on = this._onEvent;

    /**
     * @public
     * @type {String}
     */
    this._id = ids.next();

    /**
     * @private
     * @type {Element}
     */
    this._container = createFormContainer();
    const {
      container,
      injector = this._createInjector(options, this._container),
      properties = {}
    } = options;

    /**
     * @private
     * @type {State}
     */
    this._state = {
      initialData: null,
      data: null,
      properties,
      errors: {},
      schema: null
    };
    this.get = injector.get;
    this.invoke = injector.invoke;
    this.get('eventBus').fire('form.init');
    if (container) {
      this.attachTo(container);
    }
  }
  clear() {
    // clear form services
    this._emit('diagram.clear');

    // clear diagram services (e.g. EventBus)
    this._emit('form.clear');
  }

  /**
   * Destroy the form, removing it from DOM,
   * if attached.
   */
  destroy() {
    // destroy form services
    this.get('eventBus').fire('form.destroy');

    // destroy diagram services (e.g. EventBus)
    this.get('eventBus').fire('diagram.destroy');
    this._detach(false);
  }

  /**
   * Open a form schema with the given initial data.
   *
   * @param {Schema} schema
   * @param {Data} [data]
   *
   * @return Promise<{ warnings: Array<any> }>
   */
  importSchema(schema, data = {}) {
    return new Promise((resolve, reject) => {
      try {
        this.clear();
        const {
          schema: importedSchema,
          data: initializedData,
          warnings
        } = this.get('importer').importSchema(schema, data);
        this._setState({
          data: initializedData,
          errors: {},
          schema: importedSchema,
          initialData: clone(initializedData)
        });
        this._emit('import.done', {
          warnings
        });
        return resolve({
          warnings
        });
      } catch (error) {
        this._emit('import.done', {
          error,
          warnings: error.warnings || []
        });
        return reject(error);
      }
    });
  }

  /**
   * Submit the form, triggering all field validations.
   *
   * @returns { { data: Data, errors: Errors } }
   */
  submit() {
    const {
      properties
    } = this._getState();
    if (properties.readOnly) {
      throw new Error('form is read-only');
    }
    const data = this._getSubmitData();
    const errors = this.validate();
    const filteredErrors = this._applyConditions(errors, data);
    const result = {
      data,
      errors: filteredErrors
    };
    this._emit('submit', result);
    return result;
  }
  reset() {
    this._emit('reset');
    this._setState({
      data: clone(this._state.initialData),
      errors: {}
    });
  }

  /**
   * @returns {Errors}
   */
  validate() {
    const formFieldRegistry = this.get('formFieldRegistry'),
      validator = this.get('validator');
    const {
      data
    } = this._getState();
    const errors = formFieldRegistry.getAll().reduce((errors, field) => {
      const {
        disabled,
        _path
      } = field;
      if (disabled) {
        return errors;
      }
      const value = get(data, _path);
      const fieldErrors = validator.validateField(field, value);
      return set(errors, [pathStringify(_path)], fieldErrors.length ? fieldErrors : undefined);
    }, /** @type {Errors} */{});
    this._setState({
      errors
    });
    return errors;
  }

  /**
   * @param {Element|string} parentNode
   */
  attachTo(parentNode) {
    if (!parentNode) {
      throw new Error('parentNode required');
    }
    this.detach();
    if (isString(parentNode)) {
      parentNode = document.querySelector(parentNode);
    }
    const container = this._container;
    parentNode.appendChild(container);
    this._emit('attach');
  }
  detach() {
    this._detach();
  }

  /**
   * @private
   *
   * @param {boolean} [emit]
   */
  _detach(emit = true) {
    const container = this._container,
      parentNode = container.parentNode;
    if (!parentNode) {
      return;
    }
    if (emit) {
      this._emit('detach');
    }
    parentNode.removeChild(container);
  }

  /**
   * @param {FormProperty} property
   * @param {any} value
   */
  setProperty(property, value) {
    const properties = set(this._getState().properties, [property], value);
    this._setState({
      properties
    });
  }

  /**
   * @param {FormEvent} type
   * @param {Function} handler
   */
  off(type, handler) {
    this.get('eventBus').off(type, handler);
  }

  /**
   * @private
   *
   * @param {FormOptions} options
   * @param {Element} container
   *
   * @returns {Injector}
   */
  _createInjector(options, container) {
    const {
      additionalModules = [],
      modules = []
    } = options;
    const config = {
      renderer: {
        container
      }
    };
    return createInjector([{
      config: ['value', config]
    }, {
      form: ['value', this]
    }, core, ...modules, ...additionalModules]);
  }

  /**
   * @private
   */
  _emit(type, data) {
    this.get('eventBus').fire(type, data);
  }

  /**
   * @internal
   *
   * @param { { add?: boolean, field: any, remove?: number, value?: any } } update
   */
  _update(update) {
    const {
      field,
      value
    } = update;
    const {
      _path
    } = field;
    let {
      data,
      errors
    } = this._getState();
    const validator = this.get('validator');
    const fieldErrors = validator.validateField(field, value);
    set(data, _path, value);
    set(errors, [pathStringify(_path)], fieldErrors.length ? fieldErrors : undefined);
    this._setState({
      data: clone(data),
      errors: clone(errors)
    });
  }

  /**
   * @internal
   */
  _getState() {
    return this._state;
  }

  /**
   * @internal
   */
  _setState(state) {
    this._state = {
      ...this._state,
      ...state
    };
    this._emit('changed', this._getState());
  }

  /**
   * @internal
   */
  _onEvent(type, priority, handler) {
    this.get('eventBus').on(type, priority, handler);
  }

  /**
   * @internal
   */
  _getSubmitData() {
    const formFieldRegistry = this.get('formFieldRegistry');
    const formData = this._getState().data;
    const submitData = formFieldRegistry.getAll().reduce((previous, field) => {
      const {
        disabled,
        _path
      } = field;

      // do not submit disabled form fields
      if (disabled || !_path) {
        return previous;
      }
      const value = get(formData, _path);
      return {
        ...previous,
        [_path[0]]: value
      };
    }, {});
    const filteredSubmitData = this._applyConditions(submitData, formData);
    return filteredSubmitData;
  }

  /**
   * @internal
   */
  _applyConditions(toFilter, data) {
    const conditionChecker = this.get('conditionChecker');
    return conditionChecker.applyConditions(toFilter, data);
  }
}

const schemaVersion = 7;

/**
 * @typedef { import('./types').CreateFormOptions } CreateFormOptions
 */

/**
 * Create a form.
 *
 * @param {CreateFormOptions} options
 *
 * @return {Promise<Form>}
 */
function createForm(options) {
  const {
    data,
    schema,
    ...rest
  } = options;
  const form = new Form(rest);
  return form.importSchema(schema, data).then(function () {
    return form;
  });
}

export { Button, Checkbox, Checklist, DATETIME_SUBTYPES, DATETIME_SUBTYPES_LABELS, DATETIME_SUBTYPE_PATH, DATE_DISALLOW_PAST_PATH, DATE_LABEL_PATH, Datetime, Default, Form, FormComponent, FormContext$1 as FormContext, FormFieldRegistry, FormFields, FormRenderContext$1 as FormRenderContext, Image, MINUTES_IN_DAY, Numberfield, Radio, Select, TIME_INTERVAL_PATH, TIME_LABEL_PATH, TIME_SERIALISINGFORMAT_LABELS, TIME_SERIALISING_FORMATS, TIME_SERIALISING_FORMAT_PATH, TIME_USE24H_PATH, Taglist, Text, Textarea, Textfield, VALUES_SOURCES, VALUES_SOURCES_DEFAULTS, VALUES_SOURCES_LABELS, VALUES_SOURCES_PATHS, VALUES_SOURCE_DEFAULT, clone, createForm, createFormContainer, createInjector, findErrors, formFields, generateIdForType, generateIndexForType, getExpressionVariableNames, getSchemaVariables, getValuesSource, getVariableNames, iconsByType, isExpression$1 as isExpression, isRequired, pathParse, pathStringify, pathsEqual, schemaVersion };
//# sourceMappingURL=index.es.js.map
