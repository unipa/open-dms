'use strict';

var formJsViewer = require('@bpmn-io/form-js-viewer');
var Ids = require('ids');
var minDash = require('min-dash');
var classnames = require('classnames');
var jsxRuntime = require('preact/jsx-runtime');
var preact = require('preact');
var hooks$1 = require('preact/hooks');
var dragula = require('dragula');
var React = require('preact/compat');
var minDom = require('min-dom');
var arrayMove = require('array-move');
var FeelEditor = require('@bpmn-io/feel-editor');
var Big = require('big.js');

var FN_REF = '__fn';
var DEFAULT_PRIORITY$2 = 1000;
var slice = Array.prototype.slice;

/**
 * A general purpose event bus.
 *
 * This component is used to communicate across a diagram instance.
 * Other parts of a diagram can use it to listen to and broadcast events.
 *
 *
 * ## Registering for Events
 *
 * The event bus provides the {@link EventBus#on} and {@link EventBus#once}
 * methods to register for events. {@link EventBus#off} can be used to
 * remove event registrations. Listeners receive an instance of {@link Event}
 * as the first argument. It allows them to hook into the event execution.
 *
 * ```javascript
 *
 * // listen for event
 * eventBus.on('foo', function(event) {
 *
 *   // access event type
 *   event.type; // 'foo'
 *
 *   // stop propagation to other listeners
 *   event.stopPropagation();
 *
 *   // prevent event default
 *   event.preventDefault();
 * });
 *
 * // listen for event with custom payload
 * eventBus.on('bar', function(event, payload) {
 *   console.log(payload);
 * });
 *
 * // listen for event returning value
 * eventBus.on('foobar', function(event) {
 *
 *   // stop event propagation + prevent default
 *   return false;
 *
 *   // stop event propagation + return custom result
 *   return {
 *     complex: 'listening result'
 *   };
 * });
 *
 *
 * // listen with custom priority (default=1000, higher is better)
 * eventBus.on('priorityfoo', 1500, function(event) {
 *   console.log('invoked first!');
 * });
 *
 *
 * // listen for event and pass the context (`this`)
 * eventBus.on('foobar', function(event) {
 *   this.foo();
 * }, this);
 * ```
 *
 *
 * ## Emitting Events
 *
 * Events can be emitted via the event bus using {@link EventBus#fire}.
 *
 * ```javascript
 *
 * // false indicates that the default action
 * // was prevented by listeners
 * if (eventBus.fire('foo') === false) {
 *   console.log('default has been prevented!');
 * };
 *
 *
 * // custom args + return value listener
 * eventBus.on('sum', function(event, a, b) {
 *   return a + b;
 * });
 *
 * // you can pass custom arguments + retrieve result values.
 * var sum = eventBus.fire('sum', 1, 2);
 * console.log(sum); // 3
 * ```
 */
function EventBus() {
  this._listeners = {};

  // cleanup on destroy on lowest priority to allow
  // message passing until the bitter end
  this.on('diagram.destroy', 1, this._destroy, this);
}

/**
 * Register an event listener for events with the given name.
 *
 * The callback will be invoked with `event, ...additionalArguments`
 * that have been passed to {@link EventBus#fire}.
 *
 * Returning false from a listener will prevent the events default action
 * (if any is specified). To stop an event from being processed further in
 * other listeners execute {@link Event#stopPropagation}.
 *
 * Returning anything but `undefined` from a listener will stop the listener propagation.
 *
 * @param {string|Array<string>} events
 * @param {number} [priority=1000] the priority in which this listener is called, larger is higher
 * @param {Function} callback
 * @param {Object} [that] Pass context (`this`) to the callback
 */
EventBus.prototype.on = function (events, priority, callback, that) {
  events = minDash.isArray(events) ? events : [events];
  if (minDash.isFunction(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY$2;
  }
  if (!minDash.isNumber(priority)) {
    throw new Error('priority must be a number');
  }
  var actualCallback = callback;
  if (that) {
    actualCallback = minDash.bind(callback, that);

    // make sure we remember and are able to remove
    // bound callbacks via {@link #off} using the original
    // callback
    actualCallback[FN_REF] = callback[FN_REF] || callback;
  }
  var self = this;
  events.forEach(function (e) {
    self._addListener(e, {
      priority: priority,
      callback: actualCallback,
      next: null
    });
  });
};

/**
 * Register an event listener that is executed only once.
 *
 * @param {string} event the event name to register for
 * @param {number} [priority=1000] the priority in which this listener is called, larger is higher
 * @param {Function} callback the callback to execute
 * @param {Object} [that] Pass context (`this`) to the callback
 */
EventBus.prototype.once = function (event, priority, callback, that) {
  var self = this;
  if (minDash.isFunction(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY$2;
  }
  if (!minDash.isNumber(priority)) {
    throw new Error('priority must be a number');
  }
  function wrappedCallback() {
    wrappedCallback.__isTomb = true;
    var result = callback.apply(that, arguments);
    self.off(event, wrappedCallback);
    return result;
  }

  // make sure we remember and are able to remove
  // bound callbacks via {@link #off} using the original
  // callback
  wrappedCallback[FN_REF] = callback;
  this.on(event, priority, wrappedCallback);
};

/**
 * Removes event listeners by event and callback.
 *
 * If no callback is given, all listeners for a given event name are being removed.
 *
 * @param {string|Array<string>} events
 * @param {Function} [callback]
 */
EventBus.prototype.off = function (events, callback) {
  events = minDash.isArray(events) ? events : [events];
  var self = this;
  events.forEach(function (event) {
    self._removeListener(event, callback);
  });
};

/**
 * Create an EventBus event.
 *
 * @param {Object} data
 *
 * @return {Object} event, recognized by the eventBus
 */
EventBus.prototype.createEvent = function (data) {
  var event = new InternalEvent();
  event.init(data);
  return event;
};

/**
 * Fires a named event.
 *
 * @example
 *
 * // fire event by name
 * events.fire('foo');
 *
 * // fire event object with nested type
 * var event = { type: 'foo' };
 * events.fire(event);
 *
 * // fire event with explicit type
 * var event = { x: 10, y: 20 };
 * events.fire('element.moved', event);
 *
 * // pass additional arguments to the event
 * events.on('foo', function(event, bar) {
 *   alert(bar);
 * });
 *
 * events.fire({ type: 'foo' }, 'I am bar!');
 *
 * @param {string} [name] the optional event name
 * @param {Object} [event] the event object
 * @param {...Object} additional arguments to be passed to the callback functions
 *
 * @return {boolean} the events return value, if specified or false if the
 *                   default action was prevented by listeners
 */
EventBus.prototype.fire = function (type, data) {
  var event, firstListener, returnValue, args;
  args = slice.call(arguments);
  if (typeof type === 'object') {
    data = type;
    type = data.type;
  }
  if (!type) {
    throw new Error('no event type specified');
  }
  firstListener = this._listeners[type];
  if (!firstListener) {
    return;
  }

  // we make sure we fire instances of our home made
  // events here. We wrap them only once, though
  if (data instanceof InternalEvent) {
    // we are fine, we alread have an event
    event = data;
  } else {
    event = this.createEvent(data);
  }

  // ensure we pass the event as the first parameter
  args[0] = event;

  // original event type (in case we delegate)
  var originalType = event.type;

  // update event type before delegation
  if (type !== originalType) {
    event.type = type;
  }
  try {
    returnValue = this._invokeListeners(event, args, firstListener);
  } finally {
    // reset event type after delegation
    if (type !== originalType) {
      event.type = originalType;
    }
  }

  // set the return value to false if the event default
  // got prevented and no other return value exists
  if (returnValue === undefined && event.defaultPrevented) {
    returnValue = false;
  }
  return returnValue;
};
EventBus.prototype.handleError = function (error) {
  return this.fire('error', {
    error: error
  }) === false;
};
EventBus.prototype._destroy = function () {
  this._listeners = {};
};
EventBus.prototype._invokeListeners = function (event, args, listener) {
  var returnValue;
  while (listener) {
    // handle stopped propagation
    if (event.cancelBubble) {
      break;
    }
    returnValue = this._invokeListener(event, args, listener);
    listener = listener.next;
  }
  return returnValue;
};
EventBus.prototype._invokeListener = function (event, args, listener) {
  var returnValue;
  if (listener.callback.__isTomb) {
    return returnValue;
  }
  try {
    // returning false prevents the default action
    returnValue = invokeFunction(listener.callback, args);

    // stop propagation on return value
    if (returnValue !== undefined) {
      event.returnValue = returnValue;
      event.stopPropagation();
    }

    // prevent default on return false
    if (returnValue === false) {
      event.preventDefault();
    }
  } catch (error) {
    if (!this.handleError(error)) {
      console.error('unhandled error in event listener', error);
      throw error;
    }
  }
  return returnValue;
};

/*
 * Add new listener with a certain priority to the list
 * of listeners (for the given event).
 *
 * The semantics of listener registration / listener execution are
 * first register, first serve: New listeners will always be inserted
 * after existing listeners with the same priority.
 *
 * Example: Inserting two listeners with priority 1000 and 1300
 *
 *    * before: [ 1500, 1500, 1000, 1000 ]
 *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]
 *
 * @param {string} event
 * @param {Object} listener { priority, callback }
 */
EventBus.prototype._addListener = function (event, newListener) {
  var listener = this._getListeners(event),
    previousListener;

  // no prior listeners
  if (!listener) {
    this._setListeners(event, newListener);
    return;
  }

  // ensure we order listeners by priority from
  // 0 (high) to n > 0 (low)
  while (listener) {
    if (listener.priority < newListener.priority) {
      newListener.next = listener;
      if (previousListener) {
        previousListener.next = newListener;
      } else {
        this._setListeners(event, newListener);
      }
      return;
    }
    previousListener = listener;
    listener = listener.next;
  }

  // add new listener to back
  previousListener.next = newListener;
};
EventBus.prototype._getListeners = function (name) {
  return this._listeners[name];
};
EventBus.prototype._setListeners = function (name, listener) {
  this._listeners[name] = listener;
};
EventBus.prototype._removeListener = function (event, callback) {
  var listener = this._getListeners(event),
    nextListener,
    previousListener,
    listenerCallback;
  if (!callback) {
    // clear listeners
    this._setListeners(event, null);
    return;
  }
  while (listener) {
    nextListener = listener.next;
    listenerCallback = listener.callback;
    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {
      if (previousListener) {
        previousListener.next = nextListener;
      } else {
        // new first listener
        this._setListeners(event, nextListener);
      }
    }
    previousListener = listener;
    listener = nextListener;
  }
};

/**
 * A event that is emitted via the event bus.
 */
function InternalEvent() {}
InternalEvent.prototype.stopPropagation = function () {
  this.cancelBubble = true;
};
InternalEvent.prototype.preventDefault = function () {
  this.defaultPrevented = true;
};
InternalEvent.prototype.init = function (data) {
  minDash.assign(this, data || {});
};

/**
 * Invoke function. Be fast...
 *
 * @param {Function} fn
 * @param {Array<Object>} args
 *
 * @return {Any}
 */
function invokeFunction(fn, args) {
  return fn.apply(null, args);
}

/**
 * A factory to create a configurable debouncer.
 *
 * @param {number|boolean} [config=true]
 */
function DebounceFactory(config = true) {
  const timeout = typeof config === 'number' ? config : config ? 300 : 0;
  if (timeout) {
    return fn => minDash.debounce(fn, timeout);
  } else {
    return fn => fn;
  }
}
DebounceFactory.$inject = ['config.debounce'];

class FieldFactory {
  /**
   * @constructor
   *
   * @param { import('./FormFieldRegistry').default } formFieldRegistry
   * @param { import('@bpmn-io/form-js-viewer').FormFields } formFields
   */
  constructor(formFieldRegistry, formFields) {
    this._formFieldRegistry = formFieldRegistry;
    this._formFields = formFields;
  }
  create(attrs, applyDefaults = true) {
    const {
      id,
      key,
      type
    } = attrs;
    const fieldDefinition = this._formFields.get(type);
    if (!fieldDefinition) {
      throw new Error(`form field of type <${type}> not supported`);
    }
    if (id && this._formFieldRegistry._ids.assigned(id)) {
      throw new Error(`ID <${id}> already assigned`);
    }
    if (key && this._formFieldRegistry._keys.assigned(key)) {
      throw new Error(`key <${key}> already assigned`);
    }
    const labelAttrs = applyDefaults && fieldDefinition.label ? {
      label: fieldDefinition.label
    } : {};
    const field = fieldDefinition.create({
      ...labelAttrs,
      ...attrs
    });
    this._ensureId(field);
    if (fieldDefinition.keyed) {
      this._ensureKey(field, applyDefaults);
    }
    return field;
  }
  _ensureId(field) {
    if (field.id) {
      this._formFieldRegistry._ids.claim(field.id, field);
      return;
    }
    let prefix = 'Field';
    if (field.type === 'default') {
      prefix = 'Form';
    }
    field.id = this._formFieldRegistry._ids.nextPrefixed(`${prefix}_`, field);
  }
  _ensureKey(field, applyDefaults) {
    if (field.key) {
      this._formFieldRegistry._keys.claim(field.key, field);
      return;
    }
    if (applyDefaults) {
      let prefix = 'field';
      field.key = this._formFieldRegistry._keys.nextPrefixed(`${prefix}_`, field);
    }
  }
}
FieldFactory.$inject = ['formFieldRegistry', 'formFields'];

class FormFieldRegistry extends formJsViewer.FormFieldRegistry {
  /**
   * Updates a form fields id.
   *
   * @param {Object} formField
   * @param {string} newId
   */
  updateId(formField, newId) {
    this._validateId(newId);
    this._eventBus.fire('formField.updateId', {
      formField,
      newId: newId
    });
    this.remove(formField);
    formField.id = newId;
    this.add(formField);

    // TODO(nikku): make this a proper object graph so we
    // do not have to deal with IDs this way...
    if ('components' in formField) {
      for (const component of formField.components) {
        component._parent = newId;
      }
    }
  }

  /**
   * Validate the suitability of the given id and signals a problem
   * with an exception.
   *
   * @param {string} id
   *
   * @throws {Error} if id is empty or already assigned
   */
  _validateId(id) {
    if (!id) {
      throw new Error('formField must have an id');
    }
    if (this.get(id)) {
      throw new Error('formField with id ' + id + ' already added');
    }
  }
}

class Importer {
  /**
   * @constructor
   * @param { import('../core/FormFieldRegistry').default } formFieldRegistry
   * @param { import('../core/FieldFactory').default } fieldFactory
   */
  constructor(formFieldRegistry, fieldFactory) {
    this._formFieldRegistry = formFieldRegistry;
    this._fieldFactory = fieldFactory;
  }

  /**
   * Import schema creating fields, attaching additional
   * information to each field and adding fields to the
   * field registry.
   *
   * Additional information attached:
   *
   *   * `id` (unless present)
   *   * `_parent`
   *   * `_path`
   *
   * @param {any} schema
   *
   * @typedef {{ warnings: Error[], schema: any }} ImportResult
   * @returns {ImportResult}
   */
  importSchema(schema) {
    // TODO: Add warnings
    const warnings = [];
    try {
      const importedSchema = this.importFormField(formJsViewer.clone(schema));
      return {
        schema: importedSchema,
        warnings
      };
    } catch (err) {
      err.warnings = warnings;
      throw err;
    }
  }

  /**
   * @param {{[x: string]: any}} fieldAttrs
   * @param {String} [parentId]
   * @param {number} [index]
   *
   * @return {any} field
   */
  importFormField(fieldAttrs, parentId, index) {
    const {
      components,
      id,
      key
    } = fieldAttrs;
    let parent, path;
    if (parentId) {
      parent = this._formFieldRegistry.get(parentId);
    }

    // validate <id> uniqueness
    if (id && this._formFieldRegistry._ids.assigned(id)) {
      throw new Error(`form field with id <${id}> already exists`);
    }

    // validate <key> uniqueness
    if (key && this._formFieldRegistry._keys.assigned(key)) {
      throw new Error(`form field with key <${key}> already exists`);
    }

    // set form field path
    path = parent ? [...parent._path, 'components', index] : [];
    const field = this._fieldFactory.create({
      ...fieldAttrs,
      _path: path,
      _parent: parent && parent.id
    }, false);
    this._formFieldRegistry.add(field);
    if (components) {
      field.components = this.importFormFields(components, field.id);
    }
    return field;
  }

  /**
   * @param {Array<any>} components
   * @param {string} parentId
   *
   * @return {Array<any>} imported components
   */
  importFormFields(components, parentId) {
    return components.map((component, index) => {
      return this.importFormField(component, parentId, index);
    });
  }
}
Importer.$inject = ['formFieldRegistry', 'fieldFactory'];

var importModule = {
  importer: ['type', Importer]
};

function editorFormFieldClasses(type, {
  disabled = false
} = {}) {
  if (!type) {
    throw new Error('type required');
  }
  return classnames('fjs-form-field', `fjs-form-field-${type}`, {
    'fjs-disabled': disabled
  });
}

function _extends$2() { _extends$2 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }
var CloseIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$2({
  width: "16",
  height: "16",
  fill: "currentColor",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8 12 4.7z"
})));

function _extends$1() { _extends$1 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }
var SearchIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$1({
  width: "15",
  height: "15",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("path", {
  d: "M14.5 13.793l-3.776-3.776a5.508 5.508 0 10-.707.707l3.776 3.776.707-.707zM2 6.5a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0z",
  fill: "currentColor"
})));

function EditorText(props) {
  const {
    type,
    text = ''
  } = props.field;
  const Icon = formJsViewer.iconsByType('text');
  if (!text) {
    return jsxRuntime.jsx("div", {
      class: editorFormFieldClasses(type),
      children: jsxRuntime.jsxs("div", {
        class: "fjs-form-field-placeholder",
        children: [jsxRuntime.jsx(Icon, {
          viewBox: "0 0 54 54"
        }), "Text view is empty"]
      })
    });
  }
  if (formJsViewer.isExpression(text)) {
    return jsxRuntime.jsx("div", {
      class: editorFormFieldClasses(type),
      children: jsxRuntime.jsxs("div", {
        class: "fjs-form-field-placeholder",
        children: [jsxRuntime.jsx(Icon, {
          viewBox: "0 0 54 54"
        }), "Text view is populated by an expression"]
      })
    });
  }
  return jsxRuntime.jsx(formJsViewer.Text, {
    ...props,
    disableLinks: true
  });
}
EditorText.create = formJsViewer.Text.create;
EditorText.type = formJsViewer.Text.type;
EditorText.keyed = formJsViewer.Text.keyed;

const editorFormFields = [EditorText];

class EditorFormFields extends formJsViewer.FormFields {
  constructor() {
    super();
    editorFormFields.forEach(formField => {
      this.register(formField.type, formField);
    });
  }
}

const DragAndDropContext = preact.createContext({
  drake: null
});
var DragAndDropContext$1 = DragAndDropContext;

/**
 * @param {string} type
 * @param {boolean} [strict]
 *
 * @returns {any}
 */
function getService$1(type, strict) {}
const FormEditorContext = preact.createContext({
  getService: getService$1
});
var FormEditorContext$1 = FormEditorContext;

function useService$1 (type, strict) {
  const {
    getService
  } = hooks$1.useContext(FormEditorContext$1);
  return getService(type, strict);
}

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var ListDeleteIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends({
  xmlns: "http://www.w3.org/2000/svg",
  width: "11",
  height: "14"
}, props), /*#__PURE__*/React.createElement("path", {
  d: "M10 4v8c0 1.1-.9 2-2 2H3c-1.1 0-2-.9-2-2V4h9zM8 6H3v4.8c0 .66.5 1.2 1.111 1.2H6.89C7.5 12 8 11.46 8 10.8V6zm3-5H8.5l-1-1h-4l-1 1H0v1.5h11V1z"
})));

const PALETTE_ENTRIES = formJsViewer.formFields.filter(f => f.type !== 'default').map(f => {
  return {
    label: f.label,
    type: f.type,
    group: f.group
  };
});
const PALETTE_GROUPS = [{
  label: 'Basic input',
  id: 'basic-input'
}, {
  label: 'Selection',
  id: 'selection'
}, {
  label: 'Presentation',
  id: 'presentation'
}, {
  label: 'Action',
  id: 'action'
}];
function Palette(props) {
  const [entries, setEntries] = hooks$1.useState(PALETTE_ENTRIES);
  const [searchTerm, setSearchTerm] = hooks$1.useState('');
  const inputRef = hooks$1.useRef();
  const groups = groupEntries(entries);

  // filter entries on search change
  hooks$1.useEffect(() => {
    const filter = entry => {
      if (!searchTerm) {
        return true;
      }
      const search = entry.label.toLowerCase();
      return searchTerm.toLowerCase().split(/\s/g).every(term => search.includes(term));
    };
    const entries = PALETTE_ENTRIES.filter(filter);
    setEntries(entries);
  }, [searchTerm]);
  const handleInput = hooks$1.useCallback(event => {
    setSearchTerm(() => event.target.value);
  }, [setSearchTerm]);
  const handleClear = hooks$1.useCallback(event => {
    setSearchTerm('');
    inputRef.current.focus();
  }, [inputRef, setSearchTerm]);
  return jsxRuntime.jsxs("div", {
    class: "fjs-palette",
    children: [jsxRuntime.jsx("div", {
      class: "fjs-palette-header",
      title: "Components",
      children: "Components"
    }), jsxRuntime.jsxs("div", {
      class: "fjs-palette-search-container",
      children: [jsxRuntime.jsx("span", {
        class: "fjs-palette-search-icon",
        children: jsxRuntime.jsx(SearchIcon, {})
      }), jsxRuntime.jsx("input", {
        class: "fjs-palette-search",
        ref: inputRef,
        type: "text",
        placeholder: "Search components",
        value: searchTerm,
        onInput: handleInput
      }), searchTerm && jsxRuntime.jsx("button", {
        title: "Clear content",
        class: "fjs-palette-search-clear",
        onClick: handleClear,
        children: jsxRuntime.jsx(CloseIcon, {})
      })]
    }), jsxRuntime.jsxs("div", {
      class: "fjs-palette-entries",
      children: [groups.map(({
        label,
        entries,
        id
      }) => jsxRuntime.jsxs("div", {
        class: "fjs-palette-group",
        "data-group-id": id,
        children: [jsxRuntime.jsx("span", {
          class: "fjs-palette-group-title",
          children: label
        }), jsxRuntime.jsx("div", {
          class: "fjs-palette-fields fjs-drag-container fjs-no-drop",
          children: entries.map(({
            label,
            type
          }) => {
            const Icon = formJsViewer.iconsByType(type);
            return jsxRuntime.jsxs("div", {
              class: "fjs-palette-field fjs-drag-copy fjs-no-drop",
              "data-field-type": type,
              title: `Create ${getIndefiniteArticle(type)} ${label} element`,
              children: [Icon ? jsxRuntime.jsx(Icon, {
                class: "fjs-palette-field-icon",
                width: "36",
                height: "36",
                viewBox: "0 0 54 54"
              }) : null, jsxRuntime.jsx("span", {
                class: "fjs-palette-field-text",
                children: label
              })]
            });
          })
        })]
      })), groups.length == 0 && jsxRuntime.jsx("div", {
        class: "fjs-palette-no-entries",
        children: "No components found."
      })]
    })]
  });
}

// helpers ///////

function groupEntries(entries) {
  const groups = PALETTE_GROUPS.map(group => {
    return {
      ...group,
      entries: []
    };
  });
  const getGroup = id => groups.find(group => id === group.id);
  entries.forEach(entry => {
    const {
      group
    } = entry;
    getGroup(group).entries.push(entry);
  });
  return groups.filter(g => g.entries.length);
}
function getIndefiniteArticle(type) {
  if (['image'].includes(type)) {
    return 'an';
  }
  return 'a';
}

const CURSOR_CLS_PATTERN = /^fjs-cursor-.*$/;
function set(mode) {
  const classes = minDom.classes(document.body);
  classes.removeMatching(CURSOR_CLS_PATTERN);
  if (mode) {
    classes.add('fjs-cursor-' + mode);
  }
}
function unset() {
  set(null);
}

function ContextPad(props) {
  if (!props.children) {
    return null;
  }
  return jsxRuntime.jsx("div", {
    class: "fjs-context-pad",
    children: props.children
  });
}
function Empty(props) {
  return null;
}
function Element(props) {
  const eventBus = useService$1('eventBus'),
    formEditor = useService$1('formEditor'),
    formFieldRegistry = useService$1('formFieldRegistry'),
    modeling = useService$1('modeling'),
    selection = useService$1('selection');
  const {
    field
  } = props;
  const {
    id,
    type
  } = field;
  const ref = hooks$1.useRef();
  function scrollIntoView({
    selection
  }) {
    if (!selection || selection.id !== id || !ref.current) {
      return;
    }
    const elementBounds = ref.current.getBoundingClientRect(),
      containerBounds = formEditor._container.getBoundingClientRect();
    if (elementBounds.top < 0 || elementBounds.top > containerBounds.bottom) {
      ref.current.scrollIntoView();
    }
  }
  hooks$1.useEffect(() => {
    eventBus.on('selection.changed', scrollIntoView);
    return () => eventBus.off('selection.changed', scrollIntoView);
  }, [id]);
  function onClick(event) {
    event.stopPropagation();
    selection.toggle(field);
  }
  const classes = ['fjs-element'];
  if (props.class) {
    classes.push(...props.class.split(' '));
  }
  if (selection.isSelected(field)) {
    classes.push('fjs-editor-selected');
  }
  const onRemove = event => {
    event.stopPropagation();
    const parentField = formFieldRegistry.get(field._parent);
    const index = getFormFieldIndex(parentField, field);
    modeling.removeFormField(field, parentField, index);
  };
  return jsxRuntime.jsxs("div", {
    class: classes.join(' '),
    "data-id": id,
    "data-field-type": type,
    onClick: onClick,
    ref: ref,
    children: [jsxRuntime.jsx(ContextPad, {
      children: selection.isSelected(field) && field.type !== 'default' ? jsxRuntime.jsx("button", {
        class: "fjs-context-pad-item",
        onClick: onRemove,
        children: jsxRuntime.jsx(ListDeleteIcon, {})
      }) : null
    }), props.children]
  });
}
function Children(props) {
  const {
    field
  } = props;
  const {
    id
  } = field;
  const classes = ['fjs-children', 'fjs-drag-container'];
  if (props.class) {
    classes.push(...props.class.split(' '));
  }
  return jsxRuntime.jsx("div", {
    class: classes.join(' '),
    "data-id": id,
    children: props.children
  });
}
function FormEditor$1(props) {
  const eventBus = useService$1('eventBus'),
    formEditor = useService$1('formEditor'),
    formFieldRegistry = useService$1('formFieldRegistry'),
    injector = useService$1('injector'),
    modeling = useService$1('modeling'),
    selection = useService$1('selection'),
    palette = useService$1('palette'),
    paletteConfig = useService$1('config.palette'),
    propertiesPanel = useService$1('propertiesPanel'),
    propertiesPanelConfig = useService$1('config.propertiesPanel');
  const {
    schema
  } = formEditor._getState();
  const paletteRef = hooks$1.useRef(null);
  const propertiesPanelRef = hooks$1.useRef(null);
  const [, setSelection] = hooks$1.useState(schema);
  hooks$1.useEffect(() => {
    function handleSelectionChanged(event) {
      setSelection(event.selection || schema);
    }
    eventBus.on('selection.changed', handleSelectionChanged);
    setSelection(selection.get() || schema);
    return () => {
      eventBus.off('selection.changed', handleSelectionChanged);
    };
  }, [schema, selection]);
  const [drake, setDrake] = hooks$1.useState(null);
  const dragAndDropContext = {
    drake
  };
  hooks$1.useEffect(() => {
    const handleDragEvent = (type, context) => {
      return eventBus.fire(type, context);
    };
    const createDragulaInstance = () => {
      const dragulaInstance = dragula({
        isContainer(el) {
          return el.classList.contains('fjs-drag-container');
        },
        copy(el) {
          return el.classList.contains('fjs-drag-copy');
        },
        accepts(el, target) {
          return !target.classList.contains('fjs-no-drop');
        },
        slideFactorX: 10,
        slideFactorY: 5
      });

      // bind life cycle events
      dragulaInstance.on('drag', (element, source) => {
        handleDragEvent('drag.start', {
          element,
          source
        });
      });
      dragulaInstance.on('dragend', element => {
        handleDragEvent('drag.end', {
          element
        });
      });
      dragulaInstance.on('drop', (element, target, source, sibling) => {
        handleDragEvent('drag.drop', {
          element,
          target,
          source,
          sibling
        });
      });
      dragulaInstance.on('over', (element, container, source) => {
        handleDragEvent('drag.hover', {
          element,
          container,
          source
        });
      });
      dragulaInstance.on('out', (element, container, source) => {
        handleDragEvent('drag.out', {
          element,
          container,
          source
        });
      });
      dragulaInstance.on('cancel', (element, container, source) => {
        handleDragEvent('drag.cancel', {
          element,
          container,
          source
        });
      });

      // set custom styling
      dragulaInstance.on('drag', () => {
        set('grabbing');
      });
      dragulaInstance.on('dragend', () => {
        unset();
      });
      dragulaInstance.on('drop', (el, target, source, sibling) => {
        dragulaInstance.remove();
        if (!target) {
          return;
        }
        const targetFormField = formFieldRegistry.get(target.dataset.id);
        const siblingFormField = sibling && formFieldRegistry.get(sibling.dataset.id),
          targetIndex = siblingFormField ? getFormFieldIndex(targetFormField, siblingFormField) : targetFormField.components.length;
        if (source.classList.contains('fjs-palette-fields')) {
          const type = el.dataset.fieldType;
          modeling.addFormField({
            type
          }, targetFormField, targetIndex);
        } else {
          const formField = formFieldRegistry.get(el.dataset.id),
            sourceFormField = formFieldRegistry.get(source.dataset.id),
            sourceIndex = getFormFieldIndex(sourceFormField, formField);
          modeling.moveFormField(formField, sourceFormField, targetFormField, sourceIndex, targetIndex);
        }
      });
      eventBus.fire('dragula.created');
      setDrake(dragulaInstance);
      return dragulaInstance;
    };
    let dragulaInstance = createDragulaInstance();
    const onDetach = () => {
      if (dragulaInstance) {
        dragulaInstance.destroy();
        eventBus.fire('dragula.destroyed');
      }
    };
    const onAttach = () => {
      onDetach();
      dragulaInstance = createDragulaInstance();
    };
    eventBus.on('attach', onAttach);
    eventBus.on('detach', onDetach);
    return () => {
      onDetach();
      eventBus.off('attach', onAttach);
      eventBus.off('detach', onDetach);
    };
  }, []);

  // fire event after render to notify interested parties
  hooks$1.useEffect(() => {
    eventBus.fire('formEditor.rendered');
  }, []);
  const formRenderContext = {
    Children,
    Element,
    Empty
  };
  const formContext = {
    getService(type, strict = true) {
      // TODO(philippfromme): clean up
      if (type === 'form') {
        return {
          _getState() {
            return {
              data: {},
              errors: {},
              properties: {
                readOnly: true
              },
              schema
            };
          }
        };
      }
      return injector.get(type, strict);
    },
    formId: formEditor._id
  };
  const onSubmit = hooks$1.useCallback(() => {}, []);
  const onReset = hooks$1.useCallback(() => {}, []);

  // attach default palette
  const hasDefaultPalette = defaultPalette(paletteConfig);
  hooks$1.useEffect(() => {
    if (hasDefaultPalette) {
      palette.attachTo(paletteRef.current);
    }
  }, [palette, paletteRef, hasDefaultPalette]);

  // attach default properties panel
  const hasDefaultPropertiesPanel = defaultPropertiesPanel(propertiesPanelConfig);
  hooks$1.useEffect(() => {
    if (hasDefaultPropertiesPanel) {
      propertiesPanel.attachTo(propertiesPanelRef.current);
    }
  }, [propertiesPanelRef, propertiesPanel, hasDefaultPropertiesPanel]);
  return jsxRuntime.jsxs("div", {
    class: "fjs-form-editor",
    children: [jsxRuntime.jsxs(DragAndDropContext$1.Provider, {
      value: dragAndDropContext,
      children: [hasDefaultPalette && jsxRuntime.jsx("div", {
        class: "fjs-editor-palette-container",
        ref: paletteRef
      }), jsxRuntime.jsx("div", {
        class: "fjs-form-container",
        children: jsxRuntime.jsx(formJsViewer.FormContext.Provider, {
          value: formContext,
          children: jsxRuntime.jsx(formJsViewer.FormRenderContext.Provider, {
            value: formRenderContext,
            children: jsxRuntime.jsx(formJsViewer.FormComponent, {
              onSubmit: onSubmit,
              onReset: onReset
            })
          })
        })
      }), jsxRuntime.jsx(CreatePreview, {})]
    }), hasDefaultPropertiesPanel && jsxRuntime.jsx("div", {
      class: "fjs-editor-properties-container",
      ref: propertiesPanelRef
    })]
  });
}
function getFormFieldIndex(parent, formField) {
  let fieldFormIndex = parent.components.length;
  parent.components.forEach(({
    id
  }, index) => {
    if (id === formField.id) {
      fieldFormIndex = index;
    }
  });
  return fieldFormIndex;
}
function CreatePreview(props) {
  const {
    drake
  } = hooks$1.useContext(DragAndDropContext$1);
  function handleCloned(clone, original, type) {
    const fieldType = clone.dataset.fieldType;
    const Icon = formJsViewer.iconsByType(fieldType);
    const {
      label
    } = findPaletteEntry(fieldType);
    if (fieldType) {
      clone.innerHTML = '';
      clone.class = 'gu-mirror';
      if (original.classList.contains('fjs-palette-field')) {
        preact.render(jsxRuntime.jsxs("div", {
          class: "fjs-palette-field",
          children: [jsxRuntime.jsx(Icon, {
            class: "fjs-palette-field-icon",
            width: "36",
            height: "36",
            viewBox: "0 0 54 54"
          }), jsxRuntime.jsx("span", {
            class: "fjs-palette-field-text",
            children: label
          })]
        }), clone);
      } else {
        preact.render(jsxRuntime.jsx(Icon, {}), clone);
      }
    }
  }
  hooks$1.useEffect(() => {
    if (!drake) {
      return;
    }
    drake.on('cloned', handleCloned);
    return () => drake.off('cloned', handleCloned);
  }, [drake]);
  return null;
}

// helper //////

function defaultPalette(paletteConfig) {
  return !(paletteConfig && paletteConfig.parent);
}
function defaultPropertiesPanel(propertiesPanelConfig) {
  return !(propertiesPanelConfig && propertiesPanelConfig.parent);
}
function findPaletteEntry(type) {
  return PALETTE_ENTRIES.find(entry => entry.type === type);
}

class Renderer {
  constructor(renderConfig, eventBus, formEditor, injector) {
    const {
      container,
      compact = false
    } = renderConfig;
    const App = () => {
      const [state, setState] = hooks$1.useState(formEditor._getState());
      const formEditorContext = {
        getService(type, strict = true) {
          return injector.get(type, strict);
        }
      };
      formEditor.on('changed', newState => {
        setState(newState);
      });
      const {
        schema
      } = state;
      if (!schema) {
        return null;
      }
      return jsxRuntime.jsx("div", {
        class: `fjs-container fjs-editor-container ${compact ? 'fjs-editor-compact' : ''}`,
        children: jsxRuntime.jsx(FormEditorContext$1.Provider, {
          value: formEditorContext,
          children: jsxRuntime.jsx(FormEditor$1, {})
        })
      });
    };
    eventBus.on('form.init', () => {
      preact.render(jsxRuntime.jsx(App, {}), container);
    });
    eventBus.on('form.destroy', () => {
      preact.render(null, container);
    });
  }
}
Renderer.$inject = ['config.renderer', 'eventBus', 'formEditor', 'injector'];

var renderModule = {
  __init__: ['formFields', 'renderer'],
  formFields: ['type', EditorFormFields],
  renderer: ['type', Renderer]
};

var core = {
  __depends__: [importModule, renderModule],
  eventBus: ['type', EventBus],
  formFieldRegistry: ['type', FormFieldRegistry],
  fieldFactory: ['type', FieldFactory],
  debounce: ['factory', DebounceFactory]
};

var NOT_REGISTERED_ERROR = 'is not a registered action',
  IS_REGISTERED_ERROR = 'is already registered';

/**
 * An interface that provides access to modeling actions by decoupling
 * the one who requests the action to be triggered and the trigger itself.
 *
 * It's possible to add new actions by registering them with ´registerAction´
 * and likewise unregister existing ones with ´unregisterAction´.
 *
 *
 * ## Life-Cycle and configuration
 *
 * The editor actions will wait for diagram initialization before
 * registering default actions _and_ firing an `editorActions.init` event.
 *
 * Interested parties may listen to the `editorActions.init` event with
 * low priority to check, which actions got registered. Other components
 * may use the event to register their own actions via `registerAction`.
 *
 * @param {EventBus} eventBus
 * @param {Injector} injector
 */
function EditorActions(eventBus, injector) {
  // initialize actions
  this._actions = {};
  var self = this;
  eventBus.on('diagram.init', function () {
    // all diagram modules got loaded; check which ones
    // are available and register the respective default actions
    self._registerDefaultActions(injector);

    // ask interested parties to register available editor
    // actions on diagram initialization
    eventBus.fire('editorActions.init', {
      editorActions: self
    });
  });
}
EditorActions.$inject = ['eventBus', 'injector'];

/**
 * Register default actions.
 *
 * @param {Injector} injector
 */
EditorActions.prototype._registerDefaultActions = function (injector) {
  // (1) retrieve optional components to integrate with

  var commandStack = injector.get('commandStack', false);
  var modeling = injector.get('modeling', false);
  var selection = injector.get('selection', false);
  var zoomScroll = injector.get('zoomScroll', false);
  var copyPaste = injector.get('copyPaste', false);
  var canvas = injector.get('canvas', false);
  var rules = injector.get('rules', false);
  var keyboardMove = injector.get('keyboardMove', false);
  var keyboardMoveSelection = injector.get('keyboardMoveSelection', false);

  // (2) check components and register actions

  if (commandStack) {
    this.register('undo', function () {
      commandStack.undo();
    });
    this.register('redo', function () {
      commandStack.redo();
    });
  }
  if (copyPaste && selection) {
    this.register('copy', function () {
      var selectedElements = selection.get();
      if (selectedElements.length) {
        return copyPaste.copy(selectedElements);
      }
    });
  }
  if (copyPaste) {
    this.register('paste', function () {
      copyPaste.paste();
    });
  }
  if (zoomScroll) {
    this.register('stepZoom', function (opts) {
      zoomScroll.stepZoom(opts.value);
    });
  }
  if (canvas) {
    this.register('zoom', function (opts) {
      canvas.zoom(opts.value);
    });
  }
  if (modeling && selection && rules) {
    this.register('removeSelection', function () {
      var selectedElements = selection.get();
      if (!selectedElements.length) {
        return;
      }
      var allowed = rules.allowed('elements.delete', {
          elements: selectedElements
        }),
        removableElements;
      if (allowed === false) {
        return;
      } else if (minDash.isArray(allowed)) {
        removableElements = allowed;
      } else {
        removableElements = selectedElements;
      }
      if (removableElements.length) {
        modeling.removeElements(removableElements.slice());
      }
    });
  }
  if (keyboardMove) {
    this.register('moveCanvas', function (opts) {
      keyboardMove.moveCanvas(opts);
    });
  }
  if (keyboardMoveSelection) {
    this.register('moveSelection', function (opts) {
      keyboardMoveSelection.moveSelection(opts.direction, opts.accelerated);
    });
  }
};

/**
 * Triggers a registered action
 *
 * @param  {string} action
 * @param  {Object} opts
 *
 * @return {Unknown} Returns what the registered listener returns
 */
EditorActions.prototype.trigger = function (action, opts) {
  if (!this._actions[action]) {
    throw error(action, NOT_REGISTERED_ERROR);
  }
  return this._actions[action](opts);
};

/**
 * Registers a collections of actions.
 * The key of the object will be the name of the action.
 *
 * @example
 * ´´´
 * var actions = {
 *   spaceTool: function() {
 *     spaceTool.activateSelection();
 *   },
 *   lassoTool: function() {
 *     lassoTool.activateSelection();
 *   }
 * ];
 *
 * editorActions.register(actions);
 *
 * editorActions.isRegistered('spaceTool'); // true
 * ´´´
 *
 * @param  {Object} actions
 */
EditorActions.prototype.register = function (actions, listener) {
  var self = this;
  if (typeof actions === 'string') {
    return this._registerAction(actions, listener);
  }
  minDash.forEach(actions, function (listener, action) {
    self._registerAction(action, listener);
  });
};

/**
 * Registers a listener to an action key
 *
 * @param  {string} action
 * @param  {Function} listener
 */
EditorActions.prototype._registerAction = function (action, listener) {
  if (this.isRegistered(action)) {
    throw error(action, IS_REGISTERED_ERROR);
  }
  this._actions[action] = listener;
};

/**
 * Unregister an existing action
 *
 * @param {string} action
 */
EditorActions.prototype.unregister = function (action) {
  if (!this.isRegistered(action)) {
    throw error(action, NOT_REGISTERED_ERROR);
  }
  this._actions[action] = undefined;
};

/**
 * Returns the number of actions that are currently registered
 *
 * @return {number}
 */
EditorActions.prototype.getActions = function () {
  return Object.keys(this._actions);
};

/**
 * Checks wether the given action is registered
 *
 * @param {string} action
 *
 * @return {boolean}
 */
EditorActions.prototype.isRegistered = function (action) {
  return !!this._actions[action];
};
function error(action, message) {
  return new Error(action + ' ' + message);
}

var EditorActionsModule$1 = {
  __init__: ['editorActions'],
  editorActions: ['type', EditorActions]
};

class FormEditorActions extends EditorActions {
  constructor(eventBus, injector) {
    super(eventBus, injector);
    eventBus.on('form.init', () => {
      this._registerDefaultActions(injector);
      eventBus.fire('editorActions.init', {
        editorActions: this
      });
    });
  }
  _registerDefaultActions(injector) {
    const commandStack = injector.get('commandStack', false),
      formFieldRegistry = injector.get('formFieldRegistry', false),
      selection = injector.get('selection', false);
    if (commandStack) {
      // @ts-ignore
      this.register('undo', () => {
        commandStack.undo();
      });

      // @ts-ignore
      this.register('redo', () => {
        commandStack.redo();
      });
    }
    if (formFieldRegistry && selection) {
      // @ts-ignore
      this.register('selectFormField', (options = {}) => {
        const {
          id
        } = options;
        if (!id) {
          return;
        }
        const formField = formFieldRegistry.get(id);
        if (formField) {
          selection.set(formField);
        }
      });
    }
  }
}
FormEditorActions.$inject = ['eventBus', 'injector'];

var EditorActionsModule = {
  __depends__: [EditorActionsModule$1],
  editorActions: ['type', FormEditorActions]
};

var KEYS_COPY = ['c', 'C', 'KeyC'];
var KEYS_PASTE = ['v', 'V', 'KeyV'];
var KEYS_REDO$1 = ['y', 'Y', 'KeyY'];
var KEYS_UNDO$1 = ['z', 'Z', 'KeyZ'];

/**
 * Returns true if event was triggered with any modifier
 * @param {KeyboardEvent} event
 */
function hasModifier(event) {
  return event.ctrlKey || event.metaKey || event.shiftKey || event.altKey;
}

/**
 * @param {KeyboardEvent} event
 */
function isCmd(event) {
  // ensure we don't react to AltGr
  // (mapped to CTRL + ALT)
  if (event.altKey) {
    return false;
  }
  return event.ctrlKey || event.metaKey;
}

/**
 * Checks if key pressed is one of provided keys.
 *
 * @param {string|Array<string>} keys
 * @param {KeyboardEvent} event
 */
function isKey(keys, event) {
  keys = minDash.isArray(keys) ? keys : [keys];
  return keys.indexOf(event.key) !== -1 || keys.indexOf(event.code) !== -1;
}

/**
 * @param {KeyboardEvent} event
 */
function isShift(event) {
  return event.shiftKey;
}
function isCopy(event) {
  return isCmd(event) && isKey(KEYS_COPY, event);
}
function isPaste(event) {
  return isCmd(event) && isKey(KEYS_PASTE, event);
}
function isUndo(event) {
  return isCmd(event) && !isShift(event) && isKey(KEYS_UNDO$1, event);
}
function isRedo(event) {
  return isCmd(event) && (isKey(KEYS_REDO$1, event) || isKey(KEYS_UNDO$1, event) && isShift(event));
}

var KEYDOWN_EVENT = 'keyboard.keydown',
  KEYUP_EVENT = 'keyboard.keyup';
var HANDLE_MODIFIER_ATTRIBUTE = 'input-handle-modified-keys';
var DEFAULT_PRIORITY$1 = 1000;

/**
 * A keyboard abstraction that may be activated and
 * deactivated by users at will, consuming global key events
 * and triggering diagram actions.
 *
 * For keys pressed down, keyboard fires `keyboard.keydown` event.
 * The event context contains one field which is `KeyboardEvent` event.
 *
 * The implementation fires the following key events that allow
 * other components to hook into key handling:
 *
 *  - keyboard.bind
 *  - keyboard.unbind
 *  - keyboard.init
 *  - keyboard.destroy
 *
 * All events contain one field which is node.
 *
 * A default binding for the keyboard may be specified via the
 * `keyboard.bindTo` configuration option.
 *
 * @param {Config} config
 * @param {EventBus} eventBus
 */
function Keyboard(config, eventBus) {
  var self = this;
  this._config = config || {};
  this._eventBus = eventBus;
  this._keydownHandler = this._keydownHandler.bind(this);
  this._keyupHandler = this._keyupHandler.bind(this);

  // properly clean dom registrations
  eventBus.on('diagram.destroy', function () {
    self._fire('destroy');
    self.unbind();
  });
  eventBus.on('diagram.init', function () {
    self._fire('init');
  });
  eventBus.on('attach', function () {
    if (config && config.bindTo) {
      self.bind(config.bindTo);
    }
  });
  eventBus.on('detach', function () {
    self.unbind();
  });
}
Keyboard.$inject = ['config.keyboard', 'eventBus'];
Keyboard.prototype._keydownHandler = function (event) {
  this._keyHandler(event, KEYDOWN_EVENT);
};
Keyboard.prototype._keyupHandler = function (event) {
  this._keyHandler(event, KEYUP_EVENT);
};
Keyboard.prototype._keyHandler = function (event, type) {
  var eventBusResult;
  if (this._isEventIgnored(event)) {
    return;
  }
  var context = {
    keyEvent: event
  };
  eventBusResult = this._eventBus.fire(type || KEYDOWN_EVENT, context);
  if (eventBusResult) {
    event.preventDefault();
  }
};
Keyboard.prototype._isEventIgnored = function (event) {
  if (event.defaultPrevented) {
    return true;
  }
  return isInput(event.target) && this._isModifiedKeyIgnored(event);
};
Keyboard.prototype._isModifiedKeyIgnored = function (event) {
  if (!isCmd(event)) {
    return true;
  }
  var allowedModifiers = this._getAllowedModifiers(event.target);
  return allowedModifiers.indexOf(event.key) === -1;
};
Keyboard.prototype._getAllowedModifiers = function (element) {
  var modifierContainer = minDom.closest(element, '[' + HANDLE_MODIFIER_ATTRIBUTE + ']', true);
  if (!modifierContainer || this._node && !this._node.contains(modifierContainer)) {
    return [];
  }
  return modifierContainer.getAttribute(HANDLE_MODIFIER_ATTRIBUTE).split(',');
};
Keyboard.prototype.bind = function (node) {
  // make sure that the keyboard is only bound once to the DOM
  this.unbind();
  this._node = node;

  // bind key events
  minDom.event.bind(node, 'keydown', this._keydownHandler);
  minDom.event.bind(node, 'keyup', this._keyupHandler);
  this._fire('bind');
};
Keyboard.prototype.getBinding = function () {
  return this._node;
};
Keyboard.prototype.unbind = function () {
  var node = this._node;
  if (node) {
    this._fire('unbind');

    // unbind key events
    minDom.event.unbind(node, 'keydown', this._keydownHandler);
    minDom.event.unbind(node, 'keyup', this._keyupHandler);
  }
  this._node = null;
};
Keyboard.prototype._fire = function (event) {
  this._eventBus.fire('keyboard.' + event, {
    node: this._node
  });
};

/**
 * Add a listener function that is notified with `KeyboardEvent` whenever
 * the keyboard is bound and the user presses a key. If no priority is
 * provided, the default value of 1000 is used.
 *
 * @param {number} [priority]
 * @param {Function} listener
 * @param {string} type
 */
Keyboard.prototype.addListener = function (priority, listener, type) {
  if (minDash.isFunction(priority)) {
    type = listener;
    listener = priority;
    priority = DEFAULT_PRIORITY$1;
  }
  this._eventBus.on(type || KEYDOWN_EVENT, priority, listener);
};
Keyboard.prototype.removeListener = function (listener, type) {
  this._eventBus.off(type || KEYDOWN_EVENT, listener);
};
Keyboard.prototype.hasModifier = hasModifier;
Keyboard.prototype.isCmd = isCmd;
Keyboard.prototype.isShift = isShift;
Keyboard.prototype.isKey = isKey;

// helpers ///////

function isInput(target) {
  return target && (minDom.matches(target, 'input, textarea') || target.contentEditable === 'true');
}

var LOW_PRIORITY$1 = 500;
var KEYS_REDO = ['y', 'Y', 'KeyY'];
var KEYS_UNDO = ['z', 'Z', 'KeyZ'];

/**
 * Adds default keyboard bindings.
 *
 * This does not pull in any features will bind only actions that
 * have previously been registered against the editorActions component.
 *
 * @param {EventBus} eventBus
 * @param {Keyboard} keyboard
 */
function KeyboardBindings(eventBus, keyboard) {
  var self = this;
  eventBus.on('editorActions.init', LOW_PRIORITY$1, function (event) {
    var editorActions = event.editorActions;
    self.registerBindings(keyboard, editorActions);
  });
}
KeyboardBindings.$inject = ['eventBus', 'keyboard'];

/**
 * Register available keyboard bindings.
 *
 * @param {Keyboard} keyboard
 * @param {EditorActions} editorActions
 */
KeyboardBindings.prototype.registerBindings = function (keyboard, editorActions) {
  /**
   * Add keyboard binding if respective editor action
   * is registered.
   *
   * @param {string} action name
   * @param {Function} fn that implements the key binding
   */
  function addListener(action, fn) {
    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn);
    }
  }

  // undo
  // (CTRL|CMD) + Z
  addListener('undo', function (context) {
    var event = context.keyEvent;
    if (isUndo(event)) {
      editorActions.trigger('undo');
      return true;
    }
  });

  // redo
  // CTRL + Y
  // CMD + SHIFT + Z
  addListener('redo', function (context) {
    var event = context.keyEvent;
    if (isRedo(event)) {
      editorActions.trigger('redo');
      return true;
    }
  });

  // copy
  // CTRL/CMD + C
  addListener('copy', function (context) {
    var event = context.keyEvent;
    if (isCopy(event)) {
      editorActions.trigger('copy');
      return true;
    }
  });

  // paste
  // CTRL/CMD + V
  addListener('paste', function (context) {
    var event = context.keyEvent;
    if (isPaste(event)) {
      editorActions.trigger('paste');
      return true;
    }
  });

  // zoom in one step
  // CTRL/CMD + +
  addListener('stepZoom', function (context) {
    var event = context.keyEvent;

    // quirk: it has to be triggered by `=` as well to work on international keyboard layout
    // cf: https://github.com/bpmn-io/bpmn-js/issues/1362#issuecomment-722989754
    if (isKey(['+', 'Add', '='], event) && isCmd(event)) {
      editorActions.trigger('stepZoom', {
        value: 1
      });
      return true;
    }
  });

  // zoom out one step
  // CTRL + -
  addListener('stepZoom', function (context) {
    var event = context.keyEvent;
    if (isKey(['-', 'Subtract'], event) && isCmd(event)) {
      editorActions.trigger('stepZoom', {
        value: -1
      });
      return true;
    }
  });

  // zoom to the default level
  // CTRL + 0
  addListener('zoom', function (context) {
    var event = context.keyEvent;
    if (isKey('0', event) && isCmd(event)) {
      editorActions.trigger('zoom', {
        value: 1
      });
      return true;
    }
  });

  // delete selected element
  // DEL
  addListener('removeSelection', function (context) {
    var event = context.keyEvent;
    if (isKey(['Backspace', 'Delete', 'Del'], event)) {
      editorActions.trigger('removeSelection');
      return true;
    }
  });
};

var KeyboardModule$1 = {
  __init__: ['keyboard', 'keyboardBindings'],
  keyboard: ['type', Keyboard],
  keyboardBindings: ['type', KeyboardBindings]
};

const LOW_PRIORITY = 500;
class FormEditorKeyboardBindings {
  constructor(eventBus, keyboard) {
    eventBus.on('editorActions.init', LOW_PRIORITY, event => {
      const {
        editorActions
      } = event;
      this.registerBindings(keyboard, editorActions);
    });
  }
  registerBindings(keyboard, editorActions) {
    function addListener(action, fn) {
      if (editorActions.isRegistered(action)) {
        keyboard.addListener(fn);
      }
    }

    // undo
    // (CTRL|CMD) + Z
    addListener('undo', context => {
      const {
        keyEvent
      } = context;
      if (isCmd(keyEvent) && !isShift(keyEvent) && isKey(KEYS_UNDO, keyEvent)) {
        editorActions.trigger('undo');
        return true;
      }
    });

    // redo
    // CTRL + Y
    // CMD + SHIFT + Z
    addListener('redo', context => {
      const {
        keyEvent
      } = context;
      if (isCmd(keyEvent) && (isKey(KEYS_REDO, keyEvent) || isKey(KEYS_UNDO, keyEvent) && isShift(keyEvent))) {
        editorActions.trigger('redo');
        return true;
      }
    });
  }
}
FormEditorKeyboardBindings.$inject = ['eventBus', 'keyboard'];

var KeyboardModule = {
  __depends__: [KeyboardModule$1],
  __init__: ['keyboardBindings'],
  keyboardBindings: ['type', FormEditorKeyboardBindings]
};

function arrayAdd$1(array, index, item) {
  array.splice(index, 0, item);
  return array;
}
function arrayRemove(array, index) {
  array.splice(index, 1);
  return array;
}
function updatePath(formFieldRegistry, formField, index) {
  const parent = formFieldRegistry.get(formField._parent);
  formField._path = [...parent._path, 'components', index];
  return formField;
}

class AddFormFieldHandler {
  /**
   * @constructor
   * @param { import('../../../FormEditor').default } formEditor
   * @param { import('../../../core/FormFieldRegistry').default } formFieldRegistry
   */
  constructor(formEditor, formFieldRegistry) {
    this._formEditor = formEditor;
    this._formFieldRegistry = formFieldRegistry;
  }
  execute(context) {
    const {
      formField,
      targetFormField,
      targetIndex
    } = context;
    const {
      schema
    } = this._formEditor._getState();
    const targetPath = [...targetFormField._path, 'components'];
    formField._parent = targetFormField.id;

    // (1) Add new form field
    arrayAdd$1(minDash.get(schema, targetPath), targetIndex, formField);

    // (2) Update paths of new form field and its siblings
    minDash.get(schema, targetPath).forEach((formField, index) => updatePath(this._formFieldRegistry, formField, index));

    // (3) Add new form field to form field registry
    this._formFieldRegistry.add(formField);

    // TODO: Create updater/change support that automatically updates paths and schema on command execution
    this._formEditor._setState({
      schema
    });
  }
  revert(context) {
    const {
      formField,
      targetFormField,
      targetIndex
    } = context;
    const {
      schema
    } = this._formEditor._getState();
    const targetPath = [...targetFormField._path, 'components'];

    // (1) Remove new form field
    arrayRemove(minDash.get(schema, targetPath), targetIndex);

    // (2) Update paths of new form field and its siblings
    minDash.get(schema, targetPath).forEach((formField, index) => updatePath(this._formFieldRegistry, formField, index));

    // (3) Remove new form field from form field registry
    this._formFieldRegistry.remove(formField);

    // TODO: Create updater/change support that automatically updates paths and schema on command execution
    this._formEditor._setState({
      schema
    });
  }
}
AddFormFieldHandler.$inject = ['formEditor', 'formFieldRegistry'];

class EditFormFieldHandler {
  /**
   * @constructor
   * @param { import('../../../FormEditor').default } formEditor
   * @param { import('../../../core/FormFieldRegistry').default } formFieldRegistry
   */
  constructor(formEditor, formFieldRegistry) {
    this._formEditor = formEditor;
    this._formFieldRegistry = formFieldRegistry;
  }
  execute(context) {
    const {
      formField,
      properties
    } = context;
    let {
      schema
    } = this._formEditor._getState();
    const oldProperties = {};
    for (let key in properties) {
      oldProperties[key] = formField[key];
      const property = properties[key];
      if (key === 'id') {
        if (property !== formField.id) {
          this._formFieldRegistry.updateId(formField, property);
        }
      } else {
        formField[key] = property;
      }
    }
    context.oldProperties = oldProperties;

    // TODO: Create updater/change support that automatically updates paths and schema on command execution
    this._formEditor._setState({
      schema
    });
    return formField;
  }
  revert(context) {
    const {
      formField,
      oldProperties
    } = context;
    let {
      schema
    } = this._formEditor._getState();
    for (let key in oldProperties) {
      const property = oldProperties[key];
      if (key === 'id') {
        if (property !== formField.id) {
          this._formFieldRegistry.updateId(formField, property);
        }
      } else {
        formField[key] = property;
      }
    }

    // TODO: Create updater/change support that automatically updates paths and schema on command execution
    this._formEditor._setState({
      schema
    });
    return formField;
  }
}
EditFormFieldHandler.$inject = ['formEditor', 'formFieldRegistry'];

class MoveFormFieldHandler {
  /**
   * @constructor
   * @param { import('../../../FormEditor').default } formEditor
   * @param { import('../../../core/FormFieldRegistry').default } formFieldRegistry
   */
  constructor(formEditor, formFieldRegistry) {
    this._formEditor = formEditor;
    this._formFieldRegistry = formFieldRegistry;
  }
  execute(context) {
    this.moveFormField(context);
  }
  revert(context) {
    let {
      sourceFormField,
      targetFormField,
      sourceIndex,
      targetIndex
    } = context;
    this.moveFormField({
      sourceFormField: targetFormField,
      targetFormField: sourceFormField,
      sourceIndex: targetIndex,
      targetIndex: sourceIndex
    }, true);
  }
  moveFormField(context, revert) {
    let {
      sourceFormField,
      targetFormField,
      sourceIndex,
      targetIndex
    } = context;
    let {
      schema
    } = this._formEditor._getState();
    const sourcePath = [...sourceFormField._path, 'components'];
    if (sourceFormField.id === targetFormField.id) {
      if (revert) {
        if (sourceIndex > targetIndex) {
          sourceIndex--;
        }
      } else {
        if (sourceIndex < targetIndex) {
          targetIndex--;
        }
      }

      // (1) Move form field
      arrayMove.mutate(minDash.get(schema, sourcePath), sourceIndex, targetIndex);

      // (2) Update paths of new form field and its siblings
      minDash.get(schema, sourcePath).forEach((formField, index) => updatePath(this._formFieldRegistry, formField, index));
    } else {
      const formField = minDash.get(schema, [...sourcePath, sourceIndex]);
      formField._parent = targetFormField.id;

      // (1) Remove form field
      arrayRemove(minDash.get(schema, sourcePath), sourceIndex);

      // (2) Update paths of siblings
      minDash.get(schema, sourcePath).forEach((formField, index) => updatePath(this._formFieldRegistry, formField, index));
      const targetPath = [...targetFormField._path, 'components'];

      // (3) Add form field
      arrayAdd$1(minDash.get(schema, targetPath), targetIndex, formField);

      // (4) Update paths of siblings
      minDash.get(schema, targetPath).forEach((formField, index) => updatePath(this._formFieldRegistry, formField, index));
    }

    // TODO: Create updater/change support that automatically updates paths and schema on command execution
    this._formEditor._setState({
      schema
    });
  }
}
MoveFormFieldHandler.$inject = ['formEditor', 'formFieldRegistry'];

class RemoveFormFieldHandler {
  /**
   * @constructor
   * @param { import('../../../FormEditor').default } formEditor
   * @param { import('../../../core/FormFieldRegistry').default } formFieldRegistry
   */
  constructor(formEditor, formFieldRegistry) {
    this._formEditor = formEditor;
    this._formFieldRegistry = formFieldRegistry;
  }
  execute(context) {
    const {
      sourceFormField,
      sourceIndex
    } = context;
    let {
      schema
    } = this._formEditor._getState();
    const sourcePath = [...sourceFormField._path, 'components'];
    const formField = context.formField = minDash.get(schema, [...sourcePath, sourceIndex]);

    // (1) Remove form field
    arrayRemove(minDash.get(schema, sourcePath), sourceIndex);

    // (2) Update paths of its siblings
    minDash.get(schema, sourcePath).forEach((formField, index) => updatePath(this._formFieldRegistry, formField, index));

    // (3) Remove form field from form field registry
    this._formFieldRegistry.remove(formField);

    // TODO: Create updater/change support that automatically updates paths and schema on command execution
    this._formEditor._setState({
      schema
    });
  }
  revert(context) {
    const {
      formField,
      sourceFormField,
      sourceIndex
    } = context;
    let {
      schema
    } = this._formEditor._getState();
    const sourcePath = [...sourceFormField._path, 'components'];

    // (1) Add form field
    arrayAdd$1(minDash.get(schema, sourcePath), sourceIndex, formField);

    // (2) Update paths of its siblings
    minDash.get(schema, sourcePath).forEach((formField, index) => updatePath(this._formFieldRegistry, formField, index));

    // (3) Add form field to form field registry
    this._formFieldRegistry.add(formField);

    // TODO: Create updater/change support that automatically updates paths and schema on command execution
    this._formEditor._setState({
      schema
    });
  }
}
RemoveFormFieldHandler.$inject = ['formEditor', 'formFieldRegistry'];

class UpdateIdClaimHandler {
  /**
   * @constructor
   * @param { import('../../../core/FormFieldRegistry').default } formFieldRegistry
   */
  constructor(formFieldRegistry) {
    this._formFieldRegistry = formFieldRegistry;
  }
  execute(context) {
    const {
      claiming,
      formField,
      id
    } = context;
    if (claiming) {
      this._formFieldRegistry._ids.claim(id, formField);
    } else {
      this._formFieldRegistry._ids.unclaim(id);
    }
  }
  revert(context) {
    const {
      claiming,
      formField,
      id
    } = context;
    if (claiming) {
      this._formFieldRegistry._ids.unclaim(id);
    } else {
      this._formFieldRegistry._ids.claim(id, formField);
    }
  }
}
UpdateIdClaimHandler.$inject = ['formFieldRegistry'];

class UpdateKeyClaimHandler {
  /**
   * @constructor
   * @param { import('../../../core/FormFieldRegistry').default } formFieldRegistry
   */
  constructor(formFieldRegistry) {
    this._formFieldRegistry = formFieldRegistry;
  }
  execute(context) {
    const {
      claiming,
      formField,
      key
    } = context;
    if (claiming) {
      this._formFieldRegistry._keys.claim(key, formField);
    } else {
      this._formFieldRegistry._keys.unclaim(key);
    }
  }
  revert(context) {
    const {
      claiming,
      formField,
      key
    } = context;
    if (claiming) {
      this._formFieldRegistry._keys.unclaim(key);
    } else {
      this._formFieldRegistry._keys.claim(key, formField);
    }
  }
}
UpdateKeyClaimHandler.$inject = ['formFieldRegistry'];

class Modeling {
  constructor(commandStack, eventBus, formEditor, formFieldRegistry, fieldFactory) {
    this._commandStack = commandStack;
    this._formEditor = formEditor;
    this._formFieldRegistry = formFieldRegistry;
    this._fieldFactory = fieldFactory;
    eventBus.on('form.init', () => {
      this.registerHandlers();
    });
  }
  registerHandlers() {
    Object.entries(this.getHandlers()).forEach(([id, handler]) => {
      this._commandStack.registerHandler(id, handler);
    });
  }
  getHandlers() {
    return {
      'formField.add': AddFormFieldHandler,
      'formField.edit': EditFormFieldHandler,
      'formField.move': MoveFormFieldHandler,
      'formField.remove': RemoveFormFieldHandler,
      'id.updateClaim': UpdateIdClaimHandler,
      'key.updateClaim': UpdateKeyClaimHandler
    };
  }
  addFormField(attrs, targetFormField, targetIndex) {
    const formField = this._fieldFactory.create(attrs);
    const context = {
      formField,
      targetFormField,
      targetIndex
    };
    this._commandStack.execute('formField.add', context);
    return formField;
  }
  editFormField(formField, properties, value) {
    if (!minDash.isObject(properties)) {
      properties = {
        [properties]: value
      };
    }
    const context = {
      formField,
      properties
    };
    this._commandStack.execute('formField.edit', context);
  }
  moveFormField(formField, sourceFormField, targetFormField, sourceIndex, targetIndex) {
    const context = {
      formField,
      sourceFormField,
      targetFormField,
      sourceIndex,
      targetIndex
    };
    this._commandStack.execute('formField.move', context);
  }
  removeFormField(formField, sourceFormField, sourceIndex) {
    const context = {
      formField,
      sourceFormField,
      sourceIndex
    };
    this._commandStack.execute('formField.remove', context);
  }
  claimId(formField, id) {
    const context = {
      formField,
      id,
      claiming: true
    };
    this._commandStack.execute('id.updateClaim', context);
  }
  unclaimId(formField, id) {
    const context = {
      formField,
      id,
      claiming: false
    };
    this._commandStack.execute('id.updateClaim', context);
  }
  claimKey(formField, key) {
    const context = {
      formField,
      key,
      claiming: true
    };
    this._commandStack.execute('key.updateClaim', context);
  }
  unclaimKey(formField, key) {
    const context = {
      formField,
      key,
      claiming: false
    };
    this._commandStack.execute('key.updateClaim', context);
  }
}
Modeling.$inject = ['commandStack', 'eventBus', 'formEditor', 'formFieldRegistry', 'fieldFactory'];

var DEFAULT_PRIORITY = 1000;

/**
 * A utility that can be used to plug-in into the command execution for
 * extension and/or validation.
 *
 * @param {EventBus} eventBus
 *
 * @example
 *
 * import inherits from 'inherits-browser';
 *
 * import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';
 *
 * function CommandLogger(eventBus) {
 *   CommandInterceptor.call(this, eventBus);
 *
 *   this.preExecute(function(event) {
 *     console.log('command pre-execute', event);
 *   });
 * }
 *
 * inherits(CommandLogger, CommandInterceptor);
 *
 */
function CommandInterceptor(eventBus) {
  this._eventBus = eventBus;
}
CommandInterceptor.$inject = ['eventBus'];
function unwrapEvent(fn, that) {
  return function (event) {
    return fn.call(that || null, event.context, event.command, event);
  };
}

/**
 * Register an interceptor for a command execution
 *
 * @param {string|Array<string>} [events] list of commands to register on
 * @param {string} [hook] command hook, i.e. preExecute, executed to listen on
 * @param {number} [priority] the priority on which to hook into the execution
 * @param {Function} handlerFn interceptor to be invoked with (event)
 * @param {boolean} unwrap if true, unwrap the event and pass (context, command, event) to the
 *                          listener instead
 * @param {Object} [that] Pass context (`this`) to the handler function
 */
CommandInterceptor.prototype.on = function (events, hook, priority, handlerFn, unwrap, that) {
  if (minDash.isFunction(hook) || minDash.isNumber(hook)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = hook;
    hook = null;
  }
  if (minDash.isFunction(priority)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = DEFAULT_PRIORITY;
  }
  if (minDash.isObject(unwrap)) {
    that = unwrap;
    unwrap = false;
  }
  if (!minDash.isFunction(handlerFn)) {
    throw new Error('handlerFn must be a function');
  }
  if (!minDash.isArray(events)) {
    events = [events];
  }
  var eventBus = this._eventBus;
  minDash.forEach(events, function (event) {
    // concat commandStack(.event)?(.hook)?
    var fullEvent = ['commandStack', event, hook].filter(function (e) {
      return e;
    }).join('.');
    eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);
  });
};
var hooks = ['canExecute', 'preExecute', 'preExecuted', 'execute', 'executed', 'postExecute', 'postExecuted', 'revert', 'reverted'];

/*
 * Install hook shortcuts
 *
 * This will generate the CommandInterceptor#(preExecute|...|reverted) methods
 * which will in term forward to CommandInterceptor#on.
 */
minDash.forEach(hooks, function (hook) {
  /**
   * {canExecute|preExecute|preExecuted|execute|executed|postExecute|postExecuted|revert|reverted}
   *
   * A named hook for plugging into the command execution
   *
   * @param {string|Array<string>} [events] list of commands to register on
   * @param {number} [priority] the priority on which to hook into the execution
   * @param {Function} handlerFn interceptor to be invoked with (event)
   * @param {boolean} [unwrap=false] if true, unwrap the event and pass (context, command, event) to the
   *                          listener instead
   * @param {Object} [that] Pass context (`this`) to the handler function
   */
  CommandInterceptor.prototype[hook] = function (events, priority, handlerFn, unwrap, that) {
    if (minDash.isFunction(events) || minDash.isNumber(events)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = events;
      events = null;
    }
    this.on(events, hook, priority, handlerFn, unwrap, that);
  };
});

class IdBehavior extends CommandInterceptor {
  constructor(eventBus, modeling) {
    super(eventBus);

    // @ts-ignore-next-line
    this.preExecute('formField.remove', function (context) {
      const {
        formField
      } = context;
      const {
        id
      } = formField;
      modeling.unclaimId(formField, id);
    }, true);

    // @ts-ignore-next-line
    this.preExecute('formField.edit', function (context) {
      const {
        formField,
        properties
      } = context;
      if ('id' in properties) {
        modeling.unclaimId(formField, formField.id);
        modeling.claimId(formField, properties.id);
      }
    }, true);
  }
}
IdBehavior.$inject = ['eventBus', 'modeling'];

class KeyBehavior extends CommandInterceptor {
  constructor(eventBus, modeling) {
    super(eventBus);

    // @ts-ignore-next-line
    this.preExecute('formField.remove', function (context) {
      const {
        formField
      } = context;
      const {
        key
      } = formField;
      if (key) {
        modeling.unclaimKey(formField, key);
      }
    }, true);

    // @ts-ignore-next-line
    this.preExecute('formField.edit', function (context) {
      const {
        formField,
        properties
      } = context;
      if ('key' in properties) {
        modeling.unclaimKey(formField, formField.key);
        modeling.claimKey(formField, properties.key);
      }
    }, true);
  }
}
KeyBehavior.$inject = ['eventBus', 'modeling'];

class ValidateBehavior extends CommandInterceptor {
  constructor(eventBus) {
    super(eventBus);

    /**
     * Remove custom validation if <validationType> is about to be added.
     */
    // @ts-ignore-next-line
    this.preExecute('formField.edit', function (context) {
      const {
        properties
      } = context;
      const {
        validate = {}
      } = properties;
      if (validate.validationType) {
        const newValidate = {
          ...validate
        };
        delete newValidate.minLength;
        delete newValidate.maxLength;
        delete newValidate.pattern;
        properties['validate'] = newValidate;
      }
    }, true);
  }
}
ValidateBehavior.$inject = ['eventBus'];

var behaviorModule = {
  __init__: ['idBehavior', 'keyBehavior', 'validateBehavior'],
  idBehavior: ['type', IdBehavior],
  keyBehavior: ['type', KeyBehavior],
  validateBehavior: ['type', ValidateBehavior]
};

/**
 * A service that offers un- and redoable execution of commands.
 *
 * The command stack is responsible for executing modeling actions
 * in a un- and redoable manner. To do this it delegates the actual
 * command execution to {@link CommandHandler}s.
 *
 * Command handlers provide {@link CommandHandler#execute(ctx)} and
 * {@link CommandHandler#revert(ctx)} methods to un- and redo a command
 * identified by a command context.
 *
 *
 * ## Life-Cycle events
 *
 * In the process the command stack fires a number of life-cycle events
 * that other components to participate in the command execution.
 *
 *    * preExecute
 *    * preExecuted
 *    * execute
 *    * executed
 *    * postExecute
 *    * postExecuted
 *    * revert
 *    * reverted
 *
 * A special event is used for validating, whether a command can be
 * performed prior to its execution.
 *
 *    * canExecute
 *
 * Each of the events is fired as `commandStack.{eventName}` and
 * `commandStack.{commandName}.{eventName}`, respectively. This gives
 * components fine grained control on where to hook into.
 *
 * The event object fired transports `command`, the name of the
 * command and `context`, the command context.
 *
 *
 * ## Creating Command Handlers
 *
 * Command handlers should provide the {@link CommandHandler#execute(ctx)}
 * and {@link CommandHandler#revert(ctx)} methods to implement
 * redoing and undoing of a command.
 *
 * A command handler _must_ ensure undo is performed properly in order
 * not to break the undo chain. It must also return the shapes that
 * got changed during the `execute` and `revert` operations.
 *
 * Command handlers may execute other modeling operations (and thus
 * commands) in their `preExecute` and `postExecute` phases. The command
 * stack will properly group all commands together into a logical unit
 * that may be re- and undone atomically.
 *
 * Command handlers must not execute other commands from within their
 * core implementation (`execute`, `revert`).
 *
 *
 * ## Change Tracking
 *
 * During the execution of the CommandStack it will keep track of all
 * elements that have been touched during the command's execution.
 *
 * At the end of the CommandStack execution it will notify interested
 * components via an 'elements.changed' event with all the dirty
 * elements.
 *
 * The event can be picked up by components that are interested in the fact
 * that elements have been changed. One use case for this is updating
 * their graphical representation after moving / resizing or deletion.
 *
 * @see CommandHandler
 *
 * @param {EventBus} eventBus
 * @param {Injector} injector
 */
function CommandStack(eventBus, injector) {
  /**
   * A map of all registered command handlers.
   *
   * @type {Object}
   */
  this._handlerMap = {};

  /**
   * A stack containing all re/undoable actions on the diagram
   *
   * @type {Array<Object>}
   */
  this._stack = [];

  /**
   * The current index on the stack
   *
   * @type {number}
   */
  this._stackIdx = -1;

  /**
   * Current active commandStack execution
   *
   * @type {Object}
   * @property {Object[]} actions
   * @property {Object[]} dirty
   * @property { 'undo' | 'redo' | 'clear' | 'execute' | null } trigger the cause of the current excecution
   */
  this._currentExecution = {
    actions: [],
    dirty: [],
    trigger: null
  };
  this._injector = injector;
  this._eventBus = eventBus;
  this._uid = 1;
  eventBus.on(['diagram.destroy', 'diagram.clear'], function () {
    this.clear(false);
  }, this);
}
CommandStack.$inject = ['eventBus', 'injector'];

/**
 * Execute a command
 *
 * @param {string} command the command to execute
 * @param {Object} context the environment to execute the command in
 */
CommandStack.prototype.execute = function (command, context) {
  if (!command) {
    throw new Error('command required');
  }
  this._currentExecution.trigger = 'execute';
  const action = {
    command: command,
    context: context
  };
  this._pushAction(action);
  this._internalExecute(action);
  this._popAction(action);
};

/**
 * Ask whether a given command can be executed.
 *
 * Implementors may hook into the mechanism on two ways:
 *
 *   * in event listeners:
 *
 *     Users may prevent the execution via an event listener.
 *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.
 *
 *   * in command handlers:
 *
 *     If the method {@link CommandHandler#canExecute} is implemented in a handler
 *     it will be called to figure out whether the execution is allowed.
 *
 * @param  {string} command the command to execute
 * @param  {Object} context the environment to execute the command in
 *
 * @return {boolean} true if the command can be executed
 */
CommandStack.prototype.canExecute = function (command, context) {
  const action = {
    command: command,
    context: context
  };
  const handler = this._getHandler(command);
  let result = this._fire(command, 'canExecute', action);

  // handler#canExecute will only be called if no listener
  // decided on a result already
  if (result === undefined) {
    if (!handler) {
      return false;
    }
    if (handler.canExecute) {
      result = handler.canExecute(context);
    }
  }
  return result;
};

/**
 * Clear the command stack, erasing all undo / redo history
 */
CommandStack.prototype.clear = function (emit) {
  this._stack.length = 0;
  this._stackIdx = -1;
  if (emit !== false) {
    this._fire('changed', {
      trigger: 'clear'
    });
  }
};

/**
 * Undo last command(s)
 */
CommandStack.prototype.undo = function () {
  let action = this._getUndoAction(),
    next;
  if (action) {
    this._currentExecution.trigger = 'undo';
    this._pushAction(action);
    while (action) {
      this._internalUndo(action);
      next = this._getUndoAction();
      if (!next || next.id !== action.id) {
        break;
      }
      action = next;
    }
    this._popAction();
  }
};

/**
 * Redo last command(s)
 */
CommandStack.prototype.redo = function () {
  let action = this._getRedoAction(),
    next;
  if (action) {
    this._currentExecution.trigger = 'redo';
    this._pushAction(action);
    while (action) {
      this._internalExecute(action, true);
      next = this._getRedoAction();
      if (!next || next.id !== action.id) {
        break;
      }
      action = next;
    }
    this._popAction();
  }
};

/**
 * Register a handler instance with the command stack
 *
 * @param {string} command
 * @param {CommandHandler} handler
 */
CommandStack.prototype.register = function (command, handler) {
  this._setHandler(command, handler);
};

/**
 * Register a handler type with the command stack
 * by instantiating it and injecting its dependencies.
 *
 * @param {string} command
 * @param {Function} a constructor for a {@link CommandHandler}
 */
CommandStack.prototype.registerHandler = function (command, handlerCls) {
  if (!command || !handlerCls) {
    throw new Error('command and handlerCls must be defined');
  }
  const handler = this._injector.instantiate(handlerCls);
  this.register(command, handler);
};
CommandStack.prototype.canUndo = function () {
  return !!this._getUndoAction();
};
CommandStack.prototype.canRedo = function () {
  return !!this._getRedoAction();
};

// stack access  //////////////////////

CommandStack.prototype._getRedoAction = function () {
  return this._stack[this._stackIdx + 1];
};
CommandStack.prototype._getUndoAction = function () {
  return this._stack[this._stackIdx];
};

// internal functionality //////////////////////

CommandStack.prototype._internalUndo = function (action) {
  const command = action.command,
    context = action.context;
  const handler = this._getHandler(command);

  // guard against illegal nested command stack invocations
  this._atomicDo(() => {
    this._fire(command, 'revert', action);
    if (handler.revert) {
      this._markDirty(handler.revert(context));
    }
    this._revertedAction(action);
    this._fire(command, 'reverted', action);
  });
};
CommandStack.prototype._fire = function (command, qualifier, event) {
  if (arguments.length < 3) {
    event = qualifier;
    qualifier = null;
  }
  const names = qualifier ? [command + '.' + qualifier, qualifier] : [command];
  let result;
  event = this._eventBus.createEvent(event);
  for (const name of names) {
    result = this._eventBus.fire('commandStack.' + name, event);
    if (event.cancelBubble) {
      break;
    }
  }
  return result;
};
CommandStack.prototype._createId = function () {
  return this._uid++;
};
CommandStack.prototype._atomicDo = function (fn) {
  const execution = this._currentExecution;
  execution.atomic = true;
  try {
    fn();
  } finally {
    execution.atomic = false;
  }
};
CommandStack.prototype._internalExecute = function (action, redo) {
  const command = action.command,
    context = action.context;
  const handler = this._getHandler(command);
  if (!handler) {
    throw new Error('no command handler registered for <' + command + '>');
  }
  this._pushAction(action);
  if (!redo) {
    this._fire(command, 'preExecute', action);
    if (handler.preExecute) {
      handler.preExecute(context);
    }
    this._fire(command, 'preExecuted', action);
  }

  // guard against illegal nested command stack invocations
  this._atomicDo(() => {
    this._fire(command, 'execute', action);
    if (handler.execute) {
      // actual execute + mark return results as dirty
      this._markDirty(handler.execute(context));
    }

    // log to stack
    this._executedAction(action, redo);
    this._fire(command, 'executed', action);
  });
  if (!redo) {
    this._fire(command, 'postExecute', action);
    if (handler.postExecute) {
      handler.postExecute(context);
    }
    this._fire(command, 'postExecuted', action);
  }
  this._popAction(action);
};
CommandStack.prototype._pushAction = function (action) {
  const execution = this._currentExecution,
    actions = execution.actions;
  const baseAction = actions[0];
  if (execution.atomic) {
    throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');
  }
  if (!action.id) {
    action.id = baseAction && baseAction.id || this._createId();
  }
  actions.push(action);
};
CommandStack.prototype._popAction = function () {
  const execution = this._currentExecution,
    trigger = execution.trigger,
    actions = execution.actions,
    dirty = execution.dirty;
  actions.pop();
  if (!actions.length) {
    this._eventBus.fire('elements.changed', {
      elements: minDash.uniqueBy('id', dirty.reverse())
    });
    dirty.length = 0;
    this._fire('changed', {
      trigger: trigger
    });
    execution.trigger = null;
  }
};
CommandStack.prototype._markDirty = function (elements) {
  const execution = this._currentExecution;
  if (!elements) {
    return;
  }
  elements = minDash.isArray(elements) ? elements : [elements];
  execution.dirty = execution.dirty.concat(elements);
};
CommandStack.prototype._executedAction = function (action, redo) {
  const stackIdx = ++this._stackIdx;
  if (!redo) {
    this._stack.splice(stackIdx, this._stack.length, action);
  }
};
CommandStack.prototype._revertedAction = function (action) {
  this._stackIdx--;
};
CommandStack.prototype._getHandler = function (command) {
  return this._handlerMap[command];
};
CommandStack.prototype._setHandler = function (command, handler) {
  if (!command || !handler) {
    throw new Error('command and handler required');
  }
  if (this._handlerMap[command]) {
    throw new Error('overriding handler for command <' + command + '>');
  }
  this._handlerMap[command] = handler;
};

var commandModule = {
  commandStack: ['type', CommandStack]
};

var ModelingModule = {
  __depends__: [behaviorModule, commandModule],
  __init__: ['modeling'],
  modeling: ['type', Modeling]
};

class Selection {
  constructor(eventBus) {
    this._eventBus = eventBus;
    this._selection = null;
  }
  get() {
    return this._selection;
  }
  set(selection) {
    if (this._selection === selection) {
      return;
    }
    this._selection = selection;
    this._eventBus.fire('selection.changed', {
      selection: this._selection
    });
  }
  toggle(selection) {
    const newSelection = this._selection === selection ? null : selection;
    this.set(newSelection);
  }
  clear() {
    this.set(null);
  }
  isSelected(formField) {
    return this._selection === formField;
  }
}
Selection.$inject = ['eventBus'];

class SelectionBehavior {
  constructor(eventBus, selection) {
    eventBus.on(['commandStack.formField.add.postExecuted', 'commandStack.formField.move.postExecuted'], ({
      context
    }) => {
      const {
        formField
      } = context;
      selection.set(formField);
    });
    eventBus.on('commandStack.formField.remove.postExecuted', ({
      context
    }) => {
      const {
        sourceFormField,
        sourceIndex
      } = context;
      const formField = sourceFormField.components[sourceIndex] || sourceFormField.components[sourceIndex - 1];
      if (formField) {
        selection.set(formField);
      } else {
        selection.clear();
      }
    });
    eventBus.on('formField.remove', ({
      formField
    }) => {
      if (selection.isSelected(formField)) {
        selection.clear();
      }
    });
  }
}
SelectionBehavior.$inject = ['eventBus', 'selection'];

var SelectionModule = {
  __init__: ['selection', 'selectionBehavior'],
  selection: ['type', Selection],
  selectionBehavior: ['type', SelectionBehavior]
};

class PaletteRenderer {
  constructor(paletteConfig, eventBus) {
    const {
      parent
    } = paletteConfig || {};
    this._eventBus = eventBus;
    this._container = minDom.domify('<div class="fjs-palette-container"></div>');
    if (parent) {
      this.attachTo(parent);
    }
    this._eventBus.once('formEditor.rendered', 500, () => {
      this._render();
    });
  }

  /**
   * Attach the palette to a parent node.
   *
   * @param {HTMLElement} container
   */
  attachTo(container) {
    if (!container) {
      throw new Error('container required');
    }
    if (typeof container === 'string') {
      container = minDom.query(container);
    }

    // (1) detach from old parent
    this.detach();

    // (2) append to parent container
    container.appendChild(this._container);

    // (3) notify interested parties
    this._eventBus.fire('palette.attach');
  }

  /**
   * Detach the palette from its parent node.
   */
  detach() {
    const parentNode = this._container.parentNode;
    if (parentNode) {
      parentNode.removeChild(this._container);
      this._eventBus.fire('palette.detach');
    }
  }
  _render() {
    preact.render(jsxRuntime.jsx(Palette, {}), this._container);
    this._eventBus.fire('palette.rendered');
  }
  _destroy() {
    if (this._container) {
      preact.render(null, this._container);
      this._eventBus.fire('palette.destroyed');
    }
  }
}
PaletteRenderer.$inject = ['config.palette', 'eventBus'];

var PaletteModule = {
  palette: ['type', PaletteRenderer]
};

var ArrowIcon = function ArrowIcon(props) {
  return jsxRuntime.jsx("svg", {
    ...props,
    children: jsxRuntime.jsx("path", {
      fillRule: "evenodd",
      d: "m11.657 8-4.95 4.95a1 1 0 0 1-1.414-1.414L8.828 8 5.293 4.464A1 1 0 1 1 6.707 3.05L11.657 8Z"
    })
  });
};
ArrowIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};
var CreateIcon = function CreateIcon(props) {
  return jsxRuntime.jsx("svg", {
    ...props,
    children: jsxRuntime.jsx("path", {
      fillRule: "evenodd",
      d: "M9 13V9h4a1 1 0 0 0 0-2H9V3a1 1 0 1 0-2 0v4H3a1 1 0 1 0 0 2h4v4a1 1 0 0 0 2 0Z"
    })
  });
};
CreateIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};
var DeleteIcon = function DeleteIcon(props) {
  return jsxRuntime.jsx("svg", {
    ...props,
    children: jsxRuntime.jsx("path", {
      fillRule: "evenodd",
      d: "M12 6v7c0 1.1-.4 1.55-1.5 1.55h-5C4.4 14.55 4 14.1 4 13V6h8Zm-1.5 1.5h-5v4.3c0 .66.5 1.2 1.111 1.2H9.39c.611 0 1.111-.54 1.111-1.2V7.5ZM13 3h-2l-1-1H6L5 3H3v1.5h10V3Z"
    })
  });
};
DeleteIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};
var ExternalLinkIcon = function ExternalLinkIcon(props) {
  return jsxRuntime.jsx("svg", {
    ...props,
    children: jsxRuntime.jsx("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M12.637 12.637v-4.72h1.362v4.721c0 .36-.137.676-.411.95-.275.275-.591.412-.95.412H3.362c-.38 0-.703-.132-.967-.396A1.315 1.315 0 0 1 2 12.638V3.362c0-.38.132-.703.396-.967S2.982 2 3.363 2h4.553v1.363H3.363v9.274h9.274ZM14 2H9.28l-.001 1.362h2.408L5.065 9.984l.95.95 6.622-6.622v2.409H14V2Z",
      fill: "#818798"
    })
  });
};
ExternalLinkIcon.defaultProps = {
  width: "16",
  height: "16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
var FeelRequiredIcon = function FeelRequiredIcon(props) {
  return jsxRuntime.jsxs("svg", {
    ...props,
    children: [jsxRuntime.jsx("path", {
      d: "M5.8 7.06V5.95h4.307v1.11H5.8Zm0 3.071v-1.11h4.307v1.11H5.8Z",
      fill: "currentColor"
    }), jsxRuntime.jsx("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M8 3.268A4.732 4.732 0 1 0 12.732 8H14a6 6 0 1 1-6-6v1.268Z",
      fill: "currentColor"
    }), jsxRuntime.jsx("path", {
      d: "m11.28 6.072-.832-.56 1.016-1.224L10 3.848l.312-.912 1.392.584L11.632 2h1.032l-.072 1.52 1.392-.584.312.912-1.464.44 1.008 1.224-.832.552-.864-1.296-.864 1.304Z",
      fill: "currentColor"
    })]
  });
};
FeelRequiredIcon.defaultProps = {
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
var FeelOptionalIcon = function FeelOptionalIcon(props) {
  return jsxRuntime.jsxs("svg", {
    ...props,
    children: [jsxRuntime.jsx("path", {
      d: "M5.845 7.04V5.93h4.307v1.11H5.845Zm0 3.07V9h4.307v1.11H5.845Z",
      fill: "currentColor"
    }), jsxRuntime.jsx("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M3.286 8a4.714 4.714 0 1 0 9.428 0 4.714 4.714 0 0 0-9.428 0ZM8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z",
      fill: "currentColor"
    })]
  });
};
FeelOptionalIcon.defaultProps = {
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function Header(props) {
  const {
    element,
    headerProvider
  } = props;
  const {
    getElementIcon,
    getDocumentationRef,
    getElementLabel,
    getTypeLabel
  } = headerProvider;
  const label = getElementLabel(element);
  const type = getTypeLabel(element);
  const documentationRef = getDocumentationRef && getDocumentationRef(element);
  const ElementIcon = getElementIcon(element);
  return jsxRuntime.jsxs("div", {
    class: "bio-properties-panel-header",
    children: [jsxRuntime.jsx("div", {
      class: "bio-properties-panel-header-icon",
      children: ElementIcon && jsxRuntime.jsx(ElementIcon, {
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      })
    }), jsxRuntime.jsxs("div", {
      class: "bio-properties-panel-header-labels",
      children: [jsxRuntime.jsx("div", {
        title: type,
        class: "bio-properties-panel-header-type",
        children: type
      }), label ? jsxRuntime.jsx("div", {
        title: label,
        class: "bio-properties-panel-header-label",
        children: label
      }) : null]
    }), jsxRuntime.jsx("div", {
      class: "bio-properties-panel-header-actions",
      children: documentationRef ? jsxRuntime.jsx("a", {
        rel: "noopener",
        class: "bio-properties-panel-header-link",
        href: documentationRef,
        title: "Open documentation",
        target: "_blank",
        children: jsxRuntime.jsx(ExternalLinkIcon, {})
      }) : null
    })]
  });
}
const DescriptionContext = preact.createContext({
  description: {},
  getDescriptionForId: () => {}
});
const ErrorsContext = preact.createContext({
  errors: {}
});

/**
 * @typedef {Function} <propertiesPanel.showEntry> callback
 *
 * @example
 *
 * useEvent('propertiesPanel.showEntry', ({ focus = false, ...rest }) => {
 *   // ...
 * });
 *
 * @param {Object} context
 * @param {boolean} [context.focus]
 *
 * @returns void
 */
const EventContext = preact.createContext({
  eventBus: null
});
const LayoutContext = preact.createContext({
  layout: {},
  setLayout: () => {},
  getLayoutForKey: () => {},
  setLayoutForKey: () => {}
});

/**
 * Accesses the global DescriptionContext and returns a description for a given id and element.
 *
 * @example
 * ```jsx
 * function TextField(props) {
 *   const description = useDescriptionContext('input1', element);
 * }
 * ```
 *
 * @param {string} id
 * @param {object} element
 *
 * @returns {string}
 */
function useDescriptionContext(id, element) {
  const {
    getDescriptionForId
  } = hooks$1.useContext(DescriptionContext);
  return getDescriptionForId(id, element);
}
function useError(id) {
  const {
    errors
  } = hooks$1.useContext(ErrorsContext);
  return errors[id];
}

/**
 * Subscribe to an event immediately. Update subscription after inputs changed.
 *
 * @param {string} event
 * @param {Function} callback
 */
function useEvent(event, callback, eventBus) {
  const eventContext = hooks$1.useContext(EventContext);
  if (!eventBus) {
    ({
      eventBus
    } = eventContext);
  }
  const didMount = hooks$1.useRef(false);

  // (1) subscribe immediately
  if (eventBus && !didMount.current) {
    eventBus.on(event, callback);
  }

  // (2) update subscription after inputs changed
  hooks$1.useEffect(() => {
    if (eventBus && didMount.current) {
      eventBus.on(event, callback);
    }
    didMount.current = true;
    return () => {
      if (eventBus) {
        eventBus.off(event, callback);
      }
    };
  }, [callback, event, eventBus]);
}

/**
 * Creates a state that persists in the global LayoutContext.
 *
 * @example
 * ```jsx
 * function Group(props) {
 *   const [ open, setOpen ] = useLayoutState([ 'groups', 'foo', 'open' ], false);
 * }
 * ```
 *
 * @param {(string|number)[]} path
 * @param {any} [defaultValue]
 *
 * @returns {[ any, Function ]}
 */
function useLayoutState(path, defaultValue) {
  const {
    getLayoutForKey,
    setLayoutForKey
  } = hooks$1.useContext(LayoutContext);
  const layoutForKey = getLayoutForKey(path, defaultValue);
  const [value, set] = hooks$1.useState(layoutForKey);
  const setState = newValue => {
    // (1) set component state
    set(newValue);

    // (2) set context
    setLayoutForKey(path, newValue);
  };
  return [value, setState];
}

/**
 * @pinussilvestrus: we need to introduce our own hook to persist the previous
 * state on updates.
 *
 * cf. https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state
 */

function usePrevious(value) {
  const ref = hooks$1.useRef();
  hooks$1.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}

/**
 * Subscribe to `propertiesPanel.showEntry`.
 *
 * @param {string} id
 *
 * @returns {import('preact').Ref}
 */
function useShowEntryEvent(id) {
  const {
    onShow
  } = hooks$1.useContext(LayoutContext);
  const ref = hooks$1.useRef();
  const focus = hooks$1.useRef(false);
  const onShowEntry = hooks$1.useCallback(event => {
    if (event.id === id) {
      onShow();
      if (!focus.current) {
        focus.current = true;
      }
    }
  }, [id]);
  hooks$1.useEffect(() => {
    if (focus.current && ref.current) {
      if (minDash.isFunction(ref.current.focus)) {
        ref.current.focus();
      }
      if (minDash.isFunction(ref.current.select)) {
        ref.current.select();
      }
      focus.current = false;
    }
  });
  useEvent('propertiesPanel.showEntry', onShowEntry);
  return ref;
}

/**
 * @callback setSticky
 * @param {boolean} value
 */

/**
 * Use IntersectionObserver to identify when DOM element is in sticky mode.
 * If sticky is observered setSticky(true) will be called.
 * If sticky mode is left, setSticky(false) will be called.
 *
 *
 * @param {Object} ref
 * @param {string} scrollContainerSelector
 * @param {setSticky} setSticky
 */
function useStickyIntersectionObserver(ref, scrollContainerSelector, setSticky) {
  hooks$1.useEffect(() => {
    const Observer = IntersectionObserver;

    // return early if IntersectionObserver is not available
    if (!Observer) {
      return;
    }
    let observer;
    if (ref.current) {
      const scrollContainer = minDom.query(scrollContainerSelector);
      observer = new Observer(entries => {
        entries.forEach(entry => {
          if (entry.intersectionRatio < 1) {
            setSticky(true);
          } else if (entry.intersectionRatio === 1) {
            setSticky(false);
          }
        });
      }, {
        root: scrollContainer,
        rootMargin: '0px 0px 999999% 0px',
        // Use bottom margin to avoid stickyness when scrolling out to bottom
        threshold: [1]
      });
      observer.observe(ref.current);
    }

    // Unobserve if unmounted
    return () => {
      if (ref.current && observer) {
        observer.unobserve(ref.current);
      }
    };
  }, [ref, scrollContainerSelector, setSticky]);
}

/**
 * Creates a static function reference with changing body.
 * This is necessary when external libraries require a callback function
 * that has references to state variables.
 *
 * Usage:
 * const callback = useStaticCallback((val) => {val === currentState});
 *
 * The `callback` reference is static and can be safely used in external
 * libraries or as a prop that does not cause rerendering of children.
 *
 * @param {Function} callback function with changing reference
 * @returns {Function} static function reference
 */
function useStaticCallback(callback) {
  const callbackRef = hooks$1.useRef(callback);
  callbackRef.current = callback;
  return hooks$1.useCallback((...args) => callbackRef.current(...args), []);
}
function Group(props) {
  const {
    element,
    entries = [],
    id,
    label,
    shouldOpen = false
  } = props;
  const groupRef = hooks$1.useRef(null);
  const [open, setOpen] = useLayoutState(['groups', id, 'open'], shouldOpen);
  const onShow = hooks$1.useCallback(() => setOpen(true), [setOpen]);
  const toggleOpen = () => setOpen(!open);
  const [edited, setEdited] = hooks$1.useState(false);
  const [sticky, setSticky] = hooks$1.useState(false);

  // set edited state depending on all entries
  hooks$1.useEffect(() => {
    const hasOneEditedEntry = entries.find(entry => {
      const {
        id,
        isEdited
      } = entry;
      const entryNode = minDom.query(`[data-entry-id="${id}"]`);
      if (!minDash.isFunction(isEdited) || !entryNode) {
        return false;
      }
      const inputNode = minDom.query('.bio-properties-panel-input', entryNode);
      return isEdited(inputNode);
    });
    setEdited(hasOneEditedEntry);
  }, [entries]);

  // set css class when group is sticky to top
  useStickyIntersectionObserver(groupRef, 'div.bio-properties-panel-scroll-container', setSticky);
  const propertiesPanelContext = {
    ...hooks$1.useContext(LayoutContext),
    onShow
  };
  return jsxRuntime.jsxs("div", {
    class: "bio-properties-panel-group",
    "data-group-id": 'group-' + id,
    ref: groupRef,
    children: [jsxRuntime.jsxs("div", {
      class: classnames('bio-properties-panel-group-header', edited ? '' : 'empty', open ? 'open' : '', sticky && open ? 'sticky' : ''),
      onClick: toggleOpen,
      children: [jsxRuntime.jsx("div", {
        title: label,
        class: "bio-properties-panel-group-header-title",
        children: label
      }), jsxRuntime.jsxs("div", {
        class: "bio-properties-panel-group-header-buttons",
        children: [edited && jsxRuntime.jsx(DataMarker, {}), jsxRuntime.jsx("button", {
          title: "Toggle section",
          class: "bio-properties-panel-group-header-button bio-properties-panel-arrow",
          children: jsxRuntime.jsx(ArrowIcon, {
            class: open ? 'bio-properties-panel-arrow-down' : 'bio-properties-panel-arrow-right'
          })
        })]
      })]
    }), jsxRuntime.jsx("div", {
      class: classnames('bio-properties-panel-group-entries', open ? 'open' : ''),
      children: jsxRuntime.jsx(LayoutContext.Provider, {
        value: propertiesPanelContext,
        children: entries.map(entry => {
          const {
            component: Component,
            id
          } = entry;
          return preact.createElement(Component, {
            ...entry,
            element: element,
            key: id
          });
        })
      })
    })]
  });
}
function DataMarker() {
  return jsxRuntime.jsx("div", {
    title: "Section contains data",
    class: "bio-properties-panel-dot"
  });
}

/**
 * @typedef { {
 *  text: (element: object) => string,
 *  icon?: (element: Object) => import('preact').Component
 * } } PlaceholderDefinition
 *
 * @param { PlaceholderDefinition } props
 */
function Placeholder(props) {
  const {
    text,
    icon: Icon
  } = props;
  return jsxRuntime.jsx("div", {
    class: "bio-properties-panel open",
    children: jsxRuntime.jsxs("section", {
      class: "bio-properties-panel-placeholder",
      children: [Icon && jsxRuntime.jsx(Icon, {
        class: "bio-properties-panel-placeholder-icon"
      }), jsxRuntime.jsx("p", {
        class: "bio-properties-panel-placeholder-text",
        children: text
      })]
    })
  });
}
const DEFAULT_LAYOUT = {
  open: true
};
const DEFAULT_DESCRIPTION = {};

/**
 * @typedef { {
 *    component: import('preact').Component,
 *    id: String,
 *    isEdited?: Function
 * } } EntryDefinition
 *
 * @typedef { {
 *    autoFocusEntry: String,
 *    autoOpen?: Boolean,
 *    entries: Array<EntryDefinition>,
 *    id: String,
 *    label: String,
 *    remove: (event: MouseEvent) => void
 * } } ListItemDefinition
 *
 * @typedef { {
 *    add: (event: MouseEvent) => void,
 *    component: import('preact').Component,
 *    element: Object,
 *    id: String,
 *    items: Array<ListItemDefinition>,
 *    label: String,
 *    shouldSort?: Boolean,
 *    shouldOpen?: Boolean
 * } } ListGroupDefinition
 *
 * @typedef { {
 *    component?: import('preact').Component,
 *    entries: Array<EntryDefinition>,
 *    id: String,
 *    label: String,
 *    shouldOpen?: Boolean
 * } } GroupDefinition
 *
 *  @typedef { {
 *    [id: String]: GetDescriptionFunction
 * } } DescriptionConfig
 *
 * @callback { {
 * @param {string} id
 * @param {Object} element
 * @returns {string}
 * } } GetDescriptionFunction
 *
 * @typedef { {
 *  getEmpty: (element: object) => import('./components/Placeholder').PlaceholderDefinition,
 *  getMultiple: (element: Object) => import('./components/Placeholder').PlaceholderDefinition
 * } } PlaceholderProvider
 *
 */

/**
 * A basic properties panel component. Describes *how* content will be rendered, accepts
 * data from implementor to describe *what* will be rendered.
 *
 * @param {Object} props
 * @param {Object|Array} props.element
 * @param {import('./components/Header').HeaderProvider} props.headerProvider
 * @param {PlaceholderProvider} [props.placeholderProvider]
 * @param {Array<GroupDefinition|ListGroupDefinition>} props.groups
 * @param {Object} [props.layoutConfig]
 * @param {Function} [props.layoutChanged]
 * @param {DescriptionConfig} [props.descriptionConfig]
 * @param {Function} [props.descriptionLoaded]
 * @param {Object} [props.eventBus]
 */
function PropertiesPanel(props) {
  const {
    element,
    headerProvider,
    placeholderProvider,
    groups,
    layoutConfig = {},
    layoutChanged,
    descriptionConfig = {},
    descriptionLoaded,
    eventBus
  } = props;

  // set-up layout context
  const [layout, setLayout] = hooks$1.useState(createLayout(layoutConfig));
  hooks$1.useEffect(() => {
    if (typeof layoutChanged === 'function') {
      layoutChanged(layout);
    }
  }, [layout, layoutChanged]);
  const getLayoutForKey = (key, defaultValue) => {
    return minDash.get(layout, key, defaultValue);
  };
  const setLayoutForKey = (key, config) => {
    const newLayout = minDash.assign({}, layout);
    minDash.set(newLayout, key, config);
    setLayout(newLayout);
  };
  const layoutContext = {
    layout,
    setLayout,
    getLayoutForKey,
    setLayoutForKey
  };

  // set-up description context
  const description = createDescriptionContext(descriptionConfig);
  if (typeof descriptionLoaded === 'function') {
    descriptionLoaded(description);
  }
  const getDescriptionForId = (id, element) => {
    return description[id] && description[id](element);
  };
  const descriptionContext = {
    description,
    getDescriptionForId
  };
  const [errors, setErrors] = hooks$1.useState({});
  const onSetErrors = ({
    errors
  }) => setErrors(errors);
  useEvent('propertiesPanel.setErrors', onSetErrors, eventBus);
  const errorsContext = {
    errors
  };
  const eventContext = {
    eventBus
  };
  const propertiesPanelContext = {
    element
  };

  // empty state
  if (placeholderProvider && !element) {
    return jsxRuntime.jsx(Placeholder, {
      ...placeholderProvider.getEmpty()
    });
  }

  // multiple state
  if (placeholderProvider && minDash.isArray(element)) {
    return jsxRuntime.jsx(Placeholder, {
      ...placeholderProvider.getMultiple()
    });
  }
  return jsxRuntime.jsx(LayoutContext.Provider, {
    value: propertiesPanelContext,
    children: jsxRuntime.jsx(ErrorsContext.Provider, {
      value: errorsContext,
      children: jsxRuntime.jsx(DescriptionContext.Provider, {
        value: descriptionContext,
        children: jsxRuntime.jsx(LayoutContext.Provider, {
          value: layoutContext,
          children: jsxRuntime.jsx(EventContext.Provider, {
            value: eventContext,
            children: jsxRuntime.jsxs("div", {
              class: classnames('bio-properties-panel', layout.open ? 'open' : ''),
              children: [jsxRuntime.jsx(Header, {
                element: element,
                headerProvider: headerProvider
              }), jsxRuntime.jsx("div", {
                class: "bio-properties-panel-scroll-container",
                children: groups.map(group => {
                  const {
                    component: Component = Group,
                    id
                  } = group;
                  return preact.createElement(Component, {
                    ...group,
                    key: id,
                    element: element
                  });
                })
              })]
            })
          })
        })
      })
    })
  });
}

// helpers //////////////////

function createLayout(overrides) {
  return {
    ...DEFAULT_LAYOUT,
    ...overrides
  };
}
function createDescriptionContext(overrides) {
  return {
    ...DEFAULT_DESCRIPTION,
    ...overrides
  };
}
function CollapsibleEntry(props) {
  const {
    element,
    entries = [],
    id,
    label,
    open: shouldOpen,
    remove
  } = props;
  const [open, setOpen] = hooks$1.useState(shouldOpen);
  const toggleOpen = () => setOpen(!open);
  const {
    onShow
  } = hooks$1.useContext(LayoutContext);
  const propertiesPanelContext = {
    ...hooks$1.useContext(LayoutContext),
    onShow: hooks$1.useCallback(() => {
      setOpen(true);
      if (minDash.isFunction(onShow)) {
        onShow();
      }
    }, [onShow, setOpen])
  };

  // todo(pinussilvestrus): translate once we have a translate mechanism for the core
  const placeholderLabel = '<empty>';
  return jsxRuntime.jsxs("div", {
    "data-entry-id": id,
    class: classnames('bio-properties-panel-collapsible-entry', open ? 'open' : ''),
    children: [jsxRuntime.jsxs("div", {
      class: "bio-properties-panel-collapsible-entry-header",
      onClick: toggleOpen,
      children: [jsxRuntime.jsx("div", {
        title: label || placeholderLabel,
        class: classnames('bio-properties-panel-collapsible-entry-header-title', !label && 'empty'),
        children: label || placeholderLabel
      }), jsxRuntime.jsx("button", {
        title: "Toggle list item",
        class: "bio-properties-panel-arrow  bio-properties-panel-collapsible-entry-arrow",
        children: jsxRuntime.jsx(ArrowIcon, {
          class: open ? 'bio-properties-panel-arrow-down' : 'bio-properties-panel-arrow-right'
        })
      }), remove ? jsxRuntime.jsx("button", {
        title: "Delete item",
        class: "bio-properties-panel-remove-entry",
        onClick: remove,
        children: jsxRuntime.jsx(DeleteIcon, {})
      }) : null]
    }), jsxRuntime.jsx("div", {
      class: classnames('bio-properties-panel-collapsible-entry-entries', open ? 'open' : ''),
      children: jsxRuntime.jsx(LayoutContext.Provider, {
        value: propertiesPanelContext,
        children: entries.map(entry => {
          const {
            component: Component,
            id
          } = entry;
          return preact.createElement(Component, {
            ...entry,
            element: element,
            key: id
          });
        })
      })
    })]
  });
}
function ListItem(props) {
  const {
    autoFocusEntry,
    autoOpen
  } = props;

  // focus specified entry on auto open
  hooks$1.useEffect(() => {
    if (autoOpen && autoFocusEntry) {
      const entry = minDom.query(`[data-entry-id="${autoFocusEntry}"]`);
      const focusableInput = minDom.query('.bio-properties-panel-input', entry);
      if (focusableInput) {
        if (minDash.isFunction(focusableInput.select)) {
          focusableInput.select();
        } else if (minDash.isFunction(focusableInput.focus)) {
          focusableInput.focus();
        }
      }
    }
  }, [autoOpen, autoFocusEntry]);
  return jsxRuntime.jsx("div", {
    class: "bio-properties-panel-list-item",
    children: jsxRuntime.jsx(CollapsibleEntry, {
      ...props,
      open: autoOpen
    })
  });
}
const noop$2 = () => {};

/**
 * @param {import('../PropertiesPanel').ListGroupDefinition} props
 */
function ListGroup(props) {
  const {
    add,
    element,
    id,
    items,
    label,
    shouldOpen = true,
    shouldSort = true
  } = props;
  const groupRef = hooks$1.useRef(null);
  const [open, setOpen] = useLayoutState(['groups', id, 'open'], false);
  const [sticky, setSticky] = hooks$1.useState(false);
  const onShow = hooks$1.useCallback(() => setOpen(true), [setOpen]);
  const [ordering, setOrdering] = hooks$1.useState([]);
  const [newItemAdded, setNewItemAdded] = hooks$1.useState(false);
  const prevItems = usePrevious(items);
  const prevElement = usePrevious(element);
  const elementChanged = element !== prevElement;
  const shouldHandleEffects = !elementChanged && (shouldSort || shouldOpen);

  // reset initial ordering when element changes (before first render)
  if (elementChanged) {
    setOrdering(createOrdering(shouldSort ? sortItems(items) : items));
  }

  // keep ordering in sync to items - and open changes

  // (0) set initial ordering from given items
  hooks$1.useEffect(() => {
    if (!prevItems || !shouldSort) {
      setOrdering(createOrdering(items));
    }
  }, [items, element]);

  // (1) items were added
  hooks$1.useEffect(() => {
    if (shouldHandleEffects && prevItems && items.length > prevItems.length) {
      let add = [];
      items.forEach(item => {
        if (!ordering.includes(item.id)) {
          add.push(item.id);
        }
      });
      let newOrdering = ordering;

      // open if not open and configured
      if (!open && shouldOpen) {
        toggleOpen();

        // if I opened and I should sort, then sort items
        if (shouldSort) {
          newOrdering = createOrdering(sortItems(items));
        }
      }

      // add new items on top or bottom depending on sorting behavior
      newOrdering = newOrdering.filter(item => !add.includes(item));
      if (shouldSort) {
        newOrdering.unshift(...add);
      } else {
        newOrdering.push(...add);
      }
      setOrdering(newOrdering);
      setNewItemAdded(true);
    } else {
      setNewItemAdded(false);
    }
  }, [items, open, shouldHandleEffects]);

  // (2) sort items on open if shouldSort is set
  hooks$1.useEffect(() => {
    if (shouldSort && open && !newItemAdded) {
      setOrdering(createOrdering(sortItems(items)));
    }
  }, [open, shouldSort]);

  // (3) items were deleted
  hooks$1.useEffect(() => {
    if (shouldHandleEffects && prevItems && items.length < prevItems.length) {
      let keep = [];
      ordering.forEach(o => {
        if (getItem(items, o)) {
          keep.push(o);
        }
      });
      setOrdering(keep);
    }
  }, [items, shouldHandleEffects]);

  // set css class when group is sticky to top
  useStickyIntersectionObserver(groupRef, 'div.bio-properties-panel-scroll-container', setSticky);
  const toggleOpen = () => setOpen(!open);
  const hasItems = !!items.length;
  const propertiesPanelContext = {
    ...hooks$1.useContext(LayoutContext),
    onShow
  };
  return jsxRuntime.jsxs("div", {
    class: "bio-properties-panel-group",
    "data-group-id": 'group-' + id,
    ref: groupRef,
    children: [jsxRuntime.jsxs("div", {
      class: classnames('bio-properties-panel-group-header', hasItems ? '' : 'empty', hasItems && open ? 'open' : '', sticky && open ? 'sticky' : ''),
      onClick: hasItems ? toggleOpen : noop$2,
      children: [jsxRuntime.jsx("div", {
        title: label,
        class: "bio-properties-panel-group-header-title",
        children: label
      }), jsxRuntime.jsxs("div", {
        class: "bio-properties-panel-group-header-buttons",
        children: [add ? jsxRuntime.jsxs("button", {
          title: "Create new list item",
          class: "bio-properties-panel-group-header-button bio-properties-panel-add-entry",
          onClick: add,
          children: [jsxRuntime.jsx(CreateIcon, {}), !hasItems ? jsxRuntime.jsx("span", {
            class: "bio-properties-panel-add-entry-label",
            children: "Create"
          }) : null]
        }) : null, hasItems ? jsxRuntime.jsx("div", {
          title: `List contains ${items.length} item${items.length != 1 ? 's' : ''}`,
          class: "bio-properties-panel-list-badge",
          children: items.length
        }) : null, hasItems ? jsxRuntime.jsx("button", {
          title: "Toggle section",
          class: "bio-properties-panel-group-header-button bio-properties-panel-arrow",
          children: jsxRuntime.jsx(ArrowIcon, {
            class: open ? 'bio-properties-panel-arrow-down' : 'bio-properties-panel-arrow-right'
          })
        }) : null]
      })]
    }), jsxRuntime.jsx("div", {
      class: classnames('bio-properties-panel-list', open && hasItems ? 'open' : ''),
      children: jsxRuntime.jsx(LayoutContext.Provider, {
        value: propertiesPanelContext,
        children: ordering.map((o, index) => {
          const item = getItem(items, o);
          if (!item) {
            return;
          }
          const {
            id
          } = item;

          // if item was added, open first or last item based on ordering
          const autoOpen = newItemAdded && (shouldSort ? index === 0 : index === ordering.length - 1);
          return preact.createElement(ListItem, {
            ...item,
            autoOpen: autoOpen,
            element: element,
            index: index,
            key: id
          });
        })
      })
    })]
  });
}

// helpers ////////////////////

/**
 * Sorts given items alphanumeric by label
 */
function sortItems(items) {
  return minDash.sortBy(items, i => i.label.toLowerCase());
}
function getItem(items, id) {
  return minDash.find(items, i => i.id === id);
}
function createOrdering(items) {
  return items.map(i => i.id);
}
function Description$1(props) {
  const {
    element,
    forId,
    value
  } = props;
  const contextDescription = useDescriptionContext(forId, element);
  const description = value || contextDescription;
  if (description) {
    return jsxRuntime.jsx("div", {
      class: "bio-properties-panel-description",
      children: description
    });
  }
}
function Checkbox(props) {
  const {
    id,
    label,
    onChange,
    disabled,
    value = false,
    onFocus,
    onBlur
  } = props;
  const [localValue, setLocalValue] = hooks$1.useState(value);
  const handleChangeCallback = ({
    target
  }) => {
    onChange(target.checked);
  };
  const handleChange = e => {
    handleChangeCallback(e);
    setLocalValue(e.target.value);
  };
  hooks$1.useEffect(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  const ref = useShowEntryEvent(id);
  return jsxRuntime.jsxs("div", {
    class: "bio-properties-panel-checkbox",
    children: [jsxRuntime.jsx("input", {
      ref: ref,
      id: prefixId$7(id),
      name: id,
      onFocus: onFocus,
      onBlur: onBlur,
      type: "checkbox",
      class: "bio-properties-panel-input",
      onChange: handleChange,
      checked: localValue,
      disabled: disabled
    }), jsxRuntime.jsx("label", {
      for: prefixId$7(id),
      class: "bio-properties-panel-label",
      children: label
    })]
  });
}

/**
 * @param {Object} props
 * @param {Object} props.element
 * @param {String} props.id
 * @param {String} props.description
 * @param {String} props.label
 * @param {Function} props.getValue
 * @param {Function} props.setValue
 * @param {Function} props.onFocus
 * @param {Function} props.onBlur
 * @param {boolean} [props.disabled]
 */
function CheckboxEntry(props) {
  const {
    element,
    id,
    description,
    label,
    getValue,
    setValue,
    disabled,
    onFocus,
    onBlur
  } = props;
  const value = getValue(element);
  const error = useError(id);
  return jsxRuntime.jsxs("div", {
    class: "bio-properties-panel-entry bio-properties-panel-checkbox-entry",
    "data-entry-id": id,
    children: [jsxRuntime.jsx(Checkbox, {
      disabled: disabled,
      id: id,
      label: label,
      onChange: setValue,
      onFocus: onFocus,
      onBlur: onBlur,
      value: value
    }, element), error && jsxRuntime.jsx("div", {
      class: "bio-properties-panel-error",
      children: error
    }), jsxRuntime.jsx(Description$1, {
      forId: id,
      element: element,
      value: description
    })]
  });
}
function isEdited$7(node) {
  return node && !!node.checked;
}

// helpers /////////////////

function prefixId$7(id) {
  return `bio-properties-panel-${id}`;
}
const useBufferedFocus = function (editor, ref) {
  const [buffer, setBuffer] = hooks$1.useState(undefined);
  ref.current = hooks$1.useMemo(() => ({
    focus: offset => {
      if (editor) {
        editor.focus(offset);
      } else {
        if (typeof offset === 'undefined') {
          offset = Infinity;
        }
        setBuffer(offset);
      }
    }
  }), [editor]);
  hooks$1.useEffect(() => {
    if (typeof buffer !== 'undefined' && editor) {
      editor.focus(buffer);
      setBuffer(false);
    }
  }, [editor, buffer]);
};
const CodeEditor = React.forwardRef((props, ref) => {
  const {
    value,
    onInput,
    onFeelToggle,
    onLint = () => {},
    disabled,
    tooltipContainer,
    variables
  } = props;
  const inputRef = hooks$1.useRef();
  const [editor, setEditor] = hooks$1.useState();
  const [localValue, setLocalValue] = hooks$1.useState(value || '');
  useBufferedFocus(editor, ref);
  const handleInput = useStaticCallback(newValue => {
    onInput(newValue);
    setLocalValue(newValue);
  });
  hooks$1.useEffect(() => {
    let editor;

    /* Trigger FEEL toggle when
     *
     * - `backspace` is pressed
     * - AND the cursor is at the beginning of the input
     */
    const onKeyDown = e => {
      if (e.key !== 'Backspace' || !editor) {
        return;
      }
      const selection = editor.getSelection();
      const range = selection.ranges[selection.mainIndex];
      if (range.from === 0 && range.to === 0) {
        onFeelToggle();
      }
    };
    editor = new FeelEditor({
      container: inputRef.current,
      onChange: handleInput,
      onKeyDown: onKeyDown,
      onLint: onLint,
      tooltipContainer: tooltipContainer,
      value: localValue,
      variables: variables
    });
    setEditor(editor);
    return () => {
      onLint([]);
      inputRef.current.innerHTML = '';
      setEditor(null);
    };
  }, []);
  hooks$1.useEffect(() => {
    if (!editor) {
      return;
    }
    if (value === localValue) {
      return;
    }
    editor.setValue(value);
    setLocalValue(value);
  }, [value]);
  hooks$1.useEffect(() => {
    if (!editor) {
      return;
    }
    editor.setVariables(variables);
  }, [variables]);
  const handleClick = () => {
    ref.current.focus();
  };
  return jsxRuntime.jsx("div", {
    class: classnames('bio-properties-panel-feel-editor-container', disabled ? 'disabled' : null),
    children: jsxRuntime.jsx("div", {
      name: props.name,
      class: classnames('bio-properties-panel-input', localValue ? 'edited' : null),
      ref: inputRef,
      onClick: handleClick
    })
  });
});
function FeelIndicator(props) {
  const {
    active
  } = props;
  if (!active) {
    return null;
  }
  return jsxRuntime.jsx("span", {
    class: "bio-properties-panel-feel-indicator",
    children: "="
  });
}
const noop$1 = () => {};

/**
 * @param {Object} props
 * @param {Object} props.label
 * @param {String} props.feel
 */
function FeelIcon(props) {
  const {
    label,
    feel = false,
    active,
    disabled = false,
    onClick = noop$1
  } = props;
  const feelRequiredLabel = ' must be a FEEL expression';
  const feelOptionalLabel = ' can optionally be a FEEL expression';
  const handleClick = e => {
    onClick(e);

    // when pointer event was created from keyboard, keep focus on button
    if (!e.pointerType) {
      e.stopPropagation();
    }
  };
  return jsxRuntime.jsx("button", {
    class: classnames('bio-properties-panel-feel-icon', active ? 'active' : null, feel === 'required' ? 'required' : 'optional'),
    onClick: handleClick,
    disabled: feel === 'required' || disabled,
    title: label + (feel === 'required' ? feelRequiredLabel : feelOptionalLabel),
    children: feel === 'required' ? jsxRuntime.jsx(FeelRequiredIcon, {}) : jsxRuntime.jsx(FeelOptionalIcon, {})
  });
}
const noop = () => {};
function FeelTextfield(props) {
  const {
    debounce,
    id,
    label,
    onInput,
    onError,
    feel,
    value = '',
    disabled = false,
    variables,
    tooltipContainer,
    OptionalComponent = OptionalFeelInput
  } = props;
  const [localValue, _setLocalValue] = hooks$1.useState(value);
  const editorRef = useShowEntryEvent(id);
  const containerRef = hooks$1.useRef();
  const feelActive = localValue.startsWith('=') || feel === 'required';
  const feelOnlyValue = localValue.startsWith('=') ? localValue.substring(1) : localValue;
  const [focus, _setFocus] = hooks$1.useState(undefined);
  const setFocus = (offset = 0) => {
    const hasFocus = containerRef.current.contains(document.activeElement);

    // Keep caret position if it is already focused, otherwise focus at the end
    const position = hasFocus ? document.activeElement.selectionStart : Infinity;
    _setFocus(position + offset);
  };
  const handleInputCallback = hooks$1.useMemo(() => {
    return debounce(newValue => {
      onInput(newValue);
    });
  }, [onInput, debounce]);
  const setLocalValue = newValue => {
    _setLocalValue(newValue);
    if (!newValue || newValue === '=') {
      handleInputCallback(undefined);
    } else {
      handleInputCallback(newValue);
    }
  };
  const handleFeelToggle = useStaticCallback(() => {
    if (feel === 'required') {
      return;
    }
    if (!feelActive) {
      setLocalValue('=' + localValue);
    } else {
      setLocalValue(feelOnlyValue);
    }
  });
  const handleLocalInput = newValue => {
    if (feelActive) {
      newValue = '=' + newValue;
    }
    if (newValue === localValue) {
      return;
    }
    setLocalValue(newValue);
    if (!feelActive && newValue.startsWith('=')) {
      // focus is behind `=` sign that will be removed
      setFocus(-1);
    }
  };
  const handleLint = useStaticCallback(lint => {
    if (!(lint && lint.length)) {
      onError(undefined);
      return;
    }
    const error = lint[0];
    const message = `${error.source}: ${error.message}`;
    onError(message);
  });
  hooks$1.useEffect(() => {
    if (typeof focus !== 'undefined') {
      editorRef.current.focus(focus);
      _setFocus(undefined);
    }
  }, [focus]);
  hooks$1.useEffect(() => {
    if (value === localValue) {
      return;
    }

    // External value change removed content => keep FEEL configuration
    if (!value) {
      setLocalValue(feelActive ? '=' : '');
      return;
    }
    setLocalValue(value);
  }, [value]);

  // copy-paste integration
  hooks$1.useEffect(() => {
    const copyHandler = event => {
      if (!feelActive) {
        return;
      }
      event.clipboardData.setData('application/FEEL', event.clipboardData.getData('text'));
    };
    const pasteHandler = event => {
      if (feelActive) {
        return;
      }
      const data = event.clipboardData.getData('application/FEEL');
      if (data) {
        setTimeout(() => {
          handleFeelToggle();
          setFocus();
        });
      }
    };
    containerRef.current.addEventListener('copy', copyHandler);
    containerRef.current.addEventListener('cut', copyHandler);
    containerRef.current.addEventListener('paste', pasteHandler);
    return () => {
      containerRef.current.removeEventListener('copy', copyHandler);
      containerRef.current.removeEventListener('cut', copyHandler);
      containerRef.current.removeEventListener('paste', pasteHandler);
    };
  }, [containerRef, feelActive, handleFeelToggle, setFocus]);
  return jsxRuntime.jsxs("div", {
    class: "bio-properties-panel-feel-entry",
    children: [jsxRuntime.jsxs("label", {
      for: prefixId$6(id),
      class: "bio-properties-panel-label",
      onClick: () => setFocus(),
      children: [label, jsxRuntime.jsx(FeelIcon, {
        label: label,
        feel: feel,
        onClick: handleFeelToggle,
        active: feelActive
      })]
    }), jsxRuntime.jsxs("div", {
      class: "bio-properties-panel-feel-container",
      ref: containerRef,
      children: [jsxRuntime.jsx(FeelIndicator, {
        active: feelActive,
        disabled: feel !== 'optional' || disabled,
        onClick: handleFeelToggle
      }), feelActive ? jsxRuntime.jsx(CodeEditor, {
        id: prefixId$6(id),
        name: id,
        onInput: handleLocalInput,
        disabled: disabled,
        onFeelToggle: () => {
          handleFeelToggle();
          setFocus(true);
        },
        onLint: handleLint,
        value: feelOnlyValue,
        variables: variables,
        ref: editorRef,
        tooltipContainer: tooltipContainer
      }) : jsxRuntime.jsx(OptionalComponent, {
        ...props,
        onInput: handleLocalInput,
        value: localValue,
        ref: editorRef
      })]
    })]
  });
}
const OptionalFeelInput = React.forwardRef((props, ref) => {
  const {
    id,
    disabled,
    onInput,
    value,
    onFocus,
    onBlur
  } = props;
  const inputRef = hooks$1.useRef();

  // To be consistent with the FEEL editor, set focus at start of input
  // this ensures clean editing experience when switching with the keyboard
  ref.current = {
    focus: position => {
      const input = inputRef.current;
      if (!input) {
        return;
      }
      input.focus();
      if (typeof position === 'number') {
        if (position > value.length) {
          position = value.length;
        }
        input.setSelectionRange(position, position);
      }
    }
  };
  return jsxRuntime.jsx("input", {
    id: prefixId$6(id),
    type: "text",
    ref: inputRef,
    name: id,
    spellCheck: "false",
    autoComplete: "off",
    disabled: disabled,
    class: "bio-properties-panel-input",
    onInput: e => onInput(e.target.value),
    onFocus: onFocus,
    onBlur: onBlur,
    value: value || ''
  });
});
const OptionalFeelTextArea = React.forwardRef((props, ref) => {
  const {
    id,
    disabled,
    onInput,
    value,
    onFocus,
    onBlur
  } = props;
  const inputRef = hooks$1.useRef();

  // To be consistent with the FEEL editor, set focus at start of input
  // this ensures clean editing experience when switching with the keyboard
  ref.current = {
    focus: () => {
      const input = inputRef.current;
      if (!input) {
        return;
      }
      input.focus();
      input.setSelectionRange(0, 0);
    }
  };
  return jsxRuntime.jsx("textarea", {
    id: prefixId$6(id),
    type: "text",
    ref: inputRef,
    name: id,
    spellCheck: "false",
    autoComplete: "off",
    disabled: disabled,
    class: "bio-properties-panel-input",
    onInput: e => onInput(e.target.value),
    onFocus: onFocus,
    onBlur: onBlur,
    value: value || '',
    "data-gramm": "false"
  });
});

/**
 * @param {Object} props
 * @param {Object} props.element
 * @param {String} props.id
 * @param {String} props.description
 * @param {Boolean} props.debounce
 * @param {Boolean} props.disabled
 * @param {String} props.label
 * @param {Function} props.getValue
 * @param {Function} props.setValue
 * @param {Function} props.validate
 */
function FeelEntry(props) {
  const {
    element,
    id,
    description,
    debounce,
    disabled,
    feel,
    label,
    getValue,
    setValue,
    tooltipContainer,
    validate,
    show = noop,
    example,
    variables,
    onFocus,
    onBlur
  } = props;
  const [cachedInvalidValue, setCachedInvalidValue] = hooks$1.useState(null);
  const [validationError, setValidationError] = hooks$1.useState(null);
  const [localError, setLocalError] = hooks$1.useState(null);
  let value = getValue(element);
  const previousValue = usePrevious(value);
  hooks$1.useEffect(() => {
    if (minDash.isFunction(validate)) {
      const newValidationError = validate(value) || null;
      setValidationError(newValidationError);
    }
  }, [value]);
  const onInput = useStaticCallback(newValue => {
    let newValidationError = null;
    if (minDash.isFunction(validate)) {
      newValidationError = validate(newValue) || null;
    }
    if (newValidationError) {
      setCachedInvalidValue(newValue);
    } else {
      // don't create multiple commandStack entries for the same value
      if (newValue !== value) {
        setValue(newValue);
      }
    }
    setValidationError(newValidationError);
  });
  const onError = hooks$1.useCallback(err => {
    setLocalError(err);
  }, []);
  if (previousValue === value && validationError) {
    value = cachedInvalidValue;
  }
  const temporaryError = useError(id);
  const error = localError || temporaryError || validationError;
  return jsxRuntime.jsxs("div", {
    class: classnames(props.class, 'bio-properties-panel-entry', error ? 'has-error' : ''),
    "data-entry-id": id,
    children: [jsxRuntime.jsx(FeelTextfield, {
      debounce: debounce,
      disabled: disabled,
      feel: feel,
      id: id,
      label: label,
      onInput: onInput,
      onError: onError,
      onFocus: onFocus,
      onBlur: onBlur,
      example: example,
      show: show,
      value: value,
      variables: variables,
      tooltipContainer: tooltipContainer,
      OptionalComponent: props.OptionalComponent
    }, element), error && jsxRuntime.jsx("div", {
      class: "bio-properties-panel-error",
      children: error
    }), jsxRuntime.jsx(Description$1, {
      forId: id,
      element: element,
      value: description
    })]
  });
}

/**
 * @param {Object} props
 * @param {Object} props.element
 * @param {String} props.id
 * @param {String} props.description
 * @param {Boolean} props.debounce
 * @param {Boolean} props.disabled
 * @param {String} props.label
 * @param {Function} props.getValue
 * @param {Function} props.setValue
 * @param {Function} props.onFocus
 * @param {Function} props.onBlur
 * @param {Function} props.validate
 */
function FeelTextArea(props) {
  return jsxRuntime.jsx(FeelEntry, {
    class: "bio-properties-panel-feel-textarea",
    OptionalComponent: OptionalFeelTextArea,
    ...props
  });
}
function isEdited$6(node) {
  return node && (!!node.value || node.classList.contains('edited'));
}

// helpers /////////////////

function prefixId$6(id) {
  return `bio-properties-panel-${id}`;
}
function NumberField(props) {
  const {
    debounce,
    disabled,
    id,
    label,
    max,
    min,
    onInput,
    step,
    value = '',
    onFocus,
    onBlur
  } = props;
  const [localValue, setLocalValue] = hooks$1.useState(value);
  const handleInputCallback = hooks$1.useMemo(() => {
    return debounce(event => {
      const {
        validity,
        value
      } = event.target;
      if (validity.valid) {
        onInput(value ? parseFloat(value) : undefined);
      }
    });
  }, [onInput, debounce]);
  const handleInput = e => {
    handleInputCallback(e);
    setLocalValue(e.target.value);
  };
  hooks$1.useEffect(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return jsxRuntime.jsxs("div", {
    class: "bio-properties-panel-numberfield",
    children: [jsxRuntime.jsx("label", {
      for: prefixId$5(id),
      class: "bio-properties-panel-label",
      children: label
    }), jsxRuntime.jsx("input", {
      id: prefixId$5(id),
      type: "number",
      name: id,
      spellCheck: "false",
      autoComplete: "off",
      disabled: disabled,
      class: "bio-properties-panel-input",
      max: max,
      min: min,
      onInput: handleInput,
      onFocus: onFocus,
      onBlur: onBlur,
      step: step,
      value: localValue
    })]
  });
}

/**
 * @param {Object} props
 * @param {Boolean} props.debounce
 * @param {String} props.description
 * @param {Boolean} props.disabled
 * @param {Object} props.element
 * @param {Function} props.getValue
 * @param {String} props.id
 * @param {String} props.label
 * @param {String} props.max
 * @param {String} props.min
 * @param {Function} props.setValue
 * @param {Function} props.onFocus
 * @param {Function} props.onBlur
 * @param {String} props.step
 * @param {Function} props.validate
 */
function NumberFieldEntry(props) {
  const {
    debounce,
    description,
    disabled,
    element,
    getValue,
    id,
    label,
    max,
    min,
    setValue,
    step,
    onFocus,
    onBlur,
    validate
  } = props;
  const [cachedInvalidValue, setCachedInvalidValue] = hooks$1.useState(null);
  const globalError = useError(id);
  const [localError, setLocalError] = hooks$1.useState(null);
  let value = getValue(element);
  const previousValue = usePrevious(value);
  hooks$1.useEffect(() => {
    if (minDash.isFunction(validate)) {
      const newValidationError = validate(value) || null;
      setLocalError(newValidationError);
    }
  }, [value]);
  const onInput = newValue => {
    let newValidationError = null;
    if (minDash.isFunction(validate)) {
      newValidationError = validate(newValue) || null;
    }
    if (newValidationError) {
      setCachedInvalidValue(newValue);
    } else {
      setValue(newValue);
    }
    setLocalError(newValidationError);
  };
  if (previousValue === value && localError) {
    value = cachedInvalidValue;
  }
  const error = globalError || localError;
  return jsxRuntime.jsxs("div", {
    class: classnames('bio-properties-panel-entry', error ? 'has-error' : ''),
    "data-entry-id": id,
    children: [jsxRuntime.jsx(NumberField, {
      debounce: debounce,
      disabled: disabled,
      id: id,
      label: label,
      onFocus: onFocus,
      onBlur: onBlur,
      onInput: onInput,
      max: max,
      min: min,
      step: step,
      value: value
    }, element), error && jsxRuntime.jsx("div", {
      class: "bio-properties-panel-error",
      children: error
    }), jsxRuntime.jsx(Description$1, {
      forId: id,
      element: element,
      value: description
    })]
  });
}
function isEdited$5(node) {
  return node && !!node.value;
}

// helpers /////////////////

function prefixId$5(id) {
  return `bio-properties-panel-${id}`;
}
function Select(props) {
  const {
    id,
    label,
    onChange,
    options = [],
    value = '',
    disabled,
    onFocus,
    onBlur
  } = props;
  const ref = useShowEntryEvent(id);
  const [localValue, setLocalValue] = hooks$1.useState(value);
  const handleChangeCallback = ({
    target
  }) => {
    onChange(target.value);
  };
  const handleChange = e => {
    handleChangeCallback(e);
    setLocalValue(e.target.value);
  };
  hooks$1.useEffect(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return jsxRuntime.jsxs("div", {
    class: "bio-properties-panel-select",
    children: [jsxRuntime.jsx("label", {
      for: prefixId$4(id),
      class: "bio-properties-panel-label",
      children: label
    }), jsxRuntime.jsx("select", {
      ref: ref,
      id: prefixId$4(id),
      name: id,
      class: "bio-properties-panel-input",
      onInput: handleChange,
      onFocus: onFocus,
      onBlur: onBlur,
      value: localValue,
      disabled: disabled,
      children: options.map((option, idx) => {
        return jsxRuntime.jsx("option", {
          value: option.value,
          disabled: option.disabled,
          children: option.label
        }, idx);
      })
    })]
  });
}

/**
 * @param {object} props
 * @param {object} props.element
 * @param {string} props.id
 * @param {string} [props.description]
 * @param {string} props.label
 * @param {Function} props.getValue
 * @param {Function} props.setValue
 * @param {Function} props.onFocus
 * @param {Function} props.onBlur
 * @param {Function} props.getOptions
 * @param {boolean} [props.disabled]
 */
function SelectEntry(props) {
  const {
    element,
    id,
    description,
    label,
    getValue,
    setValue,
    getOptions,
    disabled,
    onFocus,
    onBlur
  } = props;
  const value = getValue(element);
  const options = getOptions(element);
  const error = useError(id);
  return jsxRuntime.jsxs("div", {
    class: classnames('bio-properties-panel-entry', error ? 'has-error' : ''),
    "data-entry-id": id,
    children: [jsxRuntime.jsx(Select, {
      id: id,
      label: label,
      value: value,
      onChange: setValue,
      onFocus: onFocus,
      onBlur: onBlur,
      options: options,
      disabled: disabled
    }, element), error && jsxRuntime.jsx("div", {
      class: "bio-properties-panel-error",
      children: error
    }), jsxRuntime.jsx(Description$1, {
      forId: id,
      element: element,
      value: description
    })]
  });
}
function isEdited$4(node) {
  return node && !!node.value;
}

// helpers /////////////////

function prefixId$4(id) {
  return `bio-properties-panel-${id}`;
}
function TextArea(props) {
  const {
    id,
    label,
    rows = 2,
    debounce,
    onInput,
    value = '',
    disabled,
    monospace,
    onFocus,
    onBlur
  } = props;
  const [localValue, setLocalValue] = hooks$1.useState(value);
  const ref = useShowEntryEvent(id);
  const handleInputCallback = hooks$1.useMemo(() => {
    return debounce(({
      target
    }) => onInput(target.value.length ? target.value : undefined));
  }, [onInput, debounce]);
  const handleInput = e => {
    handleInputCallback(e);
    setLocalValue(e.target.value);
  };
  hooks$1.useEffect(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return jsxRuntime.jsxs("div", {
    class: "bio-properties-panel-textarea",
    children: [jsxRuntime.jsx("label", {
      for: prefixId$2(id),
      class: "bio-properties-panel-label",
      children: label
    }), jsxRuntime.jsx("textarea", {
      ref: ref,
      id: prefixId$2(id),
      name: id,
      spellCheck: "false",
      class: classnames('bio-properties-panel-input', monospace ? 'bio-properties-panel-input-monospace' : ''),
      onInput: handleInput,
      onFocus: onFocus,
      onBlur: onBlur,
      rows: rows,
      value: localValue,
      disabled: disabled,
      "data-gramm": "false"
    })]
  });
}

/**
 * @param {object} props
 * @param {object} props.element
 * @param {string} props.id
 * @param {string} props.description
 * @param {boolean} props.debounce
 * @param {string} props.label
 * @param {Function} props.getValue
 * @param {Function} props.setValue
 * @param {Function} props.onFocus
 * @param {Function} props.onBlur
 * @param {number} props.rows
 * @param {boolean} props.monospace
 * @param {boolean} [props.disabled]
 */
function TextAreaEntry(props) {
  const {
    element,
    id,
    description,
    debounce,
    label,
    getValue,
    setValue,
    rows,
    monospace,
    disabled,
    onFocus,
    onBlur
  } = props;
  const value = getValue(element);
  const error = useError(id);
  return jsxRuntime.jsxs("div", {
    class: classnames('bio-properties-panel-entry', error ? 'has-error' : ''),
    "data-entry-id": id,
    children: [jsxRuntime.jsx(TextArea, {
      id: id,
      label: label,
      value: value,
      onInput: setValue,
      onFocus: onFocus,
      onBlur: onBlur,
      rows: rows,
      debounce: debounce,
      monospace: monospace,
      disabled: disabled
    }, element), error && jsxRuntime.jsx("div", {
      class: "bio-properties-panel-error",
      children: error
    }), jsxRuntime.jsx(Description$1, {
      forId: id,
      element: element,
      value: description
    })]
  });
}
function isEdited$2(node) {
  return node && !!node.value;
}

// helpers /////////////////

function prefixId$2(id) {
  return `bio-properties-panel-${id}`;
}
function Textfield(props) {
  const {
    debounce,
    disabled = false,
    id,
    label,
    onInput,
    onFocus,
    onBlur,
    value = ''
  } = props;
  const [localValue, setLocalValue] = hooks$1.useState(value || '');
  const ref = useShowEntryEvent(id);
  const handleInputCallback = hooks$1.useMemo(() => {
    return debounce(({
      target
    }) => onInput(target.value.length ? target.value : undefined));
  }, [onInput, debounce]);
  const handleInput = e => {
    handleInputCallback(e);
    setLocalValue(e.target.value);
  };
  hooks$1.useEffect(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return jsxRuntime.jsxs("div", {
    class: "bio-properties-panel-textfield",
    children: [jsxRuntime.jsx("label", {
      for: prefixId$1(id),
      class: "bio-properties-panel-label",
      children: label
    }), jsxRuntime.jsx("input", {
      ref: ref,
      id: prefixId$1(id),
      type: "text",
      name: id,
      spellCheck: "false",
      autoComplete: "off",
      disabled: disabled,
      class: "bio-properties-panel-input",
      onInput: handleInput,
      onFocus: onFocus,
      onBlur: onBlur,
      value: localValue
    })]
  });
}

/**
 * @param {Object} props
 * @param {Object} props.element
 * @param {String} props.id
 * @param {String} props.description
 * @param {Boolean} props.debounce
 * @param {Boolean} props.disabled
 * @param {String} props.label
 * @param {Function} props.getValue
 * @param {Function} props.setValue
 * @param {Function} props.onFocus
 * @param {Function} props.onBlur
 * @param {Function} props.validate
 */
function TextfieldEntry(props) {
  const {
    element,
    id,
    description,
    debounce,
    disabled,
    label,
    getValue,
    setValue,
    validate,
    onFocus,
    onBlur
  } = props;
  const [cachedInvalidValue, setCachedInvalidValue] = hooks$1.useState(null);
  const globalError = useError(id);
  const [localError, setLocalError] = hooks$1.useState(null);
  let value = getValue(element);
  const previousValue = usePrevious(value);
  hooks$1.useEffect(() => {
    if (minDash.isFunction(validate)) {
      const newValidationError = validate(value) || null;
      setLocalError(newValidationError);
    }
  }, [value]);
  const onInput = newValue => {
    let newValidationError = null;
    if (minDash.isFunction(validate)) {
      newValidationError = validate(newValue) || null;
    }
    if (newValidationError) {
      setCachedInvalidValue(newValue);
    } else {
      setValue(newValue);
    }
    setLocalError(newValidationError);
  };
  if (previousValue === value && localError) {
    value = cachedInvalidValue;
  }
  const error = globalError || localError;
  return jsxRuntime.jsxs("div", {
    class: classnames('bio-properties-panel-entry', error ? 'has-error' : ''),
    "data-entry-id": id,
    children: [jsxRuntime.jsx(Textfield, {
      debounce: debounce,
      disabled: disabled,
      id: id,
      label: label,
      onInput: onInput,
      onFocus: onFocus,
      onBlur: onBlur,
      value: value
    }, element), error && jsxRuntime.jsx("div", {
      class: "bio-properties-panel-error",
      children: error
    }), jsxRuntime.jsx(Description$1, {
      forId: id,
      element: element,
      value: description
    })]
  });
}
function isEdited$1(node) {
  return node && !!node.value;
}

// helpers /////////////////

function prefixId$1(id) {
  return `bio-properties-panel-${id}`;
}

/**
 * @param {string} type
 * @param {boolean} [strict]
 *
 * @returns {any}
 */
function getService(type, strict) {}
const PropertiesPanelContext = preact.createContext({
  getService
});
var FormPropertiesPanelContext = PropertiesPanelContext;

function arrayAdd(array, index, item) {
  const copy = [...array];
  copy.splice(index, 0, item);
  return copy;
}
function countDecimals(number) {
  const num = Big(number);
  if (num.toString() === num.toFixed(0)) return 0;
  return num.toFixed().split('.')[1].length || 0;
}
function isValidNumber(value) {
  return (typeof value === 'number' || typeof value === 'string') && value !== '' && !isNaN(Number(value));
}
function textToLabel(text) {
  if (typeof text != 'string') return null;
  for (const line of text.split('\n')) {
    const displayLine = line.trim();

    // we use the first non-whitespace line in the text as label
    if (displayLine !== '') {
      return displayLine;
    }
  }
  return null;
}
const INPUTS = ['checkbox', 'checklist', 'datetime', 'number', 'radio', 'select', 'taglist', 'textfield', 'textarea'];
const VALUES_INPUTS = ['checklist', 'radio', 'select', 'taglist'];

const labelsByType = {
  button: 'BUTTON',
  checkbox: 'CHECKBOX',
  checklist: 'CHECKLIST',
  columns: 'COLUMNS',
  default: 'FORM',
  datetime: 'DATETIME',
  image: 'IMAGE VIEW',
  number: 'NUMBER',
  radio: 'RADIO',
  select: 'SELECT',
  taglist: 'TAGLIST',
  text: 'TEXT VIEW',
  textfield: 'TEXT FIELD',
  textarea: 'TEXT AREA'
};
const PropertiesPanelHeaderProvider = {
  getElementLabel: field => {
    const {
      type
    } = field;
    if (type === 'text') {
      return textToLabel(field.text);
    }
    if (type === 'image') {
      return field.alt;
    }
    if (type === 'default') {
      return field.id;
    }
    return field.label;
  },
  getElementIcon: field => {
    const {
      type
    } = field;
    const Icon = formJsViewer.iconsByType(type);
    if (Icon) {
      return () => jsxRuntime.jsx(Icon, {
        width: "36",
        height: "36",
        viewBox: "0 0 54 54"
      });
    }
  },
  getTypeLabel: field => {
    const {
      type
    } = field;
    return labelsByType[type];
  }
};

/**
 * Provide placeholders for empty and multiple state.
 */
const PropertiesPanelPlaceholderProvider = {
  getEmpty: () => {
    return {
      text: 'Select a form field to edit its properties.'
    };
  },
  getMultiple: () => {
    return {
      text: 'Multiple form fields are selected. Select a single form field to edit its properties.'
    };
  }
};

function ActionEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];
  if (type === 'button') {
    entries.push({
      id: 'action',
      component: Action,
      editField: editField,
      field: field,
      isEdited: isEdited$4
    });
  }
  return entries;
}
function Action(props) {
  const {
    editField,
    field,
    id
  } = props;
  const path = ['action'];
  const getValue = () => {
    return minDash.get(field, path, '');
  };
  const setValue = value => {
    return editField(field, path, value);
  };
  const getOptions = () => [{
    label: 'Submit',
    value: 'submit'
  }, {
    label: 'Reset',
    value: 'reset'
  }];
  return SelectEntry({
    element: field,
    getOptions,
    getValue,
    id,
    label: 'Action',
    setValue
  });
}

function useService (type, strict) {
  const {
    getService
  } = hooks$1.useContext(FormPropertiesPanelContext);
  return getService(type, strict);
}

/**
 * Retrieve list of variables from the form schema.
 *
 * @returns { string[] } list of variables used in form schema
 */
function useVariables() {
  const form = useService('formEditor');
  const schema = form.getSchema();
  return formJsViewer.getSchemaVariables(schema);
}

function AltTextEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];
  if (type === 'image') {
    entries.push({
      id: 'alt',
      component: AltText,
      editField: editField,
      field: field,
      isEdited: isEdited$6
    });
  }
  return entries;
}
function AltText(props) {
  const {
    editField,
    field,
    id
  } = props;
  const debounce = useService('debounce');
  const variables = useVariables().map(name => ({
    name
  }));
  const path = ['alt'];
  const getValue = () => {
    return minDash.get(field, path, '');
  };
  const setValue = value => {
    return editField(field, path, value);
  };
  return FeelEntry({
    debounce,
    element: field,
    feel: 'optional',
    getValue,
    id,
    label: 'Alternative text',
    setValue,
    variables
  });
}

function ColumnsEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];
  if (type === 'columns') {
    entries.push({
      id: 'columns',
      component: Columns,
      editField: editField,
      field: field,
      isEdited: isEdited$5
    });
  }
  return entries;
}
function Columns(props) {
  const {
    editField,
    field,
    id
  } = props;
  const debounce = useService('debounce');
  const getValue = () => {
    return field.components.length;
  };
  const setValue = value => {
    let components = field.components.slice();
    if (value > components.length) {
      while (value > components.length) {
        components.push(formJsViewer.Default.create({
          _parent: field.id
        }));
      }
    } else {
      components = components.slice(0, value);
    }
    editField(field, 'components', components);
  };
  return NumberFieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label: 'Columns',
    setValue
  });
}

function DescriptionEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];
  if (INPUTS.includes(type)) {
    entries.push({
      id: 'description',
      component: Description,
      editField: editField,
      field: field,
      isEdited: isEdited$1
    });
  }
  return entries;
}
function Description(props) {
  const {
    editField,
    field,
    id
  } = props;
  const debounce = useService('debounce');
  const path = ['description'];
  const getValue = () => {
    return minDash.get(field, path, '');
  };
  const setValue = value => {
    return editField(field, path, value);
  };
  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label: 'Field description',
    setValue
  });
}

const EMPTY_OPTION = null;
function DefaultOptionEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];

  // Only make default values available when they are statically defined
  if (!INPUTS.includes(type) || VALUES_INPUTS.includes(type) && !field.values) {
    return entries;
  }
  const defaultOptions = {
    editField,
    field,
    id: 'defaultValue',
    label: 'Default value'
  };
  if (type === 'checkbox') {
    entries.push({
      ...defaultOptions,
      component: DefaultValueCheckbox,
      isEdited: isEdited$4
    });
  }
  if (type === 'number') {
    entries.push({
      ...defaultOptions,
      component: DefaultValueNumber,
      isEdited: isEdited$1
    });
  }
  if (type === 'radio' || type === 'select') {
    entries.push({
      ...defaultOptions,
      component: DefaultValueSingleSelect,
      isEdited: isEdited$4
    });
  }

  // todo(Skaiir): implement a multiselect equivalent (cf. https://github.com/bpmn-io/form-js/issues/265)

  if (type === 'textfield') {
    entries.push({
      ...defaultOptions,
      component: DefaultValueTextfield,
      isEdited: isEdited$1
    });
  }
  if (type === 'textarea') {
    entries.push({
      ...defaultOptions,
      component: DefaultValueTextarea,
      isEdited: isEdited$2
    });
  }
  return entries;
}
function DefaultValueCheckbox(props) {
  const {
    editField,
    field,
    id,
    label
  } = props;
  const {
    defaultValue
  } = field;
  const path = ['defaultValue'];
  const getOptions = () => {
    return [{
      label: 'Checked',
      value: 'true'
    }, {
      label: 'Not checked',
      value: 'false'
    }];
  };
  const setValue = value => {
    return editField(field, path, parseStringToBoolean(value));
  };
  const getValue = () => {
    return parseBooleanToString(defaultValue);
  };
  return SelectEntry({
    element: field,
    getOptions,
    getValue,
    id,
    label,
    setValue
  });
}
function DefaultValueNumber(props) {
  const {
    editField,
    field,
    id,
    label
  } = props;
  const {
    decimalDigits,
    serializeToString = false
  } = field;
  const debounce = useService('debounce');
  const path = ['defaultValue'];
  const getValue = e => {
    let value = minDash.get(field, path);
    if (!isValidNumber(value)) return;

    // Enforces decimal notation so that we do not submit defaults in exponent form
    return serializeToString ? Big(value).toFixed() : value;
  };
  const setValue = value => {
    let newValue;
    if (isValidNumber(value)) {
      newValue = serializeToString ? value : Number(value);
    }
    return editField(field, path, newValue);
  };
  const decimalDigitsSet = decimalDigits || decimalDigits === 0;
  return TextfieldEntry({
    debounce,
    label,
    element: field,
    getValue,
    id,
    setValue,
    validate: value => {
      if (value === undefined || value === null) return;
      if (!isValidNumber(value)) return 'Should be a valid number';
      if (decimalDigitsSet && countDecimals(value) > decimalDigits) return `Should not contain more than ${decimalDigits} decimal digits`;
    }
  });
}
function DefaultValueSingleSelect(props) {
  const {
    editField,
    field,
    id,
    label
  } = props;
  const {
    defaultValue = EMPTY_OPTION,
    values = []
  } = field;
  const path = ['defaultValue'];
  const getOptions = () => {
    return [{
      label: '<none>',
      value: EMPTY_OPTION
    }, ...values];
  };
  const setValue = value => {
    return editField(field, path, value.length ? value : undefined);
  };
  const getValue = () => {
    return defaultValue;
  };
  return SelectEntry({
    element: field,
    getOptions,
    getValue,
    id,
    label,
    setValue
  });
}
function DefaultValueTextfield(props) {
  const {
    editField,
    field,
    id,
    label
  } = props;
  const debounce = useService('debounce');
  const path = ['defaultValue'];
  const getValue = () => {
    return minDash.get(field, path, '');
  };
  const setValue = value => {
    return editField(field, path, value);
  };
  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label,
    setValue
  });
}
function DefaultValueTextarea(props) {
  const {
    editField,
    field,
    id,
    label
  } = props;
  const debounce = useService('debounce');
  const path = ['defaultValue'];
  const getValue = () => {
    return minDash.get(field, path, '');
  };
  const setValue = value => {
    return editField(field, path, value);
  };
  return TextAreaEntry({
    debounce,
    element: field,
    getValue,
    id,
    label,
    setValue
  });
}

// helpers /////////////////

function parseStringToBoolean(value) {
  if (value === 'true') {
    return true;
  }
  return false;
}
function parseBooleanToString(value) {
  if (value === true) {
    return 'true';
  }
  return 'false';
}

function DisabledEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];
  if (INPUTS.includes(type)) {
    entries.push({
      id: 'disabled',
      component: Disabled,
      editField: editField,
      field: field,
      isEdited: isEdited$7
    });
  }
  return entries;
}
function Disabled(props) {
  const {
    editField,
    field,
    id
  } = props;
  const path = ['disabled'];
  const getValue = () => {
    return minDash.get(field, path, '');
  };
  const setValue = value => {
    return editField(field, path, value);
  };
  return CheckboxEntry({
    element: field,
    getValue,
    id,
    label: 'Disabled',
    setValue
  });
}

function IdEntry(props) {
  const {
    editField,
    field
  } = props;
  const entries = [];
  if (field.type === 'default') {
    entries.push({
      id: 'id',
      component: Id,
      editField: editField,
      field: field,
      isEdited: isEdited$1
    });
  }
  return entries;
}
function Id(props) {
  const {
    editField,
    field,
    id
  } = props;
  const formFieldRegistry = useService('formFieldRegistry');
  const debounce = useService('debounce');
  const path = ['id'];
  const getValue = () => {
    return minDash.get(field, path, '');
  };
  const setValue = value => {
    return editField(field, path, value);
  };
  const validate = value => {
    if (minDash.isUndefined(value) || !value.length) {
      return 'Must not be empty.';
    }
    const assigned = formFieldRegistry._ids.assigned(value);
    if (assigned && assigned !== field) {
      return 'Must be unique.';
    }
    return validateId(value) || null;
  };
  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label: 'ID',
    setValue,
    validate
  });
}

// id structural validation /////////////

const SPACE_REGEX = /\s/;

// for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar
const QNAME_REGEX = /^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i;

// for ID validation as per BPMN Schema (QName - Namespace)
const ID_REGEX = /^[a-z_][\w-.]*$/i;
function validateId(idValue) {
  if (containsSpace(idValue)) {
    return 'Must not contain spaces.';
  }
  if (!ID_REGEX.test(idValue)) {
    if (QNAME_REGEX.test(idValue)) {
      return 'Must not contain prefix.';
    }
    return 'Must be a valid QName.';
  }
}
function containsSpace(value) {
  return SPACE_REGEX.test(value);
}

function KeyEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];
  if (INPUTS.includes(type)) {
    entries.push({
      id: 'key',
      component: Key$1,
      editField: editField,
      field: field,
      isEdited: isEdited$1
    });
  }
  return entries;
}
function Key$1(props) {
  const {
    editField,
    field,
    id
  } = props;
  const formFieldRegistry = useService('formFieldRegistry');
  const debounce = useService('debounce');
  const path = ['key'];
  const getValue = () => {
    return minDash.get(field, path, '');
  };
  const setValue = value => {
    return editField(field, path, value);
  };
  const validate = value => {
    if (minDash.isUndefined(value) || !value.length) {
      return 'Must not be empty.';
    }
    if (/\s/.test(value)) {
      return 'Must not contain spaces.';
    }
    const assigned = formFieldRegistry._keys.assigned(value);
    if (assigned && assigned !== field) {
      return 'Must be unique.';
    }
    return null;
  };
  return TextfieldEntry({
    debounce,
    description: 'Binds to a form variable',
    element: field,
    getValue,
    id,
    label: 'Key',
    setValue,
    validate
  });
}

function simpleStringEntryFactory(options) {
  const {
    id,
    label,
    path,
    props
  } = options;
  const {
    editField,
    field
  } = props;
  return {
    id,
    label,
    path,
    field,
    editField,
    component: SimpleStringComponent,
    isEdited: isEdited$1
  };
}
const SimpleStringComponent = props => {
  const {
    id,
    label,
    path,
    field,
    editField
  } = props;
  const debounce = useService('debounce');
  const getValue = () => minDash.get(field, path, '');
  const setValue = value => editField(field, path, value);
  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label,
    setValue
  });
};

function simpleBoolEntryFactory(options) {
  const {
    id,
    label,
    path,
    props
  } = options;
  const {
    editField,
    field
  } = props;
  return {
    id,
    label,
    path,
    field,
    editField,
    component: SimpleBoolComponent,
    isEdited: isEdited$7
  };
}
const SimpleBoolComponent = props => {
  const {
    id,
    label,
    path,
    field,
    editField
  } = props;
  const getValue = () => minDash.get(field, path, '');
  const setValue = value => editField(field, path, value);
  return CheckboxEntry({
    element: field,
    getValue,
    id,
    label,
    setValue
  });
};

function LabelEntry(props) {
  const {
    field
  } = props;
  const {
    type,
    subtype
  } = field;
  const entries = [];
  if (type === 'datetime') {
    if (subtype === formJsViewer.DATETIME_SUBTYPES.DATE || subtype === formJsViewer.DATETIME_SUBTYPES.DATETIME) {
      entries.push(simpleStringEntryFactory({
        id: 'date-label',
        path: formJsViewer.DATE_LABEL_PATH,
        label: 'Date label',
        props
      }));
    }
    if (subtype === formJsViewer.DATETIME_SUBTYPES.TIME || subtype === formJsViewer.DATETIME_SUBTYPES.DATETIME) {
      entries.push(simpleStringEntryFactory({
        id: 'time-label',
        path: formJsViewer.TIME_LABEL_PATH,
        label: 'Time label',
        props
      }));
    }
  } else if (INPUTS.includes(type) || type === 'button') {
    entries.push(simpleStringEntryFactory({
      id: 'label',
      path: ['label'],
      label: 'Field label',
      props
    }));
  }
  return entries;
}

function SourceEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];
  if (type === 'image') {
    entries.push({
      id: 'source',
      component: Source,
      editField: editField,
      field: field,
      isEdited: isEdited$6
    });
  }
  return entries;
}
function Source(props) {
  const {
    editField,
    field,
    id
  } = props;
  const debounce = useService('debounce');
  const variables = useVariables().map(name => ({
    name
  }));
  const path = ['source'];
  const getValue = () => {
    return minDash.get(field, path, '');
  };
  const setValue = value => {
    return editField(field, path, value);
  };
  return FeelEntry({
    debounce,
    description: 'Expression or static value (link/data URI)',
    element: field,
    feel: 'optional',
    getValue,
    id,
    label: 'Image source',
    setValue,
    variables
  });
}

function TextEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  if (type !== 'text') {
    return [];
  }
  return [{
    id: 'text',
    component: Text,
    editField: editField,
    field: field,
    isEdited: isEdited$6
  }];
}
function Text(props) {
  const {
    editField,
    field,
    id
  } = props;
  const debounce = useService('debounce');
  const variables = useVariables().map(name => ({
    name
  }));
  const path = ['text'];
  const getValue = () => {
    return minDash.get(field, path, '');
  };
  const setValue = value => {
    return editField(field, path, value);
  };
  return FeelTextArea({
    debounce,
    description: 'Use an Expression, Markdown or basic HTML to format.',
    element: field,
    feel: 'optional',
    getValue,
    id,
    label: 'Text',
    rows: 10,
    setValue,
    variables
  });
}

function NumberEntries(props) {
  const {
    editField,
    field,
    id
  } = props;
  const {
    type
  } = field;
  if (type !== 'number') {
    return [];
  }
  const entries = [];
  entries.push({
    id: id + '-decimalDigits',
    component: NumberDecimalDigits,
    isEdited: isEdited$5,
    editField,
    field
  });
  entries.push({
    id: id + '-step',
    component: NumberArrowStep,
    isEdited: isEdited$1,
    editField,
    field
  });
  return entries;
}
function NumberDecimalDigits(props) {
  const {
    editField,
    field,
    id
  } = props;
  const debounce = useService('debounce');
  const getValue = e => minDash.get(field, ['decimalDigits']);
  const setValue = value => editField(field, ['decimalDigits'], value);
  return NumberFieldEntry({
    debounce,
    label: 'Decimal digits',
    element: field,
    step: 'any',
    getValue,
    id,
    setValue,
    validate: value => {
      if (value === undefined || value === null) return;
      if (value < 0) return 'Should be greater than or equal to zero.';
      if (!Number.isInteger(value)) return 'Should be an integer.';
    }
  });
}
function NumberArrowStep(props) {
  const {
    editField,
    field,
    id
  } = props;
  const {
    decimalDigits
  } = field;
  const debounce = useService('debounce');
  const getValue = e => {
    let value = minDash.get(field, ['increment']);
    if (!isValidNumber(value)) return null;
    return value;
  };
  const clearLeadingZeroes = value => {
    if (!value) return value;
    const trimmed = value.replace(/^0+/g, '');
    return (trimmed.startsWith('.') ? '0' : '') + trimmed;
  };
  const setValue = value => editField(field, ['increment'], clearLeadingZeroes(value));
  const decimalDigitsSet = decimalDigits || decimalDigits === 0;
  return TextfieldEntry({
    debounce,
    label: 'Increment',
    element: field,
    getValue,
    id,
    setValue,
    validate: value => {
      if (value === undefined || value === null) return;
      if (!isValidNumber(value)) return 'Should be a valid number.';
      if (Big(value).cmp(0) <= 0) return 'Should be greater than zero.';
      if (decimalDigitsSet) {
        const minimumValue = Big(`1e-${decimalDigits}`);
        if (Big(value).cmp(minimumValue) < 0) return `Should be at least ${minimumValue.toString()}.`;
        if (countDecimals(value) > decimalDigits) return `Should not contain more than ${decimalDigits} decimal digits.`;
      }
    }
  });
}

function NumberSerializationEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  if (type !== 'number') {
    return [];
  }
  const entries = [];
  entries.push({
    id: 'serialize-to-string',
    component: SerializeToString,
    isEdited: isEdited$7,
    editField,
    field
  });
  return entries;
}
function SerializeToString(props) {
  const {
    editField,
    field,
    id
  } = props;
  const {
    defaultValue
  } = field;
  const path = ['serializeToString'];
  const getValue = () => {
    return minDash.get(field, path, '');
  };
  const setValue = value => {
    // Whenever changing the formatting, make sure to change the default value type along with it
    if (defaultValue || defaultValue === 0) {
      editField(field, ['defaultValue'], value ? Big(defaultValue).toFixed() : Number(defaultValue));
    }
    return editField(field, path, value);
  };
  return CheckboxEntry({
    element: field,
    getValue,
    id,
    label: 'Output as string',
    description: 'Allows arbitrary precision values',
    setValue
  });
}

function DateTimeEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type,
    subtype
  } = field;
  if (type !== 'datetime') {
    return [];
  }
  const entries = [{
    id: 'subtype',
    component: DateTimeSubtypeSelect,
    isEdited: isEdited$4,
    editField,
    field
  }];
  if (subtype === formJsViewer.DATETIME_SUBTYPES.TIME || subtype === formJsViewer.DATETIME_SUBTYPES.DATETIME) {
    entries.push({
      id: 'use24h',
      component: Use24h,
      isEdited: isEdited$7,
      editField,
      field
    });
  }
  return entries;
}
function DateTimeSubtypeSelect(props) {
  const {
    editField,
    field,
    id
  } = props;
  const getValue = e => minDash.get(field, formJsViewer.DATETIME_SUBTYPE_PATH);
  const clearTimeConfig = () => {
    const timeConfigPaths = [formJsViewer.TIME_LABEL_PATH, formJsViewer.TIME_USE24H_PATH, formJsViewer.TIME_INTERVAL_PATH, formJsViewer.TIME_SERIALISING_FORMAT_PATH];
    for (const path of timeConfigPaths) {
      editField(field, path, undefined);
    }
  };
  const initTimeConfig = () => {
    editField(field, formJsViewer.TIME_LABEL_PATH, 'Time');
    editField(field, formJsViewer.TIME_SERIALISING_FORMAT_PATH, formJsViewer.TIME_SERIALISING_FORMATS.UTC_OFFSET);
    editField(field, formJsViewer.TIME_INTERVAL_PATH, 15);
  };
  const clearDateConfig = () => {
    const dateConfigPaths = [formJsViewer.DATE_LABEL_PATH, formJsViewer.DATE_DISALLOW_PAST_PATH];
    for (const path of dateConfigPaths) {
      editField(field, path, undefined);
    }
  };
  const initDateConfig = () => {
    editField(field, formJsViewer.DATE_LABEL_PATH, 'Date');
  };
  const setValue = value => {
    const oldValue = getValue();
    if (oldValue === value) return;
    if (value === formJsViewer.DATETIME_SUBTYPES.DATE) {
      clearTimeConfig();
      oldValue === formJsViewer.DATETIME_SUBTYPES.TIME && initDateConfig();
    } else if (value === formJsViewer.DATETIME_SUBTYPES.TIME) {
      clearDateConfig();
      oldValue === formJsViewer.DATETIME_SUBTYPES.DATE && initTimeConfig();
    } else if (value === formJsViewer.DATETIME_SUBTYPES.DATETIME) {
      oldValue === formJsViewer.DATETIME_SUBTYPES.DATE && initTimeConfig();
      oldValue === formJsViewer.DATETIME_SUBTYPES.TIME && initDateConfig();
    }
    return editField(field, formJsViewer.DATETIME_SUBTYPE_PATH, value);
  };
  const getDatetimeSubtypes = () => {
    return Object.values(formJsViewer.DATETIME_SUBTYPES).map(subtype => ({
      label: formJsViewer.DATETIME_SUBTYPES_LABELS[subtype],
      value: subtype
    }));
  };
  return SelectEntry({
    label: 'Subtype',
    element: field,
    getOptions: getDatetimeSubtypes,
    getValue,
    id,
    setValue
  });
}
function Use24h(props) {
  const {
    editField,
    field,
    id
  } = props;
  const path = formJsViewer.TIME_USE24H_PATH;
  const getValue = () => {
    return minDash.get(field, path, '');
  };
  const setValue = value => {
    return editField(field, path, value);
  };
  return CheckboxEntry({
    element: field,
    getValue,
    id,
    label: 'Use 24h',
    setValue
  });
}

function DateTimeConstraintsEntry(props) {
  const {
    editField,
    field,
    id
  } = props;
  const {
    type,
    subtype
  } = field;
  if (type !== 'datetime') {
    return [];
  }
  const entries = [];
  if (subtype === formJsViewer.DATETIME_SUBTYPES.TIME || subtype === formJsViewer.DATETIME_SUBTYPES.DATETIME) {
    entries.push({
      id: id + '-timeInterval',
      component: TimeIntervalSelect,
      isEdited: isEdited$4,
      editField,
      field
    });
  }
  if (subtype === formJsViewer.DATETIME_SUBTYPES.DATE || subtype === formJsViewer.DATETIME_SUBTYPES.DATETIME) {
    entries.push({
      id: id + '-disallowPassedDates',
      component: DisallowPassedDates,
      isEdited: isEdited$7,
      editField,
      field
    });
  }
  return entries;
}
function DisallowPassedDates(props) {
  const {
    editField,
    field,
    id
  } = props;
  const path = formJsViewer.DATE_DISALLOW_PAST_PATH;
  const getValue = () => {
    return minDash.get(field, path, '');
  };
  const setValue = value => {
    return editField(field, path, value);
  };
  return CheckboxEntry({
    element: field,
    getValue,
    id,
    label: 'Disallow past dates',
    setValue
  });
}
function TimeIntervalSelect(props) {
  const {
    editField,
    field,
    id
  } = props;
  const timeIntervals = [1, 5, 10, 15, 30, 60];
  const getValue = e => minDash.get(field, formJsViewer.TIME_INTERVAL_PATH);
  const setValue = value => editField(field, formJsViewer.TIME_INTERVAL_PATH, parseInt(value));
  const getTimeIntervals = () => {
    return timeIntervals.map(timeInterval => ({
      label: timeInterval === 60 ? '1h' : timeInterval + 'm',
      value: timeInterval
    }));
  };
  return SelectEntry({
    label: 'Time interval',
    element: field,
    getOptions: getTimeIntervals,
    getValue,
    id,
    setValue
  });
}

function DateTimeFormatEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type,
    subtype
  } = field;
  if (type !== 'datetime') {
    return [];
  }
  const entries = [];
  if (subtype === formJsViewer.DATETIME_SUBTYPES.TIME || subtype === formJsViewer.DATETIME_SUBTYPES.DATETIME) {
    entries.push({
      id: 'time-format',
      component: TimeFormatSelect,
      isEdited: isEdited$4,
      editField,
      field
    });
  }
  return entries;
}
function TimeFormatSelect(props) {
  const {
    editField,
    field,
    id
  } = props;
  const getValue = e => minDash.get(field, formJsViewer.TIME_SERIALISING_FORMAT_PATH);
  const setValue = value => editField(field, formJsViewer.TIME_SERIALISING_FORMAT_PATH, value);
  const getTimeSerialisingFormats = () => {
    return Object.values(formJsViewer.TIME_SERIALISING_FORMATS).map(format => ({
      label: formJsViewer.TIME_SERIALISINGFORMAT_LABELS[format],
      value: format
    }));
  };
  return SelectEntry({
    label: 'Time format',
    element: field,
    getOptions: getTimeSerialisingFormats,
    getValue,
    id,
    setValue
  });
}

function SelectEntries(props) {
  const {
    field
  } = props;
  const {
    type
  } = field;
  if (type !== 'select') {
    return [];
  }
  const entries = [simpleBoolEntryFactory({
    id: 'searchable',
    path: ['searchable'],
    label: 'Searchable',
    props
  })];
  return entries;
}

function ValueEntry(props) {
  const {
    editField,
    field,
    idPrefix,
    index,
    validateFactory
  } = props;
  const entries = [{
    component: Label,
    editField,
    field,
    id: idPrefix + '-label',
    idPrefix,
    index,
    validateFactory
  }, {
    component: Value$1,
    editField,
    field,
    id: idPrefix + '-value',
    idPrefix,
    index,
    validateFactory
  }];
  return entries;
}
function Label(props) {
  const {
    editField,
    field,
    id,
    index,
    validateFactory
  } = props;
  const debounce = useService('debounce');
  const setValue = value => {
    const values = minDash.get(field, ['values']);
    return editField(field, 'values', minDash.set(values, [index, 'label'], value));
  };
  const getValue = () => {
    return minDash.get(field, ['values', index, 'label']);
  };
  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label: 'Label',
    setValue,
    validate: validateFactory(getValue())
  });
}
function Value$1(props) {
  const {
    editField,
    field,
    id,
    index,
    validateFactory
  } = props;
  const debounce = useService('debounce');
  const setValue = value => {
    const values = minDash.get(field, ['values']);
    return editField(field, 'values', minDash.set(values, [index, 'value'], value));
  };
  const getValue = () => {
    return minDash.get(field, ['values', index, 'value']);
  };
  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label: 'Value',
    setValue,
    validate: validateFactory(getValue())
  });
}

function CustomValueEntry(props) {
  const {
    editField,
    field,
    idPrefix,
    index,
    validateFactory
  } = props;
  const entries = [{
    component: Key,
    editField,
    field,
    id: idPrefix + '-key',
    idPrefix,
    index,
    validateFactory
  }, {
    component: Value,
    editField,
    field,
    id: idPrefix + '-value',
    idPrefix,
    index,
    validateFactory
  }];
  return entries;
}
function Key(props) {
  const {
    editField,
    field,
    id,
    index,
    validateFactory
  } = props;
  const debounce = useService('debounce');
  const setValue = value => {
    const properties = minDash.get(field, ['properties']);
    const key = Object.keys(properties)[index];
    return editField(field, 'properties', updateKey(properties, key, value));
  };
  const getValue = () => {
    return Object.keys(minDash.get(field, ['properties']))[index];
  };
  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label: 'Key',
    setValue,
    validate: validateFactory(getValue())
  });
}
function Value(props) {
  const {
    editField,
    field,
    id,
    index,
    validateFactory
  } = props;
  const debounce = useService('debounce');
  const setValue = value => {
    const properties = minDash.get(field, ['properties']);
    const key = Object.keys(properties)[index];
    editField(field, 'properties', updateValue(properties, key, value));
  };
  const getValue = () => {
    const properties = minDash.get(field, ['properties']);
    const key = Object.keys(properties)[index];
    return minDash.get(field, ['properties', key]);
  };
  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label: 'Value',
    setValue,
    validate: validateFactory(getValue())
  });
}

// helpers //////////

/**
 * Returns copy of object with updated value.
 *
 * @param {Object} properties
 * @param {string} key
 * @param {string} value
 *
 * @returns {Object}
 */
function updateValue(properties, key, value) {
  return {
    ...properties,
    [key]: value
  };
}

/**
 * Returns copy of object with updated key.
 *
 * @param {Object} properties
 * @param {string} oldKey
 * @param {string} newKey
 *
 * @returns {Object}
 */
function updateKey(properties, oldKey, newKey) {
  return Object.entries(properties).reduce((newProperties, entry) => {
    const [key, value] = entry;
    return {
      ...newProperties,
      [key === oldKey ? newKey : key]: value
    };
  }, {});
}

function ValuesSourceSelectEntry(props) {
  const {
    editField,
    field,
    id
  } = props;
  return [{
    id: id + '-select',
    component: ValuesSourceSelect,
    isEdited: isEdited$4,
    editField,
    field
  }];
}
function ValuesSourceSelect(props) {
  const {
    editField,
    field,
    id
  } = props;
  const getValue = formJsViewer.getValuesSource;
  const setValue = value => {
    let newField = field;
    const newProperties = {};
    Object.values(formJsViewer.VALUES_SOURCES).forEach(source => {
      // Clear all values source definitions and default the newly selected one
      const newValue = value === source ? formJsViewer.VALUES_SOURCES_DEFAULTS[source] : undefined;
      newProperties[formJsViewer.VALUES_SOURCES_PATHS[source]] = newValue;
    });
    newField = editField(field, newProperties);
    return newField;
  };
  const getValuesSourceOptions = () => {
    return Object.values(formJsViewer.VALUES_SOURCES).map(valueSource => ({
      label: formJsViewer.VALUES_SOURCES_LABELS[valueSource],
      value: valueSource
    }));
  };
  return SelectEntry({
    label: 'Type',
    element: field,
    getOptions: getValuesSourceOptions,
    getValue,
    id,
    setValue
  });
}

function InputKeyValuesSourceEntry(props) {
  const {
    editField,
    field,
    id
  } = props;
  return [{
    id: id + '-key',
    component: InputValuesKey,
    label: 'Input values key',
    description: 'Define which input property to populate the values from',
    isEdited: isEdited$1,
    editField,
    field
  }];
}
function InputValuesKey(props) {
  const {
    editField,
    field,
    id,
    label,
    description
  } = props;
  const debounce = useService('debounce');
  const path = formJsViewer.VALUES_SOURCES_PATHS[formJsViewer.VALUES_SOURCES.INPUT];
  const getValue = () => minDash.get(field, path, '');
  const setValue = value => editField(field, path, value || '');
  const validate = value => {
    if (minDash.isUndefined(value) || !value.length) {
      return 'Must not be empty.';
    }
    if (/\s/.test(value)) {
      return 'Must not contain spaces.';
    }
    return null;
  };
  return TextfieldEntry({
    debounce,
    description,
    element: field,
    getValue,
    id,
    label,
    setValue,
    validate
  });
}

function StaticValuesSourceEntry(props) {
  const {
    editField,
    field,
    id: idPrefix
  } = props;
  const {
    values
  } = field;
  const addEntry = e => {
    e.stopPropagation();
    const index = values.length + 1;
    const entry = getIndexedEntry(index);
    editField(field, formJsViewer.VALUES_SOURCES_PATHS[formJsViewer.VALUES_SOURCES.STATIC], arrayAdd(values, values.length, entry));
  };
  const removeEntry = entry => {
    editField(field, formJsViewer.VALUES_SOURCES_PATHS[formJsViewer.VALUES_SOURCES.STATIC], minDash.without(values, entry));
  };
  const validateFactory = key => {
    return value => {
      if (value === key) {
        return;
      }
      if (minDash.isUndefined(value) || !value.length) {
        return 'Must not be empty.';
      }
      const isValueAssigned = values.find(entry => entry.value === value);
      if (isValueAssigned) {
        return 'Must be unique.';
      }
    };
  };
  const items = values.map((entry, index) => {
    const id = idPrefix + '-' + index;
    return {
      id,
      label: entry.label,
      entries: ValueEntry({
        editField,
        field,
        idPrefix: id,
        index,
        validateFactory
      }),
      autoFocusEntry: id + '-label',
      remove: () => removeEntry(entry)
    };
  });
  return {
    items,
    add: addEntry,
    shouldSort: false
  };
}

// helper

function getIndexedEntry(index) {
  const entry = {
    label: 'Value',
    value: 'value'
  };
  if (index > 1) {
    entry.label += ` ${index}`;
    entry.value += `${index}`;
  }
  return entry;
}

function AdornerEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];
  const onChange = key => {
    return value => {
      const appearance = minDash.get(field, ['appearance'], {});
      editField(field, ['appearance'], minDash.set(appearance, [key], value));
    };
  };
  const getValue = key => {
    return () => {
      return minDash.get(field, ['appearance', key]);
    };
  };
  if (['number', 'textfield'].includes(type)) {
    entries.push({
      id: 'prefix-adorner',
      component: PrefixAdorner,
      isEdited: isEdited$1,
      editField,
      field,
      onChange,
      getValue
    });
    entries.push({
      id: 'suffix-adorner',
      component: SuffixAdorner,
      isEdited: isEdited$1,
      editField,
      field,
      onChange,
      getValue
    });
  }
  return entries;
}
function PrefixAdorner(props) {
  const {
    field,
    id,
    onChange,
    getValue
  } = props;
  const debounce = useService('debounce');
  return TextfieldEntry({
    debounce,
    element: field,
    getValue: getValue('prefixAdorner'),
    id,
    label: 'Prefix',
    setValue: onChange('prefixAdorner')
  });
}
function SuffixAdorner(props) {
  const {
    field,
    id,
    onChange,
    getValue
  } = props;
  const debounce = useService('debounce');
  return TextfieldEntry({
    debounce,
    element: field,
    getValue: getValue('suffixAdorner'),
    id,
    label: 'Suffix',
    setValue: onChange('suffixAdorner')
  });
}

function ConditionEntry(props) {
  const {
    editField,
    field
  } = props;
  return [{
    id: 'conditional-hide',
    component: Condition,
    editField: editField,
    field: field,
    isEdited: isEdited$6
  }];
}
function Condition(props) {
  const {
    editField,
    field,
    id
  } = props;
  const debounce = useService('debounce');
  const variables = useVariables().map(name => ({
    name
  }));
  const path = ['conditional', 'hide'];
  const getValue = () => {
    return minDash.get(field, path, '');
  };
  const setValue = value => {
    if (!value) {
      return editField(field, 'conditional', undefined);
    }
    return editField(field, 'conditional', {
      hide: value
    });
  };
  return FeelEntry({
    debounce,
    description: 'Condition under which the field is hidden',
    element: field,
    feel: 'required',
    getValue,
    id,
    label: 'Hide if',
    setValue,
    variables
  });
}

function GeneralGroup(field, editField) {
  const entries = [...IdEntry({
    field,
    editField
  }), ...LabelEntry({
    field,
    editField
  }), ...DescriptionEntry({
    field,
    editField
  }), ...KeyEntry({
    field,
    editField
  }), ...DefaultOptionEntry({
    field,
    editField
  }), ...ActionEntry({
    field,
    editField
  }), ...ColumnsEntry({
    field,
    editField
  }), ...DateTimeEntry({
    field,
    editField
  }), ...TextEntry({
    field,
    editField
  }), ...NumberEntries({
    field,
    editField
  }), ...SourceEntry({
    field,
    editField
  }), ...AltTextEntry({
    field,
    editField
  }), ...SelectEntries({
    field,
    editField
  }), ...DisabledEntry({
    field,
    editField
  })];
  return {
    id: 'general',
    label: 'General',
    entries
  };
}

function SerializationGroup(field, editField) {
  const entries = [...NumberSerializationEntry({
    field,
    editField
  }), ...DateTimeFormatEntry({
    field,
    editField
  })];
  if (!entries.length) {
    return null;
  }
  return {
    id: 'serialization',
    label: 'Serialization',
    entries
  };
}

function ConstraintsGroup(field, editField) {
  const entries = [...DateTimeConstraintsEntry({
    field,
    editField
  })];
  if (!entries.length) {
    return null;
  }
  return {
    id: 'constraints',
    label: 'Constraints',
    entries
  };
}

const VALIDATION_TYPE_OPTIONS = {
  custom: {
    value: '',
    label: 'Custom'
  },
  email: {
    value: 'email',
    label: 'Email'
  },
  phone: {
    value: 'phone',
    label: 'Phone'
  }
};
function ValidationGroup(field, editField) {
  const {
    type
  } = field;
  const validate = minDash.get(field, ['validate'], {});
  const isCustomValidation = [undefined, VALIDATION_TYPE_OPTIONS.custom.value].includes(validate.validationType);
  if (!(INPUTS.includes(type) && type !== 'checkbox' && type !== 'checklist' && type !== 'taglist')) {
    return null;
  }
  const onChange = key => {
    return value => {
      const validate = minDash.get(field, ['validate'], {});
      editField(field, ['validate'], minDash.set(validate, [key], value));
    };
  };
  const getValue = key => {
    return () => {
      return minDash.get(field, ['validate', key]);
    };
  };
  let entries = [{
    id: 'required',
    component: Required,
    getValue,
    field,
    isEdited: isEdited$7,
    onChange
  }];
  if (type === 'textfield') {
    entries.push({
      id: 'validationType',
      component: ValidationType,
      getValue,
      field,
      editField,
      isEdited: isEdited$1,
      onChange
    });
  }
  if (type === 'textarea' || type === 'textfield' && isCustomValidation) {
    entries.push({
      id: 'minLength',
      component: MinLength,
      getValue,
      field,
      isEdited: isEdited$5,
      onChange
    }, {
      id: 'maxLength',
      component: MaxLength,
      getValue,
      field,
      isEdited: isEdited$5,
      onChange
    });
  }
  if (type === 'textfield' && isCustomValidation) {
    entries.push({
      id: 'pattern',
      component: Pattern,
      getValue,
      field,
      isEdited: isEdited$1,
      onChange
    });
  }
  if (type === 'number') {
    entries.push({
      id: 'min',
      component: Min,
      getValue,
      field,
      isEdited: isEdited$5,
      onChange
    }, {
      id: 'max',
      component: Max,
      getValue,
      field,
      isEdited: isEdited$5,
      onChange
    });
  }
  return {
    id: 'validation',
    label: 'Validation',
    entries
  };
}
function Required(props) {
  const {
    field,
    getValue,
    id,
    onChange
  } = props;
  return CheckboxEntry({
    element: field,
    getValue: getValue('required'),
    id,
    label: 'Required',
    setValue: onChange('required')
  });
}
function MinLength(props) {
  const {
    field,
    getValue,
    id,
    onChange
  } = props;
  const debounce = useService('debounce');
  return NumberFieldEntry({
    debounce,
    element: field,
    getValue: getValue('minLength'),
    id,
    label: 'Minimum length',
    min: 0,
    setValue: onChange('minLength')
  });
}
function MaxLength(props) {
  const {
    field,
    getValue,
    id,
    onChange
  } = props;
  const debounce = useService('debounce');
  return NumberFieldEntry({
    debounce,
    element: field,
    getValue: getValue('maxLength'),
    id,
    label: 'Maximum length',
    min: 0,
    setValue: onChange('maxLength')
  });
}
function Pattern(props) {
  const {
    field,
    getValue,
    id,
    onChange
  } = props;
  const debounce = useService('debounce');
  return TextfieldEntry({
    debounce,
    element: field,
    getValue: getValue('pattern'),
    id,
    label: 'Custom regular expression',
    setValue: onChange('pattern')
  });
}
function Min(props) {
  const {
    field,
    getValue,
    id,
    onChange
  } = props;
  const debounce = useService('debounce');
  return NumberFieldEntry({
    debounce,
    element: field,
    id,
    label: 'Minimum',
    step: 'any',
    getValue: getValue('min'),
    setValue: onChange('min')
  });
}
function Max(props) {
  const {
    field,
    getValue,
    id,
    onChange
  } = props;
  const debounce = useService('debounce');
  return NumberFieldEntry({
    debounce,
    element: field,
    id,
    label: 'Maximum',
    step: 'any',
    getValue: getValue('max'),
    setValue: onChange('max')
  });
}
function ValidationType(props) {
  const {
    field,
    getValue,
    id,
    onChange
  } = props;
  const debounce = useService('debounce');
  const setValue = validationType => {
    onChange('validationType')(validationType || undefined);
  };
  return SelectEntry({
    debounce,
    element: field,
    getValue: getValue('validationType'),
    id,
    label: 'Validation pattern',
    setValue,
    getOptions: () => Object.values(VALIDATION_TYPE_OPTIONS)
  });
}

function ValuesGroups(field, editField) {
  const {
    type,
    id: fieldId
  } = field;
  if (!VALUES_INPUTS.includes(type)) {
    return [];
  }
  const context = {
    editField,
    field
  };
  const valuesSourceId = `${fieldId}-valuesSource`;

  /**
   * @type {Array<Group|ListGroup>}
   */
  const groups = [{
    id: valuesSourceId,
    label: 'Options source',
    component: Group,
    entries: ValuesSourceSelectEntry({
      ...context,
      id: valuesSourceId
    })
  }];
  const valuesSource = formJsViewer.getValuesSource(field);
  if (valuesSource === formJsViewer.VALUES_SOURCES.INPUT) {
    const dynamicValuesId = `${fieldId}-dynamicValues`;
    groups.push({
      id: dynamicValuesId,
      label: 'Dynamic options',
      component: Group,
      entries: InputKeyValuesSourceEntry({
        ...context,
        id: dynamicValuesId
      })
    });
  } else if (valuesSource === formJsViewer.VALUES_SOURCES.STATIC) {
    const staticValuesId = `${fieldId}-staticValues`;
    groups.push({
      id: staticValuesId,
      label: 'Static options',
      component: ListGroup,
      ...StaticValuesSourceEntry({
        ...context,
        id: staticValuesId
      })
    });
  }
  return groups;
}

function CustomValuesGroup(field, editField) {
  const {
    properties = {},
    type
  } = field;
  if (type === 'default') {
    return null;
  }
  const addEntry = event => {
    event.stopPropagation();
    const index = Object.keys(properties).length + 1;
    const key = `key${index}`,
      value = 'value';
    editField(field, ['properties'], {
      ...properties,
      [key]: value
    });
  };
  const validateFactory = key => {
    return value => {
      if (value === key) {
        return;
      }
      if (minDash.isUndefined(value) || !value.length) {
        return 'Must not be empty.';
      }
      if (minDash.has(properties, value)) {
        return 'Must be unique.';
      }
    };
  };
  const items = Object.keys(properties).map((key, index) => {
    const removeEntry = event => {
      event.stopPropagation();
      return editField(field, ['properties'], removeKey(properties, key));
    };
    const id = `${field.id}-property-${index}`;
    return {
      autoFocusEntry: id + '-key',
      entries: CustomValueEntry({
        editField,
        field,
        idPrefix: id,
        index,
        validateFactory
      }),
      id,
      label: key || '',
      remove: removeEntry
    };
  });
  return {
    add: addEntry,
    component: ListGroup,
    id: 'custom-values',
    items,
    label: 'Custom properties',
    shouldSort: false
  };
}

// helpers //////////

/**
 * Returns copy of object without key.
 *
 * @param {Object} properties
 * @param {string} oldKey
 *
 * @returns {Object}
 */
function removeKey(properties, oldKey) {
  return Object.entries(properties).reduce((newProperties, entry) => {
    const [key, value] = entry;
    if (key === oldKey) {
      return newProperties;
    }
    return {
      ...newProperties,
      [key]: value
    };
  }, {});
}

function AppearanceGroup(field, editField) {
  const entries = [...AdornerEntry({
    field,
    editField
  })];
  if (!entries.length) {
    return null;
  }
  return {
    id: 'appearance',
    label: 'Appearance',
    entries
  };
}

function ConditionGroup(field, editField) {
  const {
    type
  } = field;
  if (type === 'default') {
    return null;
  }
  const entries = [...ConditionEntry({
    field,
    editField
  })];
  return {
    id: 'condition',
    label: 'Condition',
    entries
  };
}

function getGroups(field, editField) {
  if (!field) {
    return [];
  }
  const groups = [GeneralGroup(field, editField), ConditionGroup(field, editField), AppearanceGroup(field, editField), SerializationGroup(field, editField), ...ValuesGroups(field, editField), ConstraintsGroup(field, editField), ValidationGroup(field, editField), CustomValuesGroup(field, editField)];

  // contract: if a group returns null, it should not be displayed at all
  return groups.filter(group => group !== null);
}
function FormPropertiesPanel(props) {
  const {
    eventBus,
    injector
  } = props;
  const formEditor = injector.get('formEditor');
  const modeling = injector.get('modeling');
  const selection = injector.get('selection');
  const {
    schema
  } = formEditor._getState();
  const [state, setState] = hooks$1.useState({
    selectedFormField: selection.get() || schema
  });
  const _update = field => {
    setState({
      ...state,
      selectedFormField: field
    });

    // notify interested parties on property panel updates
    eventBus.fire('propertiesPanel.updated', {
      formField: field
    });
  };
  hooks$1.useLayoutEffect(() => {
    function onSelectionChange(event) {
      _update(event.selection || schema);
    }
    eventBus.on('selection.changed', onSelectionChange);
    return () => {
      eventBus.off('selection.changed', onSelectionChange);
    };
  }, []);
  hooks$1.useLayoutEffect(() => {
    const onFieldChanged = () => {
      /**
       * TODO(pinussilvestrus): update with actual updated element,
       * once we have a proper updater/change support
       */
      _update(selection.get() || schema);
    };
    eventBus.on('changed', onFieldChanged);
    return () => {
      eventBus.off('changed', onFieldChanged);
    };
  }, []);
  const selectedFormField = state.selectedFormField;
  const propertiesPanelContext = {
    getService(type, strict = true) {
      return injector.get(type, strict);
    }
  };
  const onFocus = () => eventBus.fire('propertiesPanel.focusin');
  const onBlur = () => eventBus.fire('propertiesPanel.focusout');
  const editField = hooks$1.useCallback((formField, key, value) => modeling.editFormField(formField, key, value), [modeling]);
  return jsxRuntime.jsx("div", {
    class: "fjs-properties-panel",
    "data-field": selectedFormField && selectedFormField.id,
    onFocusCapture: onFocus,
    onBlurCapture: onBlur,
    children: jsxRuntime.jsx(FormPropertiesPanelContext.Provider, {
      value: propertiesPanelContext,
      children: jsxRuntime.jsx(PropertiesPanel, {
        element: selectedFormField,
        eventBus: eventBus,
        groups: getGroups(selectedFormField, editField),
        headerProvider: PropertiesPanelHeaderProvider,
        placeholderProvider: PropertiesPanelPlaceholderProvider
      })
    })
  });
}

class PropertiesPanelRenderer {
  constructor(propertiesPanelConfig, injector, eventBus) {
    const {
      parent
    } = propertiesPanelConfig || {};
    this._eventBus = eventBus;
    this._injector = injector;
    this._container = minDom.domify('<div class="fjs-properties-container" input-handle-modified-keys="y,z"></div>');
    if (parent) {
      this.attachTo(parent);
    }
    this._eventBus.once('formEditor.rendered', 500, () => {
      this._render();
    });
  }

  /**
   * Attach the properties panel to a parent node.
   *
   * @param {HTMLElement} container
   */
  attachTo(container) {
    if (!container) {
      throw new Error('container required');
    }
    if (typeof container === 'string') {
      container = minDom.query(container);
    }

    // (1) detach from old parent
    this.detach();

    // (2) append to parent container
    container.appendChild(this._container);

    // (3) notify interested parties
    this._eventBus.fire('propertiesPanel.attach');
  }

  /**
   * Detach the properties panel from its parent node.
   */
  detach() {
    const parentNode = this._container.parentNode;
    if (parentNode) {
      parentNode.removeChild(this._container);
      this._eventBus.fire('propertiesPanel.detach');
    }
  }
  _render() {
    preact.render(jsxRuntime.jsx(FormPropertiesPanel, {
      eventBus: this._eventBus,
      injector: this._injector
    }), this._container);
    this._eventBus.fire('propertiesPanel.rendered');
  }
  _destroy() {
    if (this._container) {
      preact.render(null, this._container);
      this._eventBus.fire('propertiesPanel.destroyed');
    }
  }
}
PropertiesPanelRenderer.$inject = ['config.propertiesPanel', 'injector', 'eventBus'];

var PropertiesPanelModule = {
  __init__: ['propertiesPanel'],
  propertiesPanel: ['type', PropertiesPanelRenderer]
};

const ids = new Ids([32, 36, 1]);

/**
 * @typedef { import('./types').Injector } Injector
 * @typedef { import('./types').Module } Module
 * @typedef { import('./types').Schema } Schema
 *
 * @typedef { import('./types').FormEditorOptions } FormEditorOptions
 * @typedef { import('./types').FormEditorProperties } FormEditorProperties
 *
 * @typedef { {
 *   properties: FormEditorProperties,
 *   schema: Schema
 * } } State
 *
 * @typedef { (type:string, priority:number, handler:Function) => void } OnEventWithPriority
 * @typedef { (type:string, handler:Function) => void } OnEventWithOutPriority
 * @typedef { OnEventWithPriority & OnEventWithOutPriority } OnEventType
 */

/**
 * The form editor.
 */
class FormEditor {
  /**
   * @constructor
   * @param {FormEditorOptions} options
   */
  constructor(options = {}) {
    /**
     * @public
     * @type {OnEventType}
     */
    this.on = this._onEvent;

    /**
     * @public
     * @type {String}
     */
    this._id = ids.next();

    /**
     * @private
     * @type {Element}
     */
    this._container = formJsViewer.createFormContainer();
    this._container.setAttribute('input-handle-modified-keys', 'z,y');
    const {
      container,
      exporter,
      injector = this._createInjector(options, this._container),
      properties = {}
    } = options;

    /**
     * @private
     * @type {any}
     */
    this.exporter = exporter;

    /**
     * @private
     * @type {State}
     */
    this._state = {
      properties,
      schema: null
    };
    this.get = injector.get;
    this.invoke = injector.invoke;
    this.get('eventBus').fire('form.init');
    if (container) {
      this.attachTo(container);
    }
  }
  clear() {
    // clear form services
    this._emit('diagram.clear');

    // clear diagram services (e.g. EventBus)
    this._emit('form.clear');
  }
  destroy() {
    // destroy form services
    this.get('eventBus').fire('form.destroy');

    // destroy diagram services (e.g. EventBus)
    this.get('eventBus').fire('diagram.destroy');
    this._detach(false);
  }

  /**
   * @param {Schema} schema
   *
   * @return {Promise<{ warnings: Array<any> }>}
   */
  importSchema(schema) {
    return new Promise((resolve, reject) => {
      try {
        this.clear();
        const {
          schema: importedSchema,
          warnings
        } = this.get('importer').importSchema(schema);
        this._setState({
          schema: importedSchema
        });
        this._emit('import.done', {
          warnings
        });
        return resolve({
          warnings
        });
      } catch (error) {
        this._emit('import.done', {
          error: error,
          warnings: error.warnings || []
        });
        return reject(error);
      }
    });
  }

  /**
   * @returns {Schema}
   */
  saveSchema() {
    return this.getSchema();
  }

  /**
   * @returns {Schema}
   */
  getSchema() {
    const {
      schema
    } = this._getState();
    return exportSchema(schema, this.exporter, formJsViewer.schemaVersion);
  }

  /**
   * @param {Element|string} parentNode
   */
  attachTo(parentNode) {
    if (!parentNode) {
      throw new Error('parentNode required');
    }
    this.detach();
    if (minDash.isString(parentNode)) {
      parentNode = document.querySelector(parentNode);
    }
    const container = this._container;
    parentNode.appendChild(container);
    this._emit('attach');
  }
  detach() {
    this._detach();
  }

  /**
   * @internal
   *
   * @param {boolean} [emit]
   */
  _detach(emit = true) {
    const container = this._container,
      parentNode = container.parentNode;
    if (!parentNode) {
      return;
    }
    if (emit) {
      this._emit('detach');
    }
    parentNode.removeChild(container);
  }

  /**
   * @param {any} property
   * @param {any} value
   */
  setProperty(property, value) {
    const properties = minDash.set(this._getState().properties, [property], value);
    this._setState({
      properties
    });
  }

  /**
   * @param {string} type
   * @param {Function} handler
   */
  off(type, handler) {
    this.get('eventBus').off(type, handler);
  }

  /**
   * @internal
   *
   * @param {FormEditorOptions} options
   * @param {Element} container
   *
   * @returns {Injector}
   */
  _createInjector(options, container) {
    const {
      additionalModules = [],
      modules = this._getModules(),
      renderer = {}
    } = options;
    const config = {
      ...options,
      renderer: {
        ...renderer,
        container
      }
    };
    return formJsViewer.createInjector([{
      config: ['value', config]
    }, {
      formEditor: ['value', this]
    }, core, ...modules, ...additionalModules]);
  }

  /**
   * @internal
   */
  _emit(type, data) {
    this.get('eventBus').fire(type, data);
  }

  /**
   * @internal
   */
  _getState() {
    return this._state;
  }

  /**
   * @internal
   */
  _setState(state) {
    this._state = {
      ...this._state,
      ...state
    };
    this._emit('changed', this._getState());
  }

  /**
   * @internal
   */
  _getModules() {
    return [ModelingModule, EditorActionsModule, KeyboardModule, SelectionModule, PaletteModule, PropertiesPanelModule];
  }

  /**
   * @internal
   */
  _onEvent(type, priority, handler) {
    this.get('eventBus').on(type, priority, handler);
  }
}

// helpers //////////

function exportSchema(schema, exporter, schemaVersion) {
  const exportDetails = exporter ? {
    exporter
  } : {};
  const cleanedSchema = formJsViewer.clone(schema, (name, value) => {
    if (['_parent', '_path'].includes(name)) {
      return undefined;
    }
    return value;
  });
  return {
    ...cleanedSchema,
    ...exportDetails,
    schemaVersion
  };
}

/**
 * @typedef { import('./types').CreateFormEditorOptions } CreateFormEditorOptions
 */

/**
 * Create a form editor.
 *
 * @param {CreateFormEditorOptions} options
 *
 * @return {Promise<FormEditor>}
 */
function createFormEditor(options) {
  const {
    schema,
    ...rest
  } = options;
  const formEditor = new FormEditor(rest);
  return formEditor.importSchema(schema).then(() => {
    return formEditor;
  });
}

Object.defineProperty(exports, 'schemaVersion', {
  enumerable: true,
  get: function () { return formJsViewer.schemaVersion; }
});
exports.FormEditor = FormEditor;
exports.createFormEditor = createFormEditor;
//# sourceMappingURL=index.cjs.map
